<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Travaux pratiques de confiance électronique</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />

<script type="text/javascript" src="toc.js"></script>
<script type="text/javascript">
function init() {
    var Body = document.getElementById('bodyid');
    var ToC  = ToCwalk(Body);
    ToC.id   = 'ToCul';
    document.getElementById('ToCbox').appendChild(ToC);
}
</script>
    
</head>
<body id="bodyid" onload="init();">
<div class="titlepage">
<div id="title">Travaux pratiques de confiance électronique</div>
<div id="author">Sébastien Pujadas</div>
</div>

<div class="frontmatter">

<h1 id="toc">Table des matières</h1>

<div id="ToCbox"></div>

<h1 id="preface">Préface</h1>

<p>La confiance électronique est un domaine assez méconnu de l'informatique, dont l'usage se limite la plupart du temps à la génération et installation de certificats d'application pour permettre l'accès à des serveurs web en HTTPS. Il s'agit pourtant d'un sujet passionnant et riche dont le potentiel (signature électronique notamment) n'est pas encore pleinement exprimé. J'ai eu le plaisir de travailler sur des projets mettant en œuvre des éléments de confiance électronique pendant une dizaine d'années, explorant souvent un terrain encore en friche, parsemé de normes et implémentations parfois instables ou contradictoires et de formats d'un abord hermétique, le tout sur un fond de cryptographie qui en a certainement découragé plus d'un. Conséquence ou facteur aggravant, il a toujours été difficile de trouver des ressources sur le sujet, et tous ceux qui ont voulu approfondir leurs connaissances ont dû découvrir séparément comment utiliser le peu d'outils disponibles, en en créant de nouveaux au besoin pour aller plus loin. J'avais initialement prévu d'écrire et de publier un aide-mémoire pour éviter aux  aventuriers de la confiance électronique de réinventer la roue à leur insu, mais ce projet a pris une toute autre dimension, et le recto-verso que j'avais initialement prévu d'écrire a finalement pris la forme du document que vous avez sous les yeux.</p>

<p>Aux dires des relecteurs – Benjamin Dossat, Cédric Clément et Pierre Lagnier, spécialistes du domaine que je remercie ici – ce livre est exigeant, et écrivant cette préface lors de ma propre relecture plus d'un an après l'écriture initiale, je suis bien obligé de leur donner raison : la notion de « travaux » du titre trouve pleinement son sens ici, mais disons qu'à vaincre sans péril... ;o)</p>

<p>J'espère que ce document vous permettra d'apprécier la confiance électronique en profondeur et vous aidera à contribuer à sa généralisation.</p>

<p class="signature">Sébastien Pujadas</p>
<p class="signature">Châtenay-Malabry, octobre 2013</p>

<h1 id="introduction">Introduction</h1>
<p>Ce document a pour but d'illustrer les grands concepts de la confiance
électronique (cryptographie, certificats, signature électronique etc.), principalement par la
manipulation d'outils en ligne de commande.</p>

<p>Les chapitres <a href="#crypto-symetrique" class="chapter"/> à <a href="#crypto-asymetrique" class="chapter"/> introduisent les primitives cryptographiques utilisées dans le domaine de la confiance électronique : algorithmes de chiffrement symétrique, algorithmes de hachage, et cryptographie asymétrique (bi-clés RSA, chiffrement et signature).</p>
<p>Ensuite, les chapitres <a href="#certificats" class="chapter"/> et <a href="#lcr" class="chapter"/> s'intéressent aux structures de données de base d'une infrastructure de gestion de clés (IGC, ou PKI pour <i>Public Key Infrastructure</i>, ou encore ICP pour infrastructure à clés publiques) : les certificats électroniques X.509 et les listes de certificats révoqués.</p>
<p>Les usages de la confiance électronique font l'objet des chapitres <a href="#confidentialite-pkcs7-cms" class="chapter"/> à <a href="#auth-web" class="chapter"/> : protection de la confidentialité des données à l'aide des formats PKCS#7/CMS et XML Encryption, signature électronique en utilisant les formats PKCS#7/CMS et XML Signature, authentification web par certificat.</p>
<p>Le chapitre <a href="#horodatage" class="chapter"/> sur l'horodatage prépare enfin les chapitres <a href="#cades" class="chapter"/> et <a href="#xades" class="chapter"/> sur la signature électronique avancée avec les formats CAdES et XAdES.</p>

<h3 id="pre-requis">Pré-requis</h3>
<p>Ce document ne se substitue volontairement pas à une présentation académique de la confiance électronique : les concepts fondamentaux ne sont pas rappelés, et il conviendra donc de se tourner vers d'autres ressources<span class="fn">Par exemple <em>Cryptographie appliquée</em>, deuxième édition, de Bruce Schneier. Éditions Vuibert, 2001, 846 p.</span>. Le lecteur est par ailleurs supposé être familiarisé avec les sujets suivants : les bases numériques
(binaire et hexadécimal), XML, l'utilisation du shell du système d'exploitation.</p>
<p>Les outils suivants sont supposés être installés sur l'environnement
utilisé par le lecteur (lequel peut être notamment Windows, UNIX/Linux, ou
Mac OS X) :</p>
<ul>
<li>OpenSSL<span class="fn">http://www.openssl.org</span>, pour les opérations cryptographiques unitaires et la manipulation des structures binaires usuelles de la confiance électronique (X.509, PKCS, etc.). Une annexe présente la compilation et l'installation d'OpenSSL en environnement GNU/Linux et Windows).</li>
<li>XML Security Library<span class="fn">http://www.aleksey.com/xmlsec/</span>, pour la manipulation des formats XML Encryption et XML Signature. La compilation de XML Security Library sous Windows est détaillée en annexe.</li>
<li>XMLStarlet<span class="fn">http://xmlstar.sourceforge.net/</span>, pour la manipulation de structures XML.</li>
<li>Les commandes <code>od</code> (ou <code>hexdump</code> en adaptant la syntaxe), <code>grep</code>, <code>tr</code>, <code>fold</code>, <code>head</code>, <code>sed</code>, <code>dd</code>, <code>sort</code>, <code>cut</code>, <code>xargs</code> et <code>cat</code>. Ces commandes sont toutes standard en environnement GNU/Linux et BSD, et utiliser GnuWin<span class="fn">http://gnuwin32.sourceforge.net/</span> sous Windows.</li>
</ul>
<p>La version actuelle de ce document a été conçue pour rentrer le plus
rapidement possible dans le vif du sujet. Les éventuelles futures révisions
seront moins exigeantes en pré-requis.</p>

<h3 id="conventions">Conventions d'écriture</h3>
<p>Sauf précision contraire :</p>
<ul>
<li>La marque d'invite de commande « <code>$</code> » est générique,
    indiquant que la commande peut-être saisie dans le shell de tout système
    d'exploitation compatible, tandis que la marque d'invite de commande
    « &gt; » indique que la commande est spécifique à l'environnement
    Windows. La marque d'invite de commande « <code>#</code> » indique
    une commande à saisir sous le compte <code>root</code> sous UNIX/Linux.</li>
<li>Les lignes de commande saisies par l'utilisateur sont en caractères
  gras.</li>
<li>Le caractère « <code>\</code> » est employé dans les lignes de
    commande pour mettre en évidence une commande trop longue pour tenir sur
    une ligne « physique » de 80 colonnes : en environnement UNIX/Linux, ce
    caractère peut être saisi littéralement (suivi de la touche Entrée)
    pour saisir la commande sur plusieurs lignes, mais sous Windows
    l'intégralité de la commande doit être saisie sur une seule ligne.</li>
</ul>
<p>Les remarques sont mises en forme comme ceci :</p>
<p class="note">Ceci est une remarque.</p>
<p>Enfin, des sujets connexes sont traités dans des encadrés.</p>

<h3 id="ressources-complementaires">Ressources complémentaires</h3>

<p>Le code source, les fichiers générés et le code source de ce livre sont publiés sur GitHub, à l'URL https://github.com/spujadas/tp-confiance.</p>

</div>


<div class="chapters">
<h1 id="crypto-symetrique">Cryptographie symétrique</h1>
<p>Ce chapitre traite des deux algorithmes de
chiffrement symétrique par bloc les plus couramment utilisés dans le domaine
de la confiance électronique : DES et AES.</p>
<p class="note">La terminologie courante mais non officielle
« 3DES » est employée ci-après pour désigner Triple DES à trois clés
indépendantes, officiellement connu sous le nom de 3TDEA (<i>Triple Data Encryption Algorithm, keying option 1</i>).</p>
<p>Les algorithmes de chiffrement symétrique par bloc chiffrent successivement
des blocs de données de longueur fixe, par exemple 64 bits pour DES/3DES et
128 bits pour AES.</p>
<p>L'utilisation des algorithmes de chiffrement symétriques nécessite :</p>
<ul>
<li>une <em>clé de chiffrement</em> symétrique (qui peut par
    exemple être dérivée d'une clé partagée), dont la longueur dépend de
    la taille du bloc de chiffrement et du mode d'application de l'algorithme,
    par exemple 256 bits pour AES-256, 56 bits pour DES, et 168 bits (3×56)
    pour 3DES,</li>
<li>dans le cadre de l'utilisation du mode opératoire de
    chiffrement CBC (<i>cipher-block chaining</i>), qui est le mode le plus
    courant dans le domaine de la confiance électronique, un <em>vecteur d'initialisation</em> (qui doit être initialisé
    aléatoirement), de longueur égale à la taille du bloc de chiffrement de
    l'algorithme.</li>
</ul>
<p>Les exemples ci-après s'appuient sur l'algorithme AES-256 en mode CBC. Ils
peuvent facilement être adaptés à d'autres algorithmes (par exemple en
utilisant la commande <code>des3</code> ou <code>des-ede3-cbc</code> pour
3DES).</p>
<h2 id="chiffrement-symetrique">Chiffrement symétrique</h2>
<p>Utiliser la commande <code>openssl</code> pour chiffrer un fichier avec une
clé AES-256 (commande <code>aes-256-cbc</code> ou <code>enc
aes-256-cbc</code>) dérivée d'un mot de passe arbitraire (saisir et confirmer
le mot de passe <code>auie</code> lorsque demandé) sans salage (option
<code>-nosalt</code>), et afficher la clé et le vecteur d'initialisation.</p>
<pre><strong>$ openssl aes-256-cbc -nosalt -p -in data.txt</strong>
enter aes-256-cbc encryption password:
Verifying - enter aes-256-cbc encryption password:
key=59CC30AD02C25BB7A8757E20D03BD6219DF9C4E87FDFA644CADDA42DEB1DCB6F
iv =A2439E6F27D61066B688122C5B44A242
îkR∟kÅ±f¸╔u↕Ú46%</pre>
<p>La clé (<code>key</code>) et le vecteur d'initialisation (<code>iv</code>)
sont affichés sous la forme d'une chaîne hexadécimale. Les données
chiffrées sont affichées en brut.</p>
<p class="note">L'option <code>-nosalt</code> permet pour les
besoins de l'exemple de dériver la même clé et le même vecteur
d'initialisation à partir d'un mot de passe donné. En pratique, pour ne pas
dégrader le niveau de sécurité, il conviendra soit de générer la clé et
le vecteur d'initialisation aléatoirement, soit de dériver ces éléments en
utilisant l'option de salage PKCS#5 (<code>-salt</code>, ou en omettant
<code>-nosalt</code>) pour éviter une attaque par dictionnaire sur le mot de
passe d'entrée.</p>
<p>Réutiliser la commande précédente avec l'option <code>-out
data.enc</code> pour écrire les données chiffrées dans un fichier.</p>
<h2 id="dechiffrement-symetrique">Déchiffrement symétrique</h2>
<p>Déchiffrer le fichier <code>data.enc</code> en utilisant la clé et le vecteur d'initialisation
généré précédemment.</p>
<pre><strong>$ openssl aes-256-cbc -d -in data.enc \
  -K 59CC30AD02C25BB7A8757E20D03BD6219DF9C4E87FDFA644CADDA42DEB1DCB6F \
  -iv A2439E6F27D61066B688122C5B44A242</strong>
texte en clair</pre>
<p class="exercise"><strong>Exercice</strong> — Chiffrer un texte clair d'une longueur au
moins égale à trois blocs, modifier un bit dans un des premiers blocs, et
déchiffrer le fichier résultant. Observer que le bloc dans lequel a eu lieu
la modification est inintelligible, et que le bloc suivant est légèrement
affecté (le bit correspondant au bit modifié du bloc précédent est
inversé). Cet exercice met en évidence l'absence de contrôle d'intégrité
global, et le mode d'opération du déchiffrement par CBC.</p>

<h3 id="padding"><i>Padding</i> des blocs</h3>
<p>Lorsque, après découpage des données à chiffrer en blocs, le dernier bloc à chiffrer est de longueur
inférieure à la taille de bloc attendue par l'algorithme de chiffrement, des octets de remplissage
(<i>padding</i>) doivent être utilisés pour compléter le bloc. OpenSSL propose par
défaut le mécanisme de <i>padding</i> dit standard (issu de la RFC 1423 et popularisé par PKCS#5) : s'il manque <em>n</em> octets pour compléter le bloc, alors
celui-ci est complété avec <em>n</em> octets contenant la valeur <code><em>n</em></code> (ou,
si le bloc était complet, le mécanisme ajoute un bloc dont chaque octet
contient le nombre d'octets du bloc).</p>
<p>Pour visualiser l'effet du mécanisme de <i>padding</i> sur le texte en
clair, déchiffrer le texte chiffré avec l'option <code>-nopad</code> et
analyser la représentation hexadécimale du résultat.</p>
<pre><strong>$ openssl aes-256-cbc -d -in data.enc \
  -K 59CC30AD02C25BB7A8757E20D03BD6219DF9C4E87FDFA644CADDA42DEB1DCB6F \
  -iv A2439E6F27D61066B688122C5B44A242 -nopad | od -tx1z</strong>
<![CDATA[0000000 74 65 78 74 65 20 65 6e 20 63 6c 61 69 72 02 02  >texte en clair..<
0000020]]></pre>
<p>Le texte en clair constituant le fichier a une longueur de 14 octets, soit
deux octets de moins que la taille d'un bloc AES-256 de 16 octets. Les deux
octets restants sont donc complétés avec la valeur <code>0x02</code>.</p>
<h1 id="hachage">Hachage</h1>
<p>Générer un fichier arbitraire (<code><em>C^Z</em></code> désigne la combinaison de touches <code>Ctrl</code> et <code>Z</code>).</p>
<pre><strong>$ cat &gt; data.txt</strong>
texte en clair<em>C^Z</em>
<em>C^Z</em></pre>
<p>Utiliser OpenSSL pour calculer l'empreinte SHA-256 du fichier.</p>
<pre><strong>$ openssl sha256 data.txt</strong>
SHA256(data.txt)= 89bd92286d6c8014c06030b25f8b40cc1d5656d4b3b7b4831874f50d6f5557
f3</pre>
<p>La valeur affichée est la représentation hexadécimale de l'empreinte. La
valeur brute (binaire) de l'empreinte peut être produite en utilisant l'option
<code>-binary</code> :</p>
<pre><strong>$ openssl sha256 -binary data.txt</strong>
oUW¾mlÇ¶└`0▓_ï@╠↔VVÈ│À┤â↑t§</pre>

<div class="note">
<p>Pour observer le phénomène de dispersion des empreintes, modifier un bit du fichier d'origine, par exemple en remplaçant
« <code>texte</code> » par « <code>uexte</code> » (ce qui transforme le
premier octet <code>0b01110100</code> en <code>0b01110101</code>), puis
calculer l'empreinte du nouveau fichier et noter que l'empreinte obtenue est
totalement différente de la première.</p>
<pre><strong>$ openssl sha256 data2.txt</strong>
SHA256(data2.txt)= cf028a03deccb1928ac3ec19a64e61f557a0a1b2d9c5352a9636fe9f6f1e1
c16</pre>
</div>

<h1 id="crypto-asymetrique">Cryptographie asymétrique</h1>

<h2 id="bi-cle">Bi-clé</h2>
<h3 id="generation-bi-cle">Génération d'un bi-clé RSA</h3>

<p class="note">Les deux genres du mot « bi-clé » coexistent pacifiquement dans le monde de la confiance électronique : les uns parlent d'<em>une</em> bi-clé (une clé double) et les autres (dont l'auteur) d'<em>un</em> bi-clé (un objet à deux clés).</p>

<p>Générer un bi-clé RSA de 2048 bits.</p>
<pre><strong>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048</strong>
 ................................................................................
 ................................................................................
 ............................+++
 ................................................................................
 .................................+++
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCnVZCIiymfCGJK
E9zMVmnVBt5HG4IG7a7jV5OfFjYi0oHDVIOacTfbu6tXFQXe90ENm140/B+SVbyI
t/vG3DkRfHGQe8hCqmSuaEoyNe/6okwac11/ZsVXILw+rh4szbeNC0QqvK+xtxY6
Z7VRzh+7DQL+AE8YLKV4yPgPfcqUyGFQBiwTw55VdKQQiFQRxD+jmist7fBHdalX
CmY+oRemIIoH8Fu9FIcyl++j43pppgnYP8n+B7k09ct2Qq/dlvjN3S4UNgJ6vMuH
Yuq8prXUVM+zdmym5nsdxYdMBzaIKwhQKZ84rplYNd9eLPYzyQWFZrKUJCYLBVQ6
Po2RaadZAgMBAAECggEBAJvl6exsyvAxnXEqpDFz6NHhvkE9bZ0K4D9Knmw/A1za
Bq93E81V4hbD99P/8CJU9bS5pcFzi+6IFkjCML6K+lhCOoPD70W8/mRHIak5+0Tk
5EZYaSmDFCQiiX9UNSTE3Fd5wZ6XgJDv5LOxX4rBoWphqwH+Q7JgFiI8CnBUX+LQ
c5ah60uHc5CyuJCD5nwPr2ojlCRHhNr5iI97v06HEABB3Q5QQVQBZF324JinkJq1
tN9ZcBDKd+y9/G7TxqGZliUGVDcGJkHxo4KsUSyE7Zk3RXqciZ1lkJxF8LfZi2gX
nUIXV/tDH/8UMXK+01ps6KJPyjc6OIQ+ecVaeBM01WkCgYEA1RLrSGQeBQ7FWa/w
IRFDX9m0PLpGl2n0yAxitZ0PhAGEpDcKM4YpCCMxuQPbvLyLd2CbAWvdCr9e4UPF
KTyjL/+TnwFR5EALoVuO6X74k5fW5BEydQTAmYi9zM2Afa2Ydw6BZlo9u19uIMpu
gDAnH/klz8cuNxbdmHHSAOi+V58CgYEAyQuql2wuwVmCR8oXFX5ggipnAf+3tfeQ
WETPH567mjyhNWbZ1PqxRBztnp2DkFoAozve6fxxIhkoJ5V2kXciDnYaj79R6Xv5
LnJM4/Jtt1AEmt2RRaKjROIw43u5cuumQlvb86k9I+W6SJbyMuzZFdwdacb64cUT
NLGW4bbLfgcCgYBe4TjSGHrhp60rfdPA9c35nZjLver3O6BbgGBoHNMu5fopobSy
MtiMnhdjGpu7lH3KH8OGQ4C/a24VgzcFYNIN6pHSqSTNLdO/+2RNB1QrbN6s2heM
0hvtgl16GDxSOn387gGjESYSDLGeemXwQQD7FNfIiRpEP7NXUb/A1eMEYwKBgQC7
MSakmPErzEjWyR8XPzVi3VJN9Si7wIdg+KiV+3kYEk3T6DD48nbtQbYqEuV2Gacw
VcWnvgokwqG1wZ/Fr9RA/MycfXoqWOlZysk3EPoBTfsLqzPhT56Pu7/jf8bbbvi+
HsO8qx6ndvYtMobOzeMPTIUCgWgFoTbRwG0JOudcLwKBgC4mWdKGAS3KrfvcT+z5
dsbu0NuN3X8qDcbOJ1iCTQpV4eQUi+JwB3MaKM1ThlY5AQXmev0UgwBQrX3tp4bc
ts+8iEJktZGI7TN6LBqw679VCqRkEMEqJ5w8xj5NuLimXzDbhX1Dysn7pe54ZArL
B0Icc+eDX6AKmoQp8Oq698Jj
-----END PRIVATE KEY-----</pre>
<p class="note">La syntaxe ci-dessus remplace l'ancienne
syntaxe <code>openssl genrsa 2048</code>, déclarée <i>superceded</i> par la
documentation d'OpenSSL, mais qui est toujours utilisable à la date
d'écriture (en version 1.0.1 d'OpenSSL).</p>
<p>Copier la clé ci-dessus (de <code>-----BEGIN PRIVATE KEY-----</code> à
<code>-----END PRIVATE KEY-----</code>, ces deux balises PEM étant incluses
dans la clé) dans un fichier nommé <code>rsakey.pem</code>, ou utiliser la
commande ci-dessus avec l'option <code>-out rsakey.pem</code> pour poursuivre
avec une autre clé.</p>
<h3 id="analyse-bi-cle">Analyse d'un bi-clé</h3>
<p>Afficher le contenu du bi-clé.</p>
<pre><strong>$ openssl rsa -in rsakey.pem -text -noout</strong>
Private-Key: (2048 bit)
modulus:
    00:b8:6f:48:f9:99:f1:99:71:c6:6f:80:64:d1:ca:
    …
publicExponent: 65537 (0x10001)
privateExponent:
    4b:10:f0:50:b6:f9:80:8c:b0:49:5d:a6:ab:44:63:
    …
prime1:
    00:e7:36:d7:37:13:f4:9a:5f:36:60:e7:ac:85:a0:
    …
prime2:
    00:cc:34:af:4f:2c:14:14:d9:b0:d7:52:a2:58:c8:
    …
exponent1:
    65:7f:34:70:70:29:23:0f:02:ce:fd:44:45:90:6c:
    …
exponent2:
    00:96:14:6a:7b:bf:a3:8a:a7:6b:86:f5:1e:88:2d:
    …
coefficient:
    39:49:5e:a9:d9:4b:8e:a2:24:58:12:0d:3c:ea:c2:
    …</pre>
<p>Ce contenu reflète la représentation d'un bi-clé RSA selon la structure
ASN.1 suivante, définie par PKCS#1 (ou, de manière équivalente à PKCS#1 version 1.5, dans la RFC 2313) :</p>
<pre>RSAPrivateKey ::= SEQUENCE {
    version           Version, 
    modulus           INTEGER,  -- n
    publicExponent    INTEGER,  -- e
    privateExponent   INTEGER,  -- d
    prime1            INTEGER,  -- p
    prime2            INTEGER,  -- q
    exponent1         INTEGER,  -- d mod (p-1)
    exponent2         INTEGER,  -- d mod (q-1) 
    coefficient       INTEGER,  -- (inverse of q) mod p
    otherPrimeInfos   OtherPrimeInfos OPTIONAL 
}</pre>
<p class="note">Contrairement à ce que son nom indique, la
structure <code>RSAPrivateKey</code> contient le bi-clé RSA et non simplement
la clé privée, laquelle peut d'ailleurs être représentée mathématiquement
par le couple <code>(n, d)</code> ou, de manière équivalente et permettant
d'appliquer plus rapidement les algorithmes de chiffrement et déchiffrement
RSA, par le quintuplet <code>(p, q, d mod (p-1), d mod (q-1), (inverse of q)
mod p)</code>.</p>
<p>La clé publique correspond au couple <code>(n, e)</code>. Elle peut être
extraite du bi-clé RSA par la commande suivante :</p>
<pre><strong>$ openssl rsa -in rsakey.pem -pubout</strong>
writing RSA key
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuG9I+ZnxmXHGb4
Gm7IivO5Of0HCI2Xsr4eJ5W9HoaI/w5hcrc9N6W4GTXHw65Xon5dRvODgw
qV0e+pnEkxWGzldJAGAAOQIDSjWOB/kP8tNHNC5r+VE54G5j88mXh09LNe
9RiKhnTBsRug8yn8XC62zSb0ZXUcN4nGuX45YzaKoYgZECYrqdj+5500NO
9OgtOXk1W2JU0DKjpSwxf6XSmEA2k6bDoWZfP/b87UVKBkWX9e9Bfmi7f9
BM01nysBM0YAEr57UoLbI6rSP/s3ZA9lX5jzgG8Q2bS/dS9Bp+W9Fzq4NF
0QIDAQAB
-----END PUBLIC KEY-----</pre>
<p>Ajouter l'option <code>-out rsakey.pub.pem</code> pour écrire la clé
publique dans un fichier, et analyser celui-ci.</p>
<pre><strong>$ openssl rsa -in rsakey.pub.pem -noout -text -pubin</strong>
Public-Key: (2048 bit)
Modulus:
    00:b8:6f:48:f9:99:f1:99:71:c6:6f:80:64:d1:ca:
…
    8d:d1
Exponent: 65537 (0x10001)</pre>
<p>Ce contenu représente bien le couple <code>(n, e)</code>, conformément à
la représentation ASN.1 normalisée suivante :</p>
<pre>RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e 
}</pre>
<p class="note">L'option <code>-pubout</code> d'<code>openssl
rsa</code> produit une clé publique conforme à la structure
<code>SubjectPublicKeyInfo</code> de X.509, qui encapsule le type de clé et la
valeur de la clé (elle-même de type <code>RSAPublicKey</code>), et qui est
notamment utilisée pour représenter une clé publique dans un certificat
électronique. Pour obtenir une clé publique de type
<code>RSAPublicKey</code>, l'option <code>-pubout</code> doit être remplacée
par la commande non documentée <code>-RSAPublicKey_out</code>.</p>
<p class="note">La structure ASN.1 brute de la clé publique
(ou privée) peut être visualisée en convertissant la clé au format DER et
en utilisant la commande <code>openssl asn1parse</code>. Par exemple :</p>
<pre><strong>$ openssl rsa -in rsakey.pem -outform DER | openssl asn1parse -inform DER -i</strong>
writing RSA key
    0:d=0  hl=4 l=1187 cons: SEQUENCE
    4:d=1  hl=2 l=   1 prim:  INTEGER           :00
    7:d=1  hl=4 l= 257 prim:  INTEGER           :B86F…8DD1
  268:d=1  hl=2 l=   3 prim:  INTEGER           :010001
  273:d=1  hl=4 l= 256 prim:  INTEGER           :4B10…B4E1
  533:d=1  hl=3 l= 129 prim:  INTEGER           :E736…C515
  665:d=1  hl=3 l= 129 prim:  INTEGER           :CC34…CCCD
  797:d=1  hl=3 l= 128 prim:  INTEGER           :657F…6C95
  928:d=1  hl=3 l= 129 prim:  INTEGER           :9614…3649
 1060:d=1  hl=3 l= 128 prim:  INTEGER           :3949…2DBF</pre>
<p class="exercise"><strong>Exercice</strong> — Utiliser les options <code>-offset</code> et
<code>-out</code> de la commande <code>openssl asn1parse</code> pour extraire
la clé publique de type <code>RSAPublicKey</code> à partir du
<code>BIT STRING</code> de la structure <code>SubjectPublicKeyInfo</code> (au
besoin se reporter à la section 4.1 de la RFC 5280 pour la définition de la
structure <code>SubjectPublicKeyInfo</code>).</p>
<h2 id="chiffrement-asymetrique">Chiffrement asymétrique</h2>
<h3 id="chiffrement-cle-publique">Chiffrement par une clé publique</h3>
<p>Chiffrer un fichier avec la clé publique RSA précédente.</p>
<pre><strong>$ openssl pkeyutl -encrypt -pubin -inkey rsakey.pub.pem -in data.txt \
  -out data.rsa</strong></pre>
<p class="note">Par défaut, OpenSSL utilise pour le chiffrement
l'algorithme de remplissage (<i>padding</i>) défini dans le mode de codage
EME-PKCS1-v1_5 de PKCS#1 version 1.5 ou RFC 2313 (par opposition à EME-OAEP introduit dans PKCS#1 version 2.0 ou RFC 2437, plus
sécurisé car non déterministe, mais beaucoup moins courant dans le domaine de la confiance
électronique en pratique), correspondant à l'option implicite
<code>-pkeyopt rsa_padding_mode:pkcs1</code> (versus <code>-pkeyopt
rsa_padding_mode:oeap</code> — la coquille <code>o<em>ea</em>p</code> pour O<em>AE</em>P étant volontaire).</p>

<h3 id="dechiffrement-cle-privee">Déchiffrement par une clé privée</h3>
<p>Déchiffrer le fichier obtenu avec la clé privée RSA.</p>
<pre><strong>$ openssl pkeyutl -decrypt -inkey rsakey.pem -in data.rsa</strong>
Loading 'screen' into random state - done
texte en clair</pre>
<p>Le <i>padding</i> défini par EME-PKCS1-v1_5 a
la forme <code>0x02 0x00 <em>données aléatoires</em> 0x00 <em>données</em></code>, avec autant de données aléatoires non nulles que nécessaire pour obtenir
une taille de bloc finale égale à la longueur de la clé RSA.</p>
<p>Déchiffrer le fichier en utilisant le <i>padding</i>
<code>none</code>
pour visualiser le <i>padding</i> réalisé précédemment par EME-PKCS1-v1_5
:</p>
<pre><strong>$ openssl pkeyutl -decrypt -in data.rsa -inkey rsakey.pem \
  -pkeyopt rsa_padding_mode:none -hexdump</strong>
0000 - 00 02 ac 39 c7 54 7f 7b-50 65 61 46 0c 69 61 c8   ...9.T.{PeaF.ia.
<em>… octets aléatoires …</em>
00f0 - 42 00 74 65 78 74 65 20-65 6e 20 63 6c 61 69 72   B.texte en clair</pre>
<p class="note">Observer que la longueur totale du bloc est de
256 octets, soit 2048 bits, c'est-à-dire la taille de la clé RSA utilisée.</p>

<div class="longnote">
<div class="notetitle">Performances des algorithmes de chiffrement</div>
<p>En pratique (cf. chapitre sur la confidentialité plus loin), les données sont chiffrées à l'aide d'une clé symétrique, puis la clé symétrique est chiffrée avec une clé publique, et ce pour des raisons de performances, les algorithmes symétriques étant beaucoup plus rapides que les algorithmes asymétriques, comme le montre par exemple la comparaison des performances entre RSA et AES-256-CBC pour chiffrer des blocs de 1024 bits :</p>
<pre><strong>$ openssl speed rsa aes-256-cbc</strong>
…
Doing aes-256 cbc for 3s on 1024 size blocks: 93499 aes-256 cbc's in 3.72s
…
Doing 1024 bit private rsa's for 10s: 2087 1024 bit private RSA's in 12.80s
Doing 1024 bit public rsa's for 10s: 41888 1024 bit public RSA's in 12.95s
…
OpenSSL 1.0.1a 19 Apr 2012
built on: Fri Apr 20 06:01:45 2012
options:bn(64,32) rc4(8x,mmx) des(idx,cisc,2,long) aes(partial) idea(int) blowfi
sh(idx)
…
The 'numbers' are in 1000s of bytes per second processed.
type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
aes-256 cbc       9200.68k     9426.32k     9677.20k    25746.01k    23797.85k
                  sign    verify    sign/s verify/s
rsa  512 bits 0.001050s 0.000102s    952.4   9828.7
rsa 1024 bits 0.006132s 0.000309s    163.1   3233.8
rsa 2048 bits 0.037914s 0.001097s     26.4    911.7
rsa 4096 bits 0.259566s 0.004098s      3.9    244.0</pre>
<p class="note">Les chiffres varient bien entendu d'une machine à l'autre, seuls les ordres de grandeur sont pris en compte.</p>
<p>Lors de ce test, AES-256-CBC a chiffré des blocs de 1024 bits à une vitesse moyenne de 25 746,01 kB par seconde (25,1 MB/s), tandis que RSA a chiffré par clé publique des blocs de 1024 bits à la vitesse moyenne de 3 233,8 blocs de 1024 bits par seconde, soit 3 233,8 kB par seconde (3,2 MB/s), soit un rapport de presque 8 entre les deux algorithmes. Noter également que doubler la taille de la clé RSA engendre un facteur de pénalité d'environ 3,5 sur le temps de chiffrement.</p>
</div>
<h2 id="signature-numerique">Signature numérique</h2>
<h3 id="signature-cle-privee">Signature par une clé privée</h3>
<p>Signer un fichier avec la clé privée RSA précédente, en chiffrant avec
la clé privée l'empreinte SHA-256 du fichier choisi.</p>
<pre><strong>$ openssl sha256 -binary data.txt | openssl pkeyutl -sign -inkey rsakey.pem</strong></pre>
<p class="note">Par analogie avec le chiffrement, par défaut, OpenSSL utilise pour la signature RSA 
l'algorithme de <i>padding</i> (remplissage) défini dans le mode de codage
EMSA-PKCS1-v1_5 de PKCS#1 ou RFC 3447, correspondant à l'option implicite
<code>-pkeyopt rsa_padding_mode:pkcs1</code>. La version sécurisée de l'algorithme de <i>padding</i> est EMSA-PSS (<code>-pkeyopt
rsa_padding_mode:pss</code>), mais son utilisation est actuellement rare dans le domaine de la confiance
électronique.</p>

<h3 id="verification-cle-publique">Vérification par une clé publique</h3>
<p>Le déchiffrement de la signature à l'aide de la clé publique produit
l'empreinte du fichier, comme attendu, en injectant le résultat de la commande
ci-dessus dans <code>openssl pkeyutl -verifyrecover</code> :</p>
<pre><strong>… | openssl pkeyutl -verifyrecover -pubin -inkey rsakey.pub.pem</strong>
Loading 'screen' into random state -Loading 'screen' into random state - done
 done
oUW¾mlÇ¶└`0▓_ï@╠↔VVÈ│À┤â↑t§
<strong>$ openssl sha256 -binary data.txt</strong>
oUW¾mlÇ¶└`0▓_ï@╠↔VVÈ│À┤â↑t§</pre>
<p class="note">La commande <code>openssl</code> est parfois
un peu capricieuse quant à l'ordre des arguments. Par exemple, dans la ligne
de commande précédente, placer l'option <code>-pubin</code> (qui indique que
la clé référencée par l'option <code>-inkey</code> est une clé publique et
non privée) <em>après</em> l'option <code>-inkey</code> provoque l'erreur
<code>unable to load Private Key</code> survient. En cas d'erreur inattendue,
il vaut parfois la peine d'essayer d'utiliser l'ordre des options tel qu'il
figure dans la documentation d'OpenSSL.</p>
<p>Pour vérifier simplement une signature, utiliser l'option <code>-verify</code> d'<code>openssl pkeyutl</code>, avec les options <code>-in</code> pour définir le fichier d'empreinte des données et <code>-sigfile</code> pour le fichier contenant la signature.</p>
<pre><strong>$ openssl sha256 -binary data.txt > data.sha256
$ openssl pkeyutl -sign -in data.sha256 -inkey rsakey.pem -out data.sha256.sig
$ openssl pkeyutl -verify -pubin -inkey rsakey.pub.pem -in data.sha256 \
  -sigfile data.sha256.sig</strong>
Signature Verified Successfully</pre>
<p>Variante de la dernière commande pour éviter le stockage de l'empreinte dans un fichier intermédiaire :</p>
<pre><strong>$ openssl sha256 -binary data.txt | openssl pkeyutl -verify -pubin \
  -inkey rsakey.pub.pem -sigfile data.sha256.sig</strong>
Signature Verified Successfully</pre>

<h3 id="analyse-signature">Analyse d'une signature</h3>
<p>En mode EMSA-PKCS1-v1_5, l'empreinte chiffrée est incluse dans une
structure de données <code>DigestInfo</code><a name="DigestInfo"/>, dont la définition ASN.1 est :</p>
<pre>DigestInfo ::= SEQUENCE {
    digestAlgorithm AlgorithmIdentifier,
    digest OCTET STRING
}</pre>
<p>Pour inclure l'empreinte dans une structure <code>DigestInfo</code> avant
<i>padding</i> et chiffrement, préciser l'algorithme de hachage devant faire
l'objet du premier élément de la structure, via l'option <code>-pkeyopt
digest:</code> :</p>
<pre><strong>$ openssl sha256 -binary data.txt | openssl pkeyutl -sign -inkey rsakey.pem \
  -pkeyopt rsa_padding_mode:pkcs1 -pkeyopt digest:sha256</strong></pre>
<p class="note">L'option <code>-pkeyopt
rsa_padding_mode:pkcs1</code> a été volontairement explicitée, mais elle
peut être omise.</p>
<p>Le déchiffrement et le décodage ASN.1 de cette signature peuvent être
obtenus en injectant le résultat de la commande ci-dessus dans la commande
suivante :</p>
<pre><strong>… | openssl pkeyutl -verifyrecover -pubin -inkey rsakey.pub.pem -asn1parse</strong>
Loading 'screen' into random state -Loading 'screen' into random state - done
 done
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING
      0000 - 89 bd 92 28 6d 6c 80 14-c0 60 30 b2 5f 8b 40 cc   ...(ml...`0._.@.
      0010 - 1d 56 56 d4 b3 b7 b4 83-18 74 f5 0d 6f 55 57 f3   .VV......t..oUW.</pre>
<p>L'<code>OCTET STRING</code> final contient bien l'empreinte du fichier
d'entrée (en hexadécimal :
<code>89bd92286d6c8014c06030b25f8b40cc1d5656d4b3b7b4831874f50d6f5557f3</code>).</p>
<p class="exercise"><strong>Exercice</strong> — Vérifier, par exemple à l'aide de la
commande <code>od -tx1</code>, que le résultat obtenu est conforme à la note
1 de la section 9.2 de la RFC 3447.</p>

<h3 id="padding-signature"><i>Padding</i> d'une signature</h3>
<p>Le <i>padding</i> défini par EMSA-PKCS1-v1_5 a
pour forme <code>0x01 0x00 0xff … 0xff <i>données</i>
</code>, où les
<code>0xff</code> sont répétés autant de fois que nécessaire pour obtenir
une taille de bloc finale égale à la longueur de la clé RSA.</p>
<p>Déchiffrer la signature en utilisant le <i>padding</i>
<code>none</code>
pour visualiser le <i>padding</i> réalisé précédemment par EMSA-PKCS1-v1_5
:</p>
<pre><strong>$ openssl sha256 -binary data.txt | openssl pkeyutl -sign -pubin \
  -inkey rsakey.pub.pem | openssl pkeyutl -verifyrecover -inkey rsakey.pem \
  -pkeyopt rsa_padding_mode:none -hexdump</strong>
Loading 'screen' into random state -
Loading 'screen' into random state - done
 done
0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
<em>… octets 0xff …</em>
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff 00   ................
00e0 - 89 bd 92 28 6d 6c 80 14-c0 60 30 b2 5f 8b 40 cc   ...(ml...`0._.@.
00f0 - 1d 56 56 d4 b3 b7 b4 83-18 74 f5 0d 6f 55 57 f3   .VV......t..oUW.</pre>
<p class="note">Observer que la longueur totale du bloc est de
256 octets, soit 2048 bits, c'est-à-dire la taille de la clé RSA de
signature.</p>

<h2 id="construction-cle-publique">Construction d'une clé publique</h2>

<p>Pour construire des structures de données associées à des modules ASN.1 non supportés nativement par OpenSSL (via l'outil en ligne de commande <code>openssl</code> ou la bibliothèque libcrypto), à l'exemple du format de signature électronique avancée CAdES, il est possible de recourir à la commande <code>openssl asn1parse</code>. Celle-ci permet de constituer une structure ASN.1 à partir d'une description fournie soit en ligne de commande pour les structures élémentaires (via l'option <code>-genstr</code>), soit dans un fichier de configuration pour les structures imbriquées (via l'option <code>-genconf</code>).</p>

<p class="note">Les principales alternatives sont d'écrire du code invoquant les fonctions ASN.1 de la bibliothèque libcrypto d'OpenSSL, et d'adapter et compiler les modules ASN.1 issus des normes souhaitées à l'aide d'un compilateur ASN.1 (tel que asn1c, présenté en annexe).</p>

<p class="note">Une méthode (un peu artisanale mais pratique) est proposée dans l'annexe <a href="#unber2asnconf" class="appendix_section"/> pour générer un fichier de configuration ASN.1 interprétable par OpenSSL à partir d'un fichier codé en DER.</p>

<p>Dans chacun des chapitres impliquant une structure de données intervenant dans le format CAdES, il est décrit comment construire cette structure à l'aide de la commande <code>openssl asn1parse</code>, à commencer par ce chapitre pour la structure <code>SubjectPublicKeyInfo</code>, utilisée pour référencer la clé publique dans le champ <code>subjectPublicKeyInfo</code> d'un certificat.</p>

<p>La structure à générer a la syntaxe ASN.1 suivante :</p>

<pre>SubjectPublicKeyInfo  ::=  SEQUENCE  {
     algorithm            AlgorithmIdentifier,
     subjectPublicKey     BIT STRING
}</pre>

<h3 id="creation-champ-algorithm">Création du champ <code>algorithm</code></h3>
<p>Créer un fichier <code>ee-SubjectPublicKeyInfo.asn.cnf</code>, avec le contenu suivant, à enrichir au fur et à mesure :</p>

<pre>asn1=SEQUENCE:subjectPublicKeyInfo

[subjectPublicKeyInfo]
algorithm = …
subjectPublicKey = …</pre>

<p>Dans cette structure, le champ <code>algorithm</code> est de type <code>AlgorithmIdentifier</code>, dont la syntaxe est la suivante :</p>

<pre>AlgorithmIdentifier  ::=  SEQUENCE  {
     algorithm               OBJECT IDENTIFIER,
     parameters              ANY DEFINED BY algorithm OPTIONAL
}</pre>

<div class="note">

<p>La norme X.509 emploie la syntaxe objet d'ASN.1 (cf. X.681) pour contraindre le rapport entre les champs <code>algorithm</code> et <code>parameters</code> :</p>

<pre>AlgorithmIdentifier{ALGORITHM:SupportedAlgorithms} ::= SEQUENCE {
    algorithm ALGORITHM.&amp;id ({SupportedAlgorithms}),
    parameters ALGORITHM.&amp;Type ({SupportedAlgorithms}{ @algorithm}) OPTIONAL
}</pre>

<p>où la définition de la classe <code>ALGORITHM</code> est :</p>

<pre>ALGORITHM ::= CLASS {
    &amp;Type                                 OPTIONAL,
    &amp;id              OBJECT IDENTIFIER    UNIQUE
}
WITH SYNTAX {
                     [&amp;Type]
    IDENTIFIED BY    &amp;id
}</pre>

<p>Avec cette syntaxe, l'algorithme RSA aurait une définition comparable à celle-ci :</p>

<pre>pkcs-1 OBJECT IDENTIFIER ::= {
    iso(1) member-body(2) US(840) rsadsi(113549) pkcs(1) 1
}

rsaEncryption OBJECT IDENTIFIER ::= { pkcs-1 1 }

rsa ALGORITHM ::= {
    NULL
    IDENTIFIED BY rsaEncryption
}</pre>

<p>où <code>NULL</code> indique que si le champ <code>parameters</code> est présent (ce qui est imposé par PKCS#1, même si son éventuelle absence est acceptée par OpenSSL), il doit être de type <code>NULL</code>.</p>

<p>La liste des algorithmes supportés (dont la valeur est <code>{ ... }</code> dans X.509) serait alors définie ainsi :</p>

<pre>SupportedAlgorithms ALGORITHM ::= { rsa }</pre>
</div>

<p>La <code>SEQUENCE</code> de la structure <code>AlgorithmIdentifier</code> correspondant à l'algorithme RSA inclut les champs suivants :</p>

<ul>
<li><code>algorithm</code>, qui contient l'OID dont l'alias court (connu d'OpenSSL) est <code>rsaEncryption</code>.</li>
<li><code>parameters</code>, qui contient <code>NULL</code>.</li>
</ul>

<p>Cela se transpose dans le fichier <code>ee-SubjectPublicKeyInfo.asn.cnf</code> par la section suivante :</p>

<pre>[rsa_AlgorithmIdentifier]
algorithm = OID:rsaEncryption
parameters = NULL</pre>

<p class="note">Les noms de section sont arbitraires : ici le nom <code>rsa_AlgorithmIdentifier</code> a été choisi pour expliciter la structure définie.</p>

<p>Mettre à jour la définition du champ <code>algorithm</code> de la structure <code>SubjectPublicKeyInfo</code></p>

<pre>[subjectPublicKeyInfo]
algorithm = SEQUENCE:rsa_AlgorithmIdentifier
…</pre>

<h3 id="creation-champ-subjectpublickey">Création du champ <code>subjectPublicKey</code></h3>

<p>Le cas du champ <code>subjectPublicKey</code> de la structure <code>SubjectPublicKeyInfo</code> est plus subtil. Il s'agit d'une <code>BIT STRING</code> dont la valeur est le codage DER de la structure <code>RSAPublicKey</code> représentant la clé publique. Il est dit de cette <code>BIT STRING</code> qu'elle encapsule ou enrobe (<i>wrap</i> en anglais) la structure <code>RSAPublicKey</code>.</p>

<p>Le mécanisme d'enrobage permet d'inclure dans un champ (habituellement une <code>BIT STRING</code> ou une <code>OCTET STRING</code>) une structure dont le type n'est pas connu lors de l'élaboration du module. Par exemple, dans le cas des <code>SubjectPublicKeyInfo</code>, une <code>BIT STRING</code> peut stocker tout type de clé publique (RSA, DSA etc.), et l'apparition d'un nouveau type de clé publique ne nécessite pas de faire évoluer le module.</p>

<p>Ce mécanisme de champ générique impose qu'un autre élément permette de déterminer le type du champ. En l'occurrence, la valeur du champ <code>algorithm</code> détermine le type de structure enrobé par la <code>BIT STRING</code> de <code>subjectPublicKey</code>, par exemple une <code>RSAPublicKey</code> si <code>algorithm</code> contient l'OID <code>rsaEncryption</code>.</p>

<p>La structure à enrober dans le champ <code>subjectPublicKey</code> dans le cas d'une clé publique RSA est de type <code>RSAPublicKey</code> :</p>

<pre>RSAPublicKey ::= SEQUENCE {
    modulus INTEGER,
    publicExponent INTEGER
}</pre>

<p>Créer le fichier <code>ee-RSAPublicKey.asn.cnf</code> suivant (les valeurs sont celles de la clé publique créée dans le fichier <code>ee-key.pem</code>, le caractère littéral « <code>\</code> » est employé pour découper une valeur sur plusieurs lignes) :</p>

<pre>asn1=SEQUENCE:RSAPublicKey

[RSAPublicKey]
n = INTEGER:0xB86F48F999F19971C66F8064D1CA0C1A6EC88AF3B939FD07088D97B2BE1E2795B\
D1E8688FF0E6172B73D37A5B81935C7C3AE57A27E5D46F38383089C4410EDA95D1EFA99C4931586\
CE57490060003902034A358E07F90FF2D347342E6BF95139E06E63F3C997874F4B35E8DA3A87F4F\
5188A8674C1B11BA0F329FC5C2EB6CD26F465751C3789C6B97E3963368AA1881910262BA9D8FEE7\
9D3434E722A2302DF4E82D3979355B6254D032A3A52C317FA5D298403693A6C3A1665F3FF6FCED4\
54A064597F5EF417E68BB7FD2D3892B4F04CD359F2B0133460012BE7B5282DB23AAD23FFB37640F\
655F98F3806F10D9B4BF752F41A7E5BD173AB8345B81FD5C8DD1
e = INTEGER:0x010001</pre>

<p>Générer le codage DER de la structure ASN.1 correspondante.</p>

<pre><strong>$ openssl asn1parse -genconf ee-RSAPublicKey.asn.cnf -i -out ee-RSAPublicKey.der</strong>
    0:d=0  hl=4 l= 266 cons: SEQUENCE
    4:d=1  hl=4 l= 257 prim:  INTEGER           :B86F48F999F19971C66F8064D1CA0C1
…
012BE7B5282DB23AAD23FFB37640F655F98F3806F10D9B4BF752F41A7E5BD173AB8345B81FD5C8DD
1
  265:d=1  hl=2 l=   3 prim:  INTEGER           :010001</pre>

<div class="note">
<p>Le résultat affiché par cette opération doit être strictement identique à celui de la commande :</p>
<pre>$ openssl rsa -in ee-key.pem -outform DER -RSAPublicKey_out
  | openssl asn1parse -inform DER -i</pre></div>
  
<p>La représentation hexadécimale de ce codage DER peut être déterminée ainsi :</p>

<pre><strong>$ od -tx1 -An ee-RSAPublicKey.der | tr -d "\n\r "</strong>
3082010a0282010100b86f48f999f19971c66f8064d1ca0c1a6ec88af3b939fd07088d97b2be1e27
…
5f98f3806f10d9b4bf752f41a7e5bd173ab8345b81fd5c8dd10203010001</pre>

<p>La <code>BIT STRING</code> du champ <code>subjectPublicKey</code> de la structure <code>SubjectPublicKeyInfo</code> à générer doit prendre la valeur hexadécimale ci-dessus.</p>

<p>Voici le fichier <code>ee-SubjectPublicKeyInfo.asn.cnf</code> ainsi obtenu.</p>

<pre>asn1=SEQUENCE:subjectPublicKeyInfo

[subjectPublicKeyInfo]
algorithm = SEQUENCE:rsa_AlgorithmIdentifier
subjectPublicKey = FORMAT:HEX,BITSTRING:3082010a0282010100b86f48f999f19971c66f8\
064d1ca0c1a6ec88af3b939fd07088d97b2be1e2795bd1e8688ff0e6172b73d37a5b81935c7c3ae\
57a27e5d46f38383089c4410eda95d1efa99c4931586ce57490060003902034a358e07f90ff2d34\
7342e6bf95139e06e63f3c997874f4b35e8da3a87f4f5188a8674c1b11ba0f329fc5c2eb6cd26f4\
65751c3789c6b97e3963368aa1881910262ba9d8fee79d3434e722a2302df4e82d3979355b6254d\
032a3a52c317fa5d298403693a6c3a1665f3ff6fced454a064597f5ef417e68bb7fd2d3892b4f04\
cd359f2b0133460012be7b5282db23aad23ffb37640f655f98f3806f10d9b4bf752f41a7e5bd173\
ab8345b81fd5c8dd10203010001

[rsa_AlgorithmIdentifier]
algorithm = OID:rsaEncryption
parameters = NULL</pre>

<div class="note">
<p>La ligne de commande UNIX/Linux suivante est proposée pour convertir un fichier un binaire en sa représentation hexadécimale, avec découpage en lignes de 64 caractères et ajout du caractère « <code>\</code> » en fin de ligne, le résultat pouvant ainsi être inclus directement dans un champ tel que <code>subjectPublicKey</code> ci-dessus (en prenant le soin de supprimer le dernier caractère « <code>\</code> ») :</p>
<pre><strong>$ od -tx1 -An ee-SubjectPublicKeyInfo.der | tr -d " \r\n" | sed 's/$/\\/'</strong>
30820122300d06092a864886f70d01010105000382010f003082010a02820101\
…
aad23ffb37640f655f98f3806f10d9b4bf752f41a7e5bd173ab8345b81fd5c8d\
d10203010001\</pre>

<p>Sous Windows, la commande <code>sed</code> à utiliser est <code>sed 's/$/\\/'</code>, en remplaçant les apostrophes délimiteurs par des guillemets.</p>
</div>

<p>Générer la structure ASN.1 <code>SubjectPublicKeyInfo</code>.</p>

<pre><strong>$ openssl asn1parse -genconf ee-SubjectPublicKeyInfo.asn.cnf -i \
  -out ee-SubjectPublicKeyInfo.der</strong>
    0:d=0  hl=4 l= 290 cons: SEQUENCE
    4:d=1  hl=2 l=  13 cons:  SEQUENCE
    6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
   17:d=2  hl=2 l=   0 prim:   NULL
   19:d=1  hl=4 l= 271 prim:  BIT STRING</pre>

<div class="note"><p>Le fichier <code>ee-SubjectPublicKeyInfo.der</code> généré doit être identique au fichier <code>ee-key.pub.der</code> résultant de la commande suivante :</p>
<pre><strong>$ openssl rsa -in ee-key.pem -outform DER -out ee-key.der</strong></pre>
<p>Dans les deux cas, l'utilisation de la commande <code>openssl asn1parse</code> avec <code>-strparse 24</code>, où 24 = 19 octets (début de la <code>BIT STRING</code>) + 4 octets (longueur de l'en-tête) + 1 (premier octet de la <code>BIT STRING</code> représentant les bits inutilisés), permet d'extraire la structure <code>RSAPublicKey</code> encapsulée.</p></div>

<p>Réaliser manuellement l'enrobage d'une structure <code>SubjectPublicKeyInfo</code> dans une <code>BIT STRING</code> permet de mieux comprendre l'articulation entre les structures, mais est assez peu pratique. Heureusement, OpenSSL propose un mécanisme pour enrober une structure dans une <code>BIT STRING</code>, via le mot clé <code>BITWRAP</code>. En utilisant le type <code>BITWRAP</code>, le fichier <code>ee-SubjectPublicKeyInfo.asn.cnf</code> devient :</p>

<pre>asn1=SEQUENCE:subjectPublicKeyInfo

[subjectPublicKeyInfo]
algorithm = SEQUENCE:rsa_AlgorithmIdentifier
subjectPublicKey = BITWRAP,SEQUENCE:subjectPublicKey

[rsa_AlgorithmIdentifier]
algorithm = OID:rsaEncryption
parameters = NULL

[subjectPublicKey]
n = INTEGER:0xB86F48F999F19971C66F8064D1CA0C1A6EC88AF3B939FD07088D97B2BE1E2795B\
D1E8688FF0E6172B73D37A5B81935C7C3AE57A27E5D46F38383089C4410EDA95D1EFA99C4931586\
CE57490060003902034A358E07F90FF2D347342E6BF95139E06E63F3C997874F4B35E8DA3A87F4F\
5188A8674C1B11BA0F329FC5C2EB6CD26F465751C3789C6B97E3963368AA1881910262BA9D8FEE7\
9D3434E722A2302DF4E82D3979355B6254D032A3A52C317FA5D298403693A6C3A1665F3FF6FCED4\
54A064597F5EF417E68BB7FD2D3892B4F04CD359F2B0133460012BE7B5282DB23AAD23FFB37640F\
655F98F3806F10D9B4BF752F41A7E5BD173AB8345B81FD5C8DD1
e = INTEGER:0x010001</pre>

<p>Ce fichier final est plus lisible et plus facile à modifier que de passer par le codage DER intermédiaire d'une structure <code>RSAPublicKey</code>.</p>

<div class="note"><p>En cas d'oubli du mot clé <code>BITWRAP</code>, la structure générée (représentée ci-dessous) sera différente de celle souhaitée et, étant incompatible avec la définition donnée dans le module ASN.1, ne pourra pas être traitée par les applications utilisatrices.</p>
<pre>    0:d=0  hl=4 l= 285 cons: SEQUENCE
    4:d=1  hl=2 l=  13 cons:  SEQUENCE
    6:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption
   17:d=2  hl=2 l=   0 prim:   NULL
   19:d=1  hl=4 l= 266 cons:  SEQUENCE
   23:d=2  hl=4 l= 257 prim:   INTEGER           :B86F48F999F19971C66F8064D1CA0C
…
D1
  284:d=2  hl=2 l=   3 prim:   INTEGER           :010001</pre></div>

<p>Utiliser dumpasn1 (cf. annexe <a href="#dumpasn1" class="appendix_section"/>) pour analyser le fichier <code>ee-SubjectPublicKeyInfo.der</code>, en notant que la <code>BIT STRING</code> enrobante est détricotée.</p>

<pre><strong>$ dumpasn1 -a ee-SubjectPublicKeyInfo.der</strong>
   0  290: SEQUENCE {
   4   13:   SEQUENCE {
   6    9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
  17    0:     NULL
         :     }
  19  271:   BIT STRING, encapsulates {
  24  266:     SEQUENCE {
  28  257:       INTEGER
         :         00 B8 6F 48 F9 99 F1 99 71 C6 6F 80 64 D1 CA 0C
…
         :         D1
 289    3:       INTEGER 65537
         :       }
         :     }
         :   }</pre>

<h1 id="certificats">Certificats</h1>
<p>Ce chapitre est consacré à la génération pas à pas de certificats. Pour permettre de vérifier le profil des certificats
à l'aide d'un outil externe, le profil retenu est celui défini en France par
l'annexe A14 du référentiel général de sécurité<span class="fn">http://www..modernisation.gouv.fr/rgs-securite</span> (RGS), dans un document intitulé <em>Profils de
Certificats / LCR / OCSP et Algorithmes Cryptographiques</em>.</p>

<p class="note">Il existait un outil, nommé outil Validation Profils RGS<span class="fn"><strike>http://bao.dgme.fr</strike></span>, permettant de valider la conformité des certificats, listes de certificats révoqués, jetons OCSP et jetons d'horodatage par rapport aux profils définis par le RGS. Cet outil a disparu pendant le mois de juin 2012, et est mentionné au cas où il réapparaîtrait. Les éléments générés dans ce document ont tous été validés par cet outil.</p>

<h2 id="generation-bi-cles">Génération des bi-clés</h2>
<p>Générer un bi-clé RSA de 2048 bits pour l'autorité de certification.</p>
<pre><strong>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048</strong>
 ...................................................................+++
 ................................................................................
 ...........+++
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCcLbpiB/OVoLSz
RzENFJEwdE8UieC1UPNWxOSATXbIg+v9aSnpwikD6laI/DiN0jgiLK76H0LHqg/3
xXiaJyh4PRkzHGO1muVj/6uE3G4CGR6gUWQ6c12qwMJO8GyLhPyEbiZ9FGysQQE+
Z3RLkg90nW2KRWnfrZxxtCXHb9zrMA/qlCB9rfdahs8ZqLwAiXueg4Hsqq7eOIV4
6O12U02jjpXEkjC6+LL9H7c+uh0w85KgkHc9SNXx896KQM/nX+uBAOQuSAId2uiH
2g8HrmSWecL/4AxIiIzqzX+H2FRIpPtQ02/Xto+EQ1Wy/F6ML27NkoHL87VbrOC/
4+q/P4XBAgMBAAECggEAFL3+AwcLUtQFK8pIuXQB1G2eExw8u9gEeYGs111yaS8c
KIvPBTzENcDpvUfCOxOwYNmOY6nDNMFhXYbcfZy1w0JaFm+uzm/EB4PtQ7gC5ERx
zNkCdsDbr9Hp/JHx2JXQ88WtVu9ff4EiqScUSvUbGGHQKo0NgqeMH43Ndq9kp9eF
JVc/TCX6KcpmopK0hKIRd0Pow2MK9jCGkidxV70Of641pLagQvW9o5siIbkIbidh
u82p0EAu5gyreLKdUpU6sEmSig7Ox9LmSgG7UyIhqd3bvVYLYw68/R4UZd3cwKRX
yceNyZKWnETmyurj1RLka1z3lOy2zqBeqzOpbKtgAQKBgQDMegYN5PtJD9lDWnfR
s4/Qj7Z9w5Unp6QMhVionE7NkIOKZ3E42PFGTbK4r99x/D26Sc/fKf2bHJbZSObn
TMpHUSvnvuYQFNlsV1PWfg4VbCrRw9D26LG8ESdjelW3iXYcau/45J9bEvP1/vyI
WvwD/ITUxjN7WDyQWjal4X2FpQKBgQDDiDDCfyGN0/SXmb1pnUCMMe/WxPje8RDN
lBeyDVvYpBTFKQDSbK0N0nY8xKS5HLdCmR9817Sqpm9UJ/7oc3NeYKXYF9BGE08w
C5UfdA3QsdoSUS7TseTunn/yhmKJBq4m9AaJRPZCH49Ipk2FQIhQg9YPUdwd6klV
tDJPNZ3c7QKBgCWHD61lJSlXm0xdQjheeDqS5a9XQfyxK86QeqEXbu8TYtD4AzOn
vUBl6jMzNBM7dCjIezo9/qmFKbpfQuGYmldUcnZp9tdkvDLCJETthbAw1fsBsUxf
kJ8vlscPIMQ6mk7E4Z4Qd57Db7rqPXbZG/+vTMGwTqqImzTzGayAIgVxAoGBAKFk
Mkr3wGxefM79GPip0XNmbH6rSnhKJgJpsD1JBXyFwpcSRxlollaIVwvFi+k3KJSR
6wmSyg7pHY8rDB413Q4TXBBHZ6PPoFcZ2FaD5jtR8ZuY4rvdZAcJULaP8ZkEqI6C
cTqwb0sY3Z2rluTb5SgACZnPiY4vqaRR/gyfRtPpAoGAfqPmbd8xLlKVaN7Rjlrm
IoOrDYaL27o2fhwmSiKTiMq/sbUQWstr+S34u7/BhnNk4gBFj8CnimK4QYdrpy8d
OprHbQU1Tvh40OLPsMS5ZCfWzuhhLj09TABFW7Fbj4y+2gI3g0GcWd+BoYOx/NKL
rPewPJu3mc8wj2Y9ue8elLg=
-----END PRIVATE KEY-----</pre>

<p>Copier la clé ci-dessus dans un fichier nommé <code>ca-key.pem</code>
(<code>ca</code> pour <i>certificate/certification authority</i> ou autorité
de certification), ou utiliser la commande ci-dessus avec l'option <code>-out
ca-key.pem</code> pour poursuivre avec une autre clé.</p>

<p>Pour obtenir les mêmes valeurs que celles de ce document, renommer la clé
<code>rsakey.pem</code> générée au début en <code>ee-key.pem</code>
(<code>ee</code> pour <i>end entity</i> ou entité finale). Sinon générer un
bi-clé RSA de 2048 bits dans un fichier <code>ee-key.pem</code>.</p>

<h2 id="generation-csr">Génération des requêtes de signature de certificat</h2>

<h3 id="generetation-csr-cli">Génération avec objet passé en ligne de commande</h3>
<p>Les options de la commande <code>openssl req -new</code> permettent
théoriquement de générer une CSR (<i>certificate signature request</i>, ou
requête de signature de certificat) à elles seules., mais du fait d'un
<i>bug</i> (connu) dans OpenSSL, un fichier de configuration supplémentaire
— même fonctionnellement vide — reste nécessaire. Créer le fichier
<code>req-empty.cnf</code> avec le contenu suivant.</p>
<pre>[ req ]
distinguished_name     = req_distinguished_name

[ req_distinguished_name ]</pre>

<p>Générer la CSR, dans le fichier <code>ca-req.pem</code>.</p>
<pre><strong>$ openssl req -new -key ca-key.pem \
  -subj "/C=FR/O=Mon Entreprise/OU=0002 123456789/OU=OpenSSL Root CA" -sha256 \
  -config req-empty.cnf -out ca-req.pem</strong></pre>

<p class="note">L'ordre des éléments composant l'objet (ou
<i>subject</i> pour la terminologie anglaise) fait l'objet d'une section
spécifique en annexe.</p>

<h3 id="analyse-csr">Analyse d'une requête de signature de certificat</h3>

<p>Visualiser le contenu de la requête.</p>
<pre><strong>$ openssl req -in ca-req.pem -noout -text</strong>
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:9c:2d:ba:62:07:f3:95:a0:b4:b3:47:31:0d:14:
                    …
                    85:c1
                Exponent: 65537 (0x10001)
        Attributes:
            a0:00
    Signature Algorithm: sha256WithRSAEncryption
         8b:0f:a7:83:95:25:01:b4:8c:67:9e:27:43:b3:d8:90:95:a8:
         …
         ff:54:53:9a</pre>
<p>La CSR reflète la structure ASN.1 <code>CertificationRequest</code> :</p>
<pre>CertificationRequest ::= SEQUENCE {
    certificationRequestInfo CertificationRequestInfo,
    signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
    signature          BIT STRING
}</pre>
<p>où <code>CertificationRequestInfo</code> a la structure suivante :</p>
<pre>CertificationRequestInfo ::= SEQUENCE {
    version       INTEGER { v1(0) } (v1,...),
    subject       Name,
    subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
    attributes    [0] Attributes{{ CRIAttributes }}
}</pre>
<p class="note">Le champ attribut contient les octets
<code>0xa0 0x00</code>, correspondant au codage DER d'un <code>SET OF</code>
ASN.1 vide, l'élément <code>attributes</code> étant obligatoire même si la
CSR ne contient aucun attribut, comme expliqué dans la documentation de la
commande <code>req</code> d'OpenSSL.</p>

<h3 id="generation-csr-interactive">Génération avec objet renseigné de manière interactive</h3>

<p>Pour la génération de la CSR de l'entité finale, une autre méthode est
proposée, permettant de renseigner les informations constituant la CSR de
manière interactive. Créer le fichier de configuration
<code>ee-req-dynamic.cnf.utf8</code> suivant, et l'enregistrer avec le codage UTF-8 sans BOM (<i>byte order mark</i>).</p>
<p class="note">La problématique du codage des caractères, qui prend ici tout son sens, est abordée en annexe.</p>
<pre>[ req ]
distinguished_name = req_distinguished_name
string_mask = MASK:0x2002

[ req_distinguished_name ]
C = Code du pays où est enregistrée l\'entité (en majuscules)
C_default = FR
C_min = 2
C_max = 2
O = Nom officiel complet de l\'entité
1.OU = Identification de l\'entité au format ISO 6523
2.OU = Identification complémentaire (optionnelle, [Entrée] pour ignorer)
CN = Prénom et nom de l\'état civil du porteur</pre>
<p class="note">La syntaxe non documentée
<code>MASK:…</code> permet d'autoriser uniquement certains formats de
chaînes de caractères. La valeur <code>0x2002</code> autorise uniquement les
chaînes de type <code>PrintableString</code> (<code>0x0002</code>) et
<code>UTF8String</code> (<code>0x2000</code>). Plus précisément, une chaîne de caractères est codée en <code>PrintableString</code> par défaut, sauf si elle contient des caractères qui n'existente pas dans le jeu de caractères <code>PrintableString</code>, et dans ce cas elle est codée sous la forme d'une <code>UTF8String</code>. Pour obtenir la liste complète
des valeurs possibles pour <code>MASK</code>, se reporter aux constantes <code>B_ASN1_*</code> dans le
fichier d'en-tête <code>asn1.h</code> de la libcrypto.</p>
<p>Générer la CSR, en renseignant les informations demandées.</p>
<div class="note">
<p>Les commandes ci-dessous ne fonctionnent pas sous Windows avec la page de code UTF-8 (<code>chcp 65001</code>) de l'invite de commande, qui semble mal coexister avec <code>openssl</code> : s'attendre au mieux à pouvoir saisir uniquement des caractères ASCII (avec un message d'erreur fatale <code>problems making Certificate Request</code> à la saisie l'un caractère non ASCII), et au pire à une erreur empêchant le démarrage d'OpenSSL (<code>The device is not ready.</code>, observé sous Windows XP, à moins que l'exécutable <code>openssl.exe</code> ne soit appelé depuis un fichier batch, auquel cas – toujours sous Windows XP – le fichier batch ne sera même pas lu !).</p>
<p>Une astuce (particulièrement inélégante… une méthode plus pragmatique est proposée un peu plus loin) consiste à utiliser une page de code telle que Windows-1252 (<code>chcp 1252</code>), et à copier-coller des chaînes de caractères UTF-8 représentées en Windows-1252 vers l'invite de commande. Par exemple, sous Notepad++<span class="fn">http://notepad-plus-plus.org/</span>, créer un nouveau fichier, choisir le codage UTF-8 (<code>Encoding &gt; Encode in UTF-8</code>), saisir la chaîne de caractères souhaitée (par exemple « <code>Entité</code> »), choisir le codage ANSI (<code>Encoding &gt; Encode in ANSI</code>), copier la chaîne résultante (« <code>Mon entitÃ©</code> »), et la coller dans la fenêtre d'invite de commande. Dans cet exemple, les deux octets représentant le caractère « é » en UTF-8 (<code>0xc3 0xa9</code>) sont représentés en Windows-1252 par les deux caractères « Ã© ». OpenSSL traitant uniquement les octets déduits de la représentation de la page de code en cours, il n'y voit que du feu.</p></div>
<pre><strong>$ openssl req -new -key ee-key.pem -config ee-req-dynamic.cnf.utf8 \
  -utf8 -out ee-req.pem</strong>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Code du pays où est enregistrée l'entité (en majuscules) [FR]:
Nom officiel complet de l'entité []:<strong>Mon Entité</strong>
Identification de l'entité au format ISO 6523 []:<strong>0002 987654321</strong>
Identification complémentaire (optionnelle, [Entrée] pour ignorer) []:
Prénom et nom de l'état civil du porteur []:<strong>Prénom NOM</strong></pre>
<p class="note">Pour ajouter des contrôles sur la longueur
des champs et/ou ajouter des attributs dans la CSR, se reporter à la documentation<span class="fn">http://www.openssl.org/docs/apps/req.html</span> de la
fonction <code>openssl req</code>.</p>

<h3 id="generation-csr-config">Génération avec objet fixé dans un fichier de configuration</h3>

<p>La dernière méthode proposée consiste à définir les valeurs des champs dans le fichier de configuration. Créer le fichier <code>ee-req-static.cnf.utf8</code> suivant, et l'enregistrer avec le codage UTF-8 (sans BOM).</p>
<p class="note">Cette méthode est la plus pratique sous Windows pour éviter les problèmes liées au codage UTF-8 car OpenSSL n'a aucun souci à lire les fichiers de configuration au format UTF-8 (tant que l'option <code>-utf8</code> est utilisée).</p>
<pre>[ req ]
distinguished_name = req_distinguished_name
string_mask = MASK:0x2002
prompt = no

[ req_distinguished_name ]
C = FR
O = Mon Entité
OU = 0002 987654321
CN = Prénom Nom</pre>
<p>Exécuter ensuite la commande suivante :</p>
<pre>$ openssl req -new -key ee-key.pem -config ee-req-static.cnf.utf8 -utf8 \
  -out ee-req2.pem</pre>
<p>Si le fichier <code>ee-req.pem</code> a été créé précédemment, alors s'assurer que les fichiers <code>ee-req.pem</code> et <code>ee-req2.pem</code> sont identiques puis supprimer <code>ee-req2.pem</code>, sinon renommer <code>ee-req2.pem</code> en <code>ee-req.pem</code> avant de poursuivre.</p>
<p class="exercise"><strong>Exercice</strong> — Générer un bi-clé RSA <code>ee2-key.pem</code> de 2048 bits, puis, à l'aide d'une méthode au choix, la CSR <code>ee2-req.pem</code> correspondant à cette clé et au DN <code>/C=FR/O=Mon Organisation/OU=0002 963852741/CN=Entité Finale</code>.</p>

<h3 id="generation-objet-csr">Représentation de l'objet d'une requête de signature de certificat</h3>

<p>Pour conclure partiellement sur les différences de comportement par rapport au codage UTF-8, la fin de cette section s'intéresse aux différents affichages possibles du sujet de la CSR.</p>
<p>Affichage de la CSR ou du sujet de la CSR avec la commande <code>openssl req</code> : les caractères non ASCII sont remplacés par une représentation hexadécimale (le caractère « é » a pour codage UTF-8 <code>0xc3 0xa9</code>, comme indiqué par exemple dans cette table de caractères<span class="fn">http://www.utf8-chartable.de/</span>).</p>
<pre><strong>$ openssl req -in ee-req.pem -noout -text</strong>
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=FR, O=Mon Entit\xC3\xA9, OU=0002 987654321, CN=Pr\xC3\xA9nom Nom
…

<strong>$ openssl req -in ee-req.pem -noout -subject</strong>
subject=/C=FR/O=Mon Entit\xC3\xA9/OU=0002 987654321/CN=Pr\xC3\xA9nom Nom</pre>
<p>Analyse ASN.1 de la CSR sous Linux : les chaînes <code>UTF8String</code> ne sont pas affichées directement, mais leur représentation hexadécimale montre la valeur attendue (avec toujours <code>c3 a9</code> pour « é »).</p>
<pre><strong>$ openssl req -in ee-req.pem -outform DER | openssl asn1parse \
  -inform DER -i -dump</strong>
    0:d=0  hl=4 l= 663 cons: SEQUENCE
    4:d=1  hl=4 l= 383 cons:  SEQUENCE
    8:d=2  hl=2 l=   1 prim:   INTEGER           :00
   11:d=2  hl=2 l=  82 cons:   SEQUENCE
   13:d=3  hl=2 l=  11 cons:    SET
   15:d=4  hl=2 l=   9 cons:     SEQUENCE
   17:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
   22:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :FR
   26:d=3  hl=2 l=  20 cons:    SET
   28:d=4  hl=2 l=  18 cons:     SEQUENCE
   30:d=5  hl=2 l=   3 prim:      OBJECT            :organizationName
   35:d=5  hl=2 l=  11 prim:      UTF8STRING
      0000 - 4d 6f 6e 20 45 6e 74 69-74 c3 a9                  Mon Entit..
   48:d=3  hl=2 l=  23 cons:    SET
   50:d=4  hl=2 l=  21 cons:     SEQUENCE
   52:d=5  hl=2 l=   3 prim:      OBJECT            :organizationalUnitName
   57:d=5  hl=2 l=  14 prim:      PRINTABLESTRING   :0002 987654321
   73:d=3  hl=2 l=  20 cons:    SET
   75:d=4  hl=2 l=  18 cons:     SEQUENCE
   77:d=5  hl=2 l=   3 prim:      OBJECT            :commonName
   82:d=5  hl=2 l=  11 prim:      UTF8STRING
      0000 - 50 72 c3 a9 6e 6f 6d 20-4e 6f 6d                  Pr..nom Nom
…</pre>
<p>Analyse ASN.1 de la CSR sous Windows, sous une page de code autre que 65001 (UTF-8), par exemple 850 : OpenSSL tente d'afficher la représentation de la chaîne dans la page de code en cours (avec la page 65001, si <code>openssl</code> peut être lancé, par exemple sous Windows 7, la commande s'interrompt immédiatement après l'affichage du premier caractère non ASCII).</p>
<pre><strong>> openssl req -in ee-req.pem -outform DER | openssl asn1parse -inform DER -i \
  -dump</strong>
    0:d=0  hl=4 l= 663 cons: SEQUENCE
    4:d=1  hl=4 l= 383 cons:  SEQUENCE
    8:d=2  hl=2 l=   1 prim:   INTEGER           :00
   11:d=2  hl=2 l=  82 cons:   SEQUENCE
   13:d=3  hl=2 l=  11 cons:    SET
   15:d=4  hl=2 l=   9 cons:     SEQUENCE
   17:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
   22:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :FR
   26:d=3  hl=2 l=  20 cons:    SET
   28:d=4  hl=2 l=  18 cons:     SEQUENCE
   30:d=5  hl=2 l=   3 prim:      OBJECT            :organizationName
   35:d=5  hl=2 l=  11 prim:      UTF8STRING        :Mon Entit├®
   48:d=3  hl=2 l=  23 cons:    SET
   50:d=4  hl=2 l=  21 cons:     SEQUENCE
   52:d=5  hl=2 l=   3 prim:      OBJECT            :organizationalUnitName
   57:d=5  hl=2 l=  14 prim:      PRINTABLESTRING   :0002 987654321
   73:d=3  hl=2 l=  20 cons:    SET
   75:d=4  hl=2 l=  18 cons:     SEQUENCE
   77:d=5  hl=2 l=   3 prim:      OBJECT            :commonName
   82:d=5  hl=2 l=  11 prim:      UTF8STRING        :Pr├®nom Nom
…</pre>
<p>Dans tous les cas, l'analyse ASN.1 par <code>openssl asn1parse</code> met en évidence que les chaînes qui admettent un codage ASCII sont représentées par une <code>PrintableString</code>, réservant aux <code>UTF8String</code> les cas où un codage ASCII n'est pas possible.</p>

<h2 id="generation-certificats">Génération des certificats</h2>

<h3 id="generation-certificat-ac">Génération du certificat de l'autorité de certification</h3>

<p>Créer le fichier de configuration <code>ca-crt.cnf</code> suivant, définissant le profil du certificat de l'autorité de certification (AC). Pour plus d'informations sur le format du fichier de configuration OpenSSL pour les profils de certificats, consulter cette page<span class="fn">http://www.openssl.org/docs/apps/x509v3_config.html</span>.</p>
<pre>[ca_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,keyCertSign,cRLSign
certificatePolicies \
= 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.1
basicConstraints=critical,CA:TRUE</pre>
<p class="note">Le caractère « <code>\</code> » est ici littéral quel que soit l'environnement, et permet de découper une ligne « fonctionnelle » sur plusieurs lignes « physiques ».</p>
<p class="note">L'OID (<i>object identifier</i>, ou identifiant d'objet) de la politique de certification est normalement issu d'un sous-arc de l'OID attribué à l'organisme en charge de l'autorité de certification. Les possibilités d'obtention d'OID sont décrites dans la FAQ du site OID Repository<span class="fn">http://www.oid-info.com</span>. Ainsi, l'OID dans le fichier de configuration ci-dessus est défini sous un identifiant de sous-arc généré aléatoirement sous un arc prévu par Microsoft à l'usage de ses clients, à l'aide du script <code>oidgen.vbs</code> (disponible ici<span class="fn">http://gallery.technet.microsoft.com/scriptcenter/56b78004-40d0-41cf-b95e-6e795b2e8a06</span>). À noter que la piste de l'arc UUID<span class="fn">http://www.itu.int/ITU-T/asn1/uuid.html</span> de l'ITU, qui est sans doute plus satisfaisante car indépendante d'un organisme commercial, n'est pas recommandée à la date d'écriture car les OID associés ne sont supportés ni par Windows, ni par Firefox (version 11), ni par bien d'autres applications<span class="fn">http://www.viathinksoft.de/~daniel-marschall/asn.1/oid_facts.html</span>.</p>
<p>Générer le certificat de l'AC à partir de la CSR <code>ca-req.pem</code> et du fichier de configuration précédent, pour une durée de validité de 10 ans, et signée en SHA256 et RSA avec la clé privée de l'AC <code>ca-key.pem</code>.</p>
<pre><strong>$ openssl x509 -req -in ca-req.pem -extfile ca-crt.cnf -extensions ca_ext \
  -signkey ca-key.pem -sha256 -days 3652 -out ca-crt.pem</strong>
Loading 'screen' into random state - done
Signature ok
subject=/C=FR/O=Mon Entreprise/OU=0002 123456789/OU=OpenSSL Root CA
Getting Private key</pre>
<p class="note">En l'absence d'option <code>-set_serial</code>, le numéro de série est généré aléatoirement sur 64 bits.</p>
<p class="note">Si le fichier de configuration définit un seul profil, alors la balise de section <code>[…]</code> peut être omise, et dans ce cas ne pas utiliser l'option <code>-extensions</code>.</p>
<p class="note">Les versions successives des RFC permettent d'employer un nombre croissant d'algorithmes de signature de certificat (en particuler RSASSA-PSS, dont l'algorithme de <i>padding</i> EMSA-PSS a été évoqué dans la section sur la signature numérique, introduit dans la RFC 4055, et les algorithmes GOST introduits dans la RFC 4491), mais en pratique les algorithmes de signature les plus fréquemment utilisés sont à base de RSA et SHA-1 (en mode PKCS#1 version 1.5, cf. RFC 3279) ou SHA-2 (également en mode PKCS#1 version 1.5, cf. RFC 4055).</p>

<p>Afficher le contenu du certificat.</p>

<pre><strong>$ openssl x509 -in ca-crt.pem -noout -text</strong>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            ac:aa:ff:2f:9d:e9:3c:53
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
        Validity
            Not Before: Apr  7 14:12:48 2012 GMT
            Not After : Apr  7 14:12:48 2022 GMT
        Subject: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:9c:2d:ba:62:07:f3:95:a0:b4:b3:47:31:0d:14:
                    …
                    85:c1
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier:
                4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8F
            X509v3 Authority Key Identifier:
                keyid:4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8
F

            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Certificate Policies:
                Policy: 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224
.8393003.10972002.1.1

            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         96:a4:82:08:6e:7a:3a:a7:32:7c:db:54:13:f1:0f:a0:3e:dc:
         …
         7c:32:c1:bb</pre>

<h3 id="generation-certificat-ee-authsig">Génération d'un certificat d'authentification et signature pour l'entité finale</h3>

<p>Créer le fichier de configuration <code>ee-crt.cnf</code> suivant, définissant le profil du certificat d'authentification et signature du porteur.</p>
<pre>[authsig_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,nonRepudiation,digitalSignature
certificatePolicies \
= 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.2
crlDistributionPoints=URI:http://tiny.cc/LatestCRL
basicConstraints=critical,CA:FALSE</pre>
<p class="note">L'élément <code>crlDistributionPoints</code> doit contenir, pour que le profil du certificat soit conforme au RGS, l'URL d'une liste de certificats révoqués (LCR) publiquement accessible et au format DER. Même si l'outil de validation des profils RGS n'effectue pas cette vérification à la date de rédaction, il est recommandé de renseigner une URL publique pointant réellement sur la LCR. Une solution possible est de créer un site web gratuit (une recherche des mots clés « hébergement web gratuit » ou l'offre du FAI du lecteur sont deux pistes à creuser) et d'y publier la LCR. Pour plus de flexibilité, l'auteur a utilisé un réducteur d'URL pour produire une URL générique « pérenne » pouvant être paramétrée pour pointer vers l'hébergeur de la LCR du moment. (À un instant donné, il est peu probable que l'URL ci-dessus pointe réellement sur une LCR, l'auteur n'ayant pas prévu de tenir celle-ci à jour en dehors des périodes de rédaction de ce document !)</p>
<p>Avant de créer le certificat, générer aléatoirement le numéro de série du prochain certificat signé par l'AC, sur 8 octets (64 bits).</p>
<pre><strong>$ openssl rand -hex 8 -out ca-crt.srl</strong></pre>
<p>Déclencher la génération du certificat.</p>
<pre><strong>$ openssl x509 -req -in ee-req.pem -extfile ee-crt.cnf -extensions authsig_ext \
  -CA ca-crt.pem -CAkey ca-key.pem -CAserial ca-crt.srl -sha256 -days 730 \
  -out ee-crt-authsig.pem</strong></pre>
<p>Afficher le contenu du certificat.</p>
<pre><strong>$ openssl x509 -in ee-crt-authsig.pem -noout -text</strong>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            dc:d2:1e:e5:a2:b7:df:c7
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
        Validity
            Not Before: Apr  7 15:17:47 2012 GMT
            Not After : Apr  7 15:17:47 2014 GMT
        Subject: C=FR, O=Mon Entit\xC3\xA9, OU=0002 987654321, CN=Pr\xC3\xA9nom
Nom
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:b8:6f:48:f9:99:f1:99:71:c6:6f:80:64:d1:ca:
                    …
                    8d:d1
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier:
                8B:28:E4:FE:77:43:B0:05:E3:67:1F:8A:EF:13:58:2B:CB:46:40:60
            X509v3 Authority Key Identifier:
                keyid:4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8
F

            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation
            X509v3 Certificate Policies:
                Policy: 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224
.8393003.10972002.1.2

            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://tiny.cc/LatestCRL

            X509v3 Basic Constraints: critical
                CA:FALSE
    Signature Algorithm: sha256WithRSAEncryption
         09:2f:ba:bf:d9:86:fd:02:9c:8a:22:3b:a0:f2:e4:81:60:3a:
         …
         77:cf:6e:8b</pre>

<h2 id="verification-manuelle-sig-certificat">Vérification manuelle de la signature d'un certificat</h2>

<p>Au niveau le plus général, un certificat X.509 contient une structure de données à signer nommée <code>tbsCertificate</code>, un algorithme de signature (<code>signatureAlgorithm</code>) et une signature numérique (<code>signatureValue</code>), visibles sur le certificat d'authentification précédent en filtrant l'analyse de la commande <code>openssl asn1parse</code> sur les deux premiers niveaux d'imbrication (via <code>grep d=[01]</code>, la notation <code>d=</code> étant employée dans l'affichage de l'analyse ASN.1 pour désigner la profondeur — <i>depth</i> — de l'imbrication, où 0 est le niveau le plus global).</p>

<pre><strong>$ openssl asn1parse -in ee-crt-authsig.pem -i | grep d=[01]</strong>
    0:d=0  hl=4 l=1006 cons: SEQUENCE
    4:d=1  hl=4 l= 726 cons:  SEQUENCE
  734:d=1  hl=2 l=  13 cons:  SEQUENCE
  749:d=1  hl=4 l= 257 prim:  BIT STRING</pre>

<p>Pour vérifier manuellement la signature numérique, il faut extraire la structure <code>tbsCertificate</code> et en calculer l'empreinte, extraire la signature numérique de <code>signatureValue</code> et la déchiffrer avec la clé publique de l'AC, et vérifier que les deux valeurs obtenues sont égales.</p>

<p>La structure <code>tbsCertificate</code> est la première <code>SEQUENCE</code> de niveau 1 (<code>d=1</code>) sous la structure <code>Certificate</code> de niveau 0 :</p>

<pre>    4:d=1  hl=4 l= 726 cons:  SEQUENCE</pre>

<p>La <code>SEQUENCE</code> commence à l'octet 4. L'extraire en utilisant l'option <code>-strparse</code> de la commande <code>openssl asn1parse</code> :</p>

<pre><strong>$ openssl asn1parse -in ee-crt-authsig.pem -strparse 4 \
  -out ee-crt-authsig.tbscertificate.der -noout</strong></pre>

<p>L'algorithme de signature du certificat étant <code>sha256WithRSAEncryption</code>, calculer l'empreinte SHA-256 de la structure <code>tbsCertificate</code> extraite.</p>

<pre><strong>$ openssl sha256 ee-crt-authsig.tbscertificate.der</strong>
SHA256(ee-crt-authsig.tbscertificate.der)= 45232ce57de879d9030142362a6c86186b0a1
c95d8e583387d9032b2e13ff677</pre>

<p>La signature numérique du certificat est la <code>BIT STRING</code> de niveau 1 (<code>d=1</code>) sous la structure <code>Certificate</code>, à partir de l'octet 749 :</p>

<pre><strong>$ openssl asn1parse -in ee-crt-authsig.pem -i -offset 749 -dump</strong>
    0:d=0  hl=4 l= 257 prim: BIT STRING
      0000 - 00 09 2f ba bf d9 86 fd-02 9c 8a 22 3b a0 f2 e4   ../........";...
      …
      00f0 - af 0e 13 4d af b8 d6 82-eb 24 1f 41 ea 77 cf 6e   ...M.....$.A.w.n
      0100 - 8b                                                .</pre>

<p class="note">Avec l'option <code>-offset 749</code>, la numérotation de la position des octets dans l'affichage ci-dessus est relative à l'octet 749 de la structure globale.</p>

<p>La signature numérique du certificat a une longueur de 2048 bits (soit 256 octets) : où commence-t-elle, et pourquoi la <code>BIT STRING</code> a-t-elle une longueur de <code>l= 257</code> octets ? L'octet 749 est le début du <em>codage</em> de la <code>BIT STRING</code>. Ce codage est constitué d'une en-tête (<i>header</i>) de longueur 4 octets (<code>hl=4</code>, avec <code>hl</code> pour <i>header length</i> ou longueur de l'en-tête), suivie du contenu, qui commence donc à l'octet 753. Une <code>BIT STRING</code>, comme son nom l'indique est une chaîne de <em>bits</em>, donc contrairement à une <code>OCTET STRING</code> par exemple, sa valeur peut être représentée par un nombre de bits qui n'est pas nécessairement un multiple de 8. Le premier octet de contenu (ici <code>0x00</code>) donne le nombre de bits (arbitraires) de <i>padding</i> qui ont été ajoutés en fin de contenu pour que le nombre de bits total soit un multiple de 8, c'est-à-dire le nombre de bits inutilisés. La longueur de la signature numérique étant un multiple de 8 bits, le nombre de bits inutilisés est de 0 (aucun <i>padding</i> nécessaire), et la valeur de la signature numérique commence donc à l'octet 754 pour une longueur de 256 octets. Extraire la signature numérique :</p>

<pre><strong>$ openssl asn1parse -in ee-crt-authsig.pem -offset 754 -length 256 \
  -out ee-crt-authsig.signaturevalue.bin -noout</strong></pre>

<p>Lors de la signature, l'algorithme <code>sha256WithRSAEncryption</code> encapsule d'abord l'empreinte dans une structure <code>DigestInfo</code> (cf. section <a href="#DigestInfo" class="section"/>) avant d'ajouter le <i>padding</i> d'EMSA-PKCS1-v1_5 et de chiffrer le résultat avec la clé privée. Déchiffrer la signature numérique à l'aide de la clé publique de l'AC en mettant le <i>padding</i> en évidence :</p>

<pre><strong>$ openssl pkeyutl -verifyrecover -in ee-crt-authsig.signaturevalue.bin \
  -inkey ca-key.pem -pubin -pkeyopt rsa_padding_mode:none -hexdump</strong>
0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
… <em>octets 0xff</em> …
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 31 30   .............010
00d0 - 0d 06 09 60 86 48 01 65-03 04 02 01 05 00 04 20   ...`.H.e.......
00e0 - 45 23 2c e5 7d e8 79 d9-03 01 42 36 2a 6c 86 18   E#,.}.y...B6*l..
00f0 - 6b 0a 1c 95 d8 e5 83 38-7d 90 32 b2 e1 3f f6 77   k......8}.2..?.w</pre>

<p>Déchiffrer à présent la signature numérique en supprimant le <i>padding</i> (l'option <code>-pkeyopt rsa_padding_mode:pkcs1</code> est implicite) :</p>

<pre><strong>$ openssl pkeyutl -verifyrecover -in ee-crt-authsig.signaturevalue.bin \
  -inkey ca-key.pem -pubin -out ee-crt-authsig.digestinfo.der</strong></pre>

<p class="note">L'option <code>-certin</code> (<em>avant</em> <code>-inkey</code>) au lieu de <code>-pubin</code> (<em>après</em> <code>-inkey</code>) permet de passer en paramètre de <code>-inkey</code> un fichier contenant le certificat duquel doit être extraite la clé publique utilisée pour le déchiffrement.</p>

<p>Analyser enfin la structure <code>DigestInfo</code> obtenue :</p>

<pre><strong>$ openssl asn1parse -in ee-crt-authsig.digestinfo.der -inform DER -i -dump</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING
      0000 - 45 23 2c e5 7d e8 79 d9-03 01 42 36 2a 6c 86 18   E#,.}.y...B6*l..
      0010 - 6b 0a 1c 95 d8 e5 83 38-7d 90 32 b2 e1 3f f6 77   k......8}.2..?.w</pre>

<p>La valeur contenue dans la dernière <code>OCTET STRING</code> correspond bien à la valeur de l'empreinte du codage DER de la structure <code>tbsCertificate</code> extraite précédemment.</p>

<p class="note">La vérification de la signature numérique du certificat est une des étapes de la procédure de validation d'une chaîne de certification décrite dans la section 6 de la RFC 5280 : la vérification de la signature numérique d'un certificat en particulier y fait l'objet du point (a)(1) dans la section 6.1.3.</p>

<h2 id="generation-certificat-confidentialite">Génération d'un certificat de confidentialité</h2>

<p>Cette section s'intéresse à la génération d'un certificat de confidentialité, qui sera utilisé pour protéger la confidentialité de données destinées à son porteur dans les chapitres suivants.</p>

<p>Générer un bi-clé RSA de 2048 bits.</p>
<pre><strong>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 \
  -out ee2-key.pem</strong></pre>
<p>La clé ci-dessous sera utilisée pour <code>ee2-key.pem</code> :</p>
<pre>-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAvIm+7N4g3fCuN2kp/Fg3dr8/fz4ImPOXwV90o3roN/Q6SKKn
2yNy/RU64WpM2kyVrj3Mn8izElYQBS+m5OUSEEqrikanx4EAY9QPgP6f6H0IczHO
T5mjhw2m5H1gXibulBhWpdrkYCQaRB2yQAo2owBDLRgRpi9vNZUGCLmMLkCmqeNr
k9njZ7FxDZZp6tiYAy64QMBRlc96aYSyuK8+WG3Ia3FIRzeO3H7IGouVFRJlkHon
NLbVWaNbNTnfgkl4CQhzTeg/fEBXIRnF6gN56hhZ2KwVVt6Sgn06ISyv3IenSrim
iWFTddbxVP9PCSQpBjW7rq/ZRVB4Z3uoKzJr7QIDAQABAoIBABDgG3DEKRj0dAON
rC5kDwLX920CNm7KTukGDECdva9UcusRdAjPUXmJru2CQELB3BvueCRNKIoZnfF4
5G1Ue5tts5D65gWbbFeDIaggIlwC5QC6kobZb6Ok+y00c625ul0TGJ5by1k3ogo6
xjupLl7EpT6iCuJfGIspPZMGWJ/DDiCYD5JywmrgfET/Iy+0d0nKlmh1kxCOKCGE
VcvLQXIA9wV0ogtD20JzXBGVF0cjQbI9j5kD2F5IGK1IyNNS6yTPTh0K6XSM3TYj
4dFLoDRh8mlRiBtyXGeGaA7IllPL2LrhVvWrGqqL53fdYzO/eNlVHP7tTaHwn4zO
NXluBNkCgYEA8vi14FMb4KYHo6Jy99T9TOMBP6N34xLbp09+T2BRu53Bktq1oDgU
GPyv/ry1gfHPqERaLhmwugI8B1IqmjmtPLIWc5IR0AdPWOqEb/NFeUZXA8wobHyP
laGkzs9HgA4jW2EchXEUYOCaivVdcdmeCWznWl+luscCt3H0i7+akJcCgYEAxqXS
rOv576hP2ewrCAANFqhYDm7Zbc6/bNIVbj/3r1zpyTqv+4F7rih8t95ws7pS2a+o
1t2Z5zpnzz6OLMCilUCrLCU69pgD20Ge2fiZc/COrXNsSvsxlH5ElKPTVSV+BZ5I
K5y0n/EISqC1MbaFT9S/Tz1O35h6M+9tsxX9tBsCgYAWxzpFzYTPisEslg4xLcaR
bravQKP8pcfx54Hv7xe6fw+mtNpSKu+3Z/kX6JkblY/iNoY9zCrFRXBbP1i/HKkh
B5ETRJ5m4kiODW5dEHFy7SU7NeiUQxky7fSFbulFGA44guIpoHBIpMXYQSiBg+VM
/OizkEP5Pq8Cg6xpbY0QAQKBgHtwzgLgvLade8lqxa66AWgkAlwtq/VddXzU67ZQ
D8UsUqbWTkdWxhmKVT4Y/yXgUd2uF5g1qo6Sr7GMKONMbXub7QKIvCRCgJr+Iw1G
O21dffvw7smFYODqugk36HpPywkIu8ZGIcQGDuX5Cb+zsRHTnXJLIbk2UjH1xdB0
iOwjAoGBAM3Sa9mpHItnwtPvNg84kJer7Lbx7xNlhuKgCJ2+UlOngGExjQNDZjQF
6dJpt+MqWezAMmujRYyzy1zwc9cRz0NkuvXOAWHtep43qXk+jedaBpujGqBQCg3Q
e6RymtQKiGTYDdnum/HjKFEhDIHjzCEMSlcRs/Sv4FkhTt2i9xwZ
-----END RSA PRIVATE KEY-----</pre>
<p>Créer le fichier de configuration <code>ee2-req-static.cnf.utf8</code> suivant, avec le codage UTF-8 sans BOM, pour la CSR :</p>
<pre>[ req ]
distinguished_name      = req_distinguished_name
string_mask     = MASK:0x2002
prompt = no

[ req_distinguished_name ]
C = FR
O = Mon Organisation
OU = 0002 963852741
CN = Entité Finale</pre>
<p>Générer la CSR :</p>
<pre><strong>$ openssl req -new -key ee2-key.pem -config ee2-req-static.cnf.utf8 -utf8 \
  -out ee2-req.pem</strong></pre>
<p>Créer le fichier de configuration <code>ee2-crt.cnf</code> pour les extensions du certificat :</p>
<pre>[confid_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,keyEncipherment
certificatePolicies \
= 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.3
crlDistributionPoints=URI:http://tiny.cc/LatestCRL
basicConstraints=critical,CA:FALSE</pre>
<p class="note">Il est également possible d'ajouter la section <code>[confid_ext]</code> au fichier <code>ee-crt.cnf</code> existant et d'utiliser ce fichier de configuration ci-après.</p>
<p>Générer aléatoirement le numéro de série du prochain certificat signé par l'AC (il s'agit ici de l'AC créée dans le chapitre sur les certificats, et non celle du chapitre sur l'authentification).</p>
<pre><strong>$ openssl rand -hex 8 -out ca-crt.srl</strong></pre>
<p>Générer le certificat.</p>
<pre><strong>$ openssl x509 -req -in ee2-req.pem -extfile ee2-crt.cnf \
  -extensions confid_ext -CA ca-crt.pem -CAkey ca-key.pem -CAserial ca-crt.srl \
  -sha256 -days 730 -out ee-crt-authsig.pem</strong></pre>

<p>Valider la conformité du profil du certificat par rapport au RGS.</p>

<h2 id="importation-magasin-windows">Importation dans le magasin de certificats de Windows</h2>

<p>Pour pouvoir utiliser un certificat dans une application Microsoft, le certificat et sa clé privée doivent être importés dans le magasin de certificats de Windows. Le format utilisé pour l'importation est le format PKCS#12, qui permet de stocker un certificat, sa clé privée éventuellement protégée par un mot de passe, et d'autres certificats tels que ceux de la chaîne de certification.</p>

<p>Créer un fichier au format PKCS#12 contenant le certificat du porteur et sa clé privée, ainsi que le certificat de l'AC. Saisir le mot de passe <code>auie</code> lorsque demandé.</p>

<pre><strong>$ openssl pkcs12 -export -in ee-crt-authsig.pem -inkey ee-key.pem \
  -certfile ca-crt.pem -name "OpenSSL EE" -out ee-authsig.p12</strong>
Enter Export Password:
Verifying - Enter Export Password:</pre>

<p class="note">L'option <code>-name</code> définit le nom convivial du certificat, qui permet de distinguer un certificat dans l'affichage du magasin de certificats de Windows.</p>

<p>La manière la plus simple d'installer un certificat depuis un fichier au format PKCS#12 est de double-cliquer sur le nom du fichier dans l'explorateur Windows.</p>

<p class="note">Windows associe les extensions <code>.p12</code> et <code>.pfx</code> aux fichiers au format PKCS#12.</p>

<p>Cliquer sur le bouton « Suivant » dans la boîte de dialogue de bienvenue, puis valider le choix du fichier à importer en cliquant sur le bouton « Suivant ». Dans la boîte de dialogue suivante, saisir le mot de passe, et cocher la case « Activer la protection renforcée des clés (…) », comme dans la figure ci-dessous.</p>

<img alt="Boîte de dialogue de saisie du mot de passe d'importation d'un fichier au format PKCS#12" src="img/P12_password.png"/>

<p>Valider avec le bouton « Suivant ». Laisser l'option par défaut « Sélectionner automatiquement le magasin de certificats selon le type de certificats » et cliquer sur le bouton « Suivant ». Démarrer l'importation en cliquant sur le bouton « Terminer ». Conséquence de l'activation de la protection renforcée des clés privées, la boîte de dialogue suivante s'affiche.</p>

<img alt="Boîte de dialogue d'importation d'une nouvelle clé d'échange privée" src="img/P12_new_private_key.png"/>

<div class="note">
<p>Par défaut, le niveau de protection est moyen, c'est-à-dire qu'une alerte Windows est affichée dès qu'une application souhaite utiliser la clé privée. Il est également possible d'élever le niveau de sécurité au niveau haut, en cliquant sur le bouton « Définir le niveau de sécurité », et en sélectionnant l'option « Haut » dans la boîte de dialogue ci-dessous :</p>
<img alt="Boîte de dialogue de sélection du niveau de sécurité" src="img/P12_private_key_protection.png"/>
<p>Après avoir cliqué sur le bouton « Suivant », l'utilisateur définit un mot de passe, lequel sera ensuite demandé lors de chaque tentative d'accès à la clé privée.</p>
<p>Le mot de passe n'étant pas régi par une politique de mot de passe et n'étant pas recouvrable en cas d'oubli (ce qui finit généralement par arriver s'il est rarement utilisé), il est recommandé d'activer le niveau de protection haut avec précaution. Dans le cadre de ce document, il est supposé que le niveau de protection est moyen.</p>
</div>

<p>Après avoir validé à l'aide du bouton « OK », l'avertissement suivant s'affiche.</p>

<img alt="Avertissement de sécurité : nouveau certificat racine" src="img/P12_new_root_CA.png"/>

<p class="note">Le fond et la forme de cet avertissement (contenu alarmiste, mise en page inhabituelle, procédure et terminologie peu compréhensibles pour un néophyte) sont souvent cités pour illustrer la « non-convivialité » de la confiance électronique pour l'utilisateur final.</p>

<p>Utiliser la commande <code>openssl x509</code> suivante pour calculer l'« Aperçu (sha1) » du certificat :</p>
<pre><strong>$ openssl x509 -fingerprint -in ca-crt.pem -noout</strong>
SHA1 Fingerprint=89:A1:CB:9C:85:CF:DB:F1:9A:12:08:35:8B:97:1B:7F:20:B7:4B:D1</pre>

<p class="note">L'empreinte ci-dessus est l'empreinte SHA-1 (par défaut, l'algorithme de hachage pouvant être précisé par une option <code>-&lt;algorithme&gt;</code>, par exemple <code>-sha256</code>) du codage DER du certificat.</p>

<p>Les empreintes correspondant, l'AC racine peut être importée sans crainte en cliquant sur le bouton « Oui ».</p>

<p>Enfin, la boîte de dialogue indiquant que l'importation s'est terminée correctement s'affiche : cliquer sur le bouton « OK ».</p>

<p>Le magasin de certificats de Windows peut être visualisé de deux manières :</p>

<ul>
<li>Depuis la console de gestion, soit via le menu Windows Démarrer &gt; Exécuter… &gt; saisir <code>certmgr.msc</code> et valider, soit (notamment si <code>certmgr.msc</code> n'existe pas) via Démarrer &gt; Exécuter… &gt; saisir <code>mmc</code> et valider puis choisir le menu Fichier &gt; Ajouter/Supprimer un composant logiciel enfichable…, cliquer sur le bouton « Ajouter… », sélectionner « Certificats », cliquer sur le bouton « Ajouter », laisser la sélection par défaut « Mon compte d'utilisateur », cliquer sur le bouton « Terminer », puis sur le bouton « Fermer », puis sur « OK », et dérouler la liste « Certificats - Utilisateur actuel » (et optionnellement, sauvegarder cette configuration de console pour pouvoir y accéder directement ultérieurement). Les certificats de l'utilisateur sont sous Personnel/Certificats (y retrouver le certificat délivré à « Prénom Nom » portant le nom convivial « OpenSSL EE »), les AC intermédiaires sous Autorités intermédiaires/Certificats, et les AC racines sous Autorité de certification racines/Certificats (y retrouver le certificat délivré à « OpenSSL Root CA »).</li>
<li>Depuis Internet Explorer, accéder au menu Outils &gt; Options Internet… &gt; onglet Contenus, cliquer sur le bouton « Certificats ». Les certificats de l'utilisateur sont sous Personnel (le certificat délivré à « Prénom Nom » y porte le nom convivial « OpenSSL EE »), les AC intermédiaires sous Autorités intermédiaires, et les AC racines (dont « OpenSSL Root CA ») sous Autorité principales de confiance.</li>
</ul>

<p>Le certificat du porteur importé dans le magasin de certificats de Windows peut être retrouvé par OpenSSL à partir de son nom convivial, en utilisant la commande <code>openssl engine</code> (après éventuelle configuration du moteur cryptographique <code>capi</code> d'OpenSSL, comme décrit en annexe).</p>

<pre><strong>> openssl engine -t capi -post lookup_method:2 -post lookup_cert:"OpenSSL EE"</strong>
(capi) CryptoAPI ENGINE
     [ available ]
[Success]: lookup_method:2
  Friendly Name "OpenSSL EE"
  Subject: C = FR, O = Mon Entit\C3\A9, OU = 0002 987654321, CN = Pr\C3\A9nom No
m
  Issuer: C = FR, O = Mon Entreprise, OU = 0002 123456789, OU = OpenSSL Root CA
[Success]: lookup_cert:OpenSSL EE</pre>

<h2 id="construction-certificat">Construction d'un certificat</h2>

<p>La construction manuelle d'un certificat s'effectue en trois étapes : la constitution de la structure à signer <code>TBSCertificate</code>, la signature de cette structure, et la constitution de la structure <code>Certificate</code> contenant ces éléments avec la syntaxe ASN.1 suivante :</p>

<pre>Certificate  ::=  SEQUENCE  {
     tbsCertificate       TBSCertificate,
     signatureAlgorithm   AlgorithmIdentifier,
     signatureValue       BIT STRING
}</pre>

<h3 id="constitution-tbscertificate">Constitution d'une structure <code>TBSCertificate</code></h3>

<p>La structure <code>TBSCertificate</code> a la syntaxe ASN.1 suivante :</p>

<pre>TBSCertificate  ::=  SEQUENCE  {
     version         [0]  EXPLICIT Version DEFAULT v1,
     serialNumber         CertificateSerialNumber,
     signature            AlgorithmIdentifier,
     issuer               Name,
     validity             Validity,
     subject              Name,
     subjectPublicKeyInfo SubjectPublicKeyInfo,
     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
     extensions      [3]  EXPLICIT Extensions OPTIONAL
}</pre>

<p>Les champs <code>version</code> et <code>serialNumber</code> sont de type <code>INTEGER</code>, avec pour valeurs respectives <code>2</code> et — pour reprendre le cas du certificat d'authentification et signature généré dans la section <a href="#generation-certificat-ee-authsig" class="section"/> (page <a href="#generation-certificat-ee-authsig" class="page"/>) — <code>0xdcd21ee5a2b7dfc7</code>. Les autres champs sont des <code>SEQUENCE</code>.</p>

<p>Créer le fichier <code>ee-TBSCertificate.asn.cnf</code> avec l'encodage UTF-8, contenant les lignes suivantes :</p>

<pre>asn1=SEQUENCE:ee_tbsCertificate

[ee_tbsCertificate]
version = EXPLICIT:0,INTEGER:2
serialNumber = INTEGER:0xDCD21EE5A2B7DFC7
signature = SEQUENCE:ee_signature
issuer = SEQUENCE:ee_issuer
validity = SEQUENCE:ee_validity
subject = SEQUENCE:ee_subject
subjectPublicKeyInfo = SEQUENCE:ee_subjectPublicKeyInfo
extensions = EXPLICIT:3,SEQUENCE:ee_extensions</pre>

<p>Le champ <code>signature</code> contenant l'algorithme de signature (ici SHA-256 et RSA) est de type ASN.1 <code>AlgorithmIdentifier</code>, et est défini de manière analogue au champ <code>algorithm</code> de la structure <code>SubjectPublicKeyInfo</code> (cf. section <a href="#creation-champ-algorithm" class="section"/>, page <a href="#creation-champ-algorithm" class="page"/>) :</p>

<pre>[ee_signature]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL</pre>

<p>Les champs <code>issuer</code> et <code>subject</code> contiennent chacun une <code>SEQUENCE</code> de RDN, chaque RDN étant un <code>SET</code> de <code>SEQUENCE {type, value}</code>, où <code>type</code> est l'OID du type de RDN, et <code>value</code> la valeur du RDN (elle-même de type <code>PrintableString</code> ou <code>UTF8String</code> par exemple).</p>

<p>À titre illustratif, le champ <code>issuer</code> à produire pour le certificat considéré admet la structure ASN.1 suivante (produite par l'outil dumpasn1 présenté dans l'annexe <a href="#dumpasn1" class="appendix_section"/>) :</p>

<pre>SEQUENCE {
  SET {
    SEQUENCE {
      OBJECT IDENTIFIER countryName (2 5 4 6)
      PrintableString 'FR'
      }
    }
  SET {
    SEQUENCE {
      OBJECT IDENTIFIER organizationName (2 5 4 10)
      PrintableString 'Mon Entreprise'
      }
    }
  SET {
    SEQUENCE {
      OBJECT IDENTIFIER organizationalUnitName (2 5 4 11)
      PrintableString '0002 123456789'
      }
    }
  SET {
    SEQUENCE {
      OBJECT IDENTIFIER organizationalUnitName (2 5 4 11)
      PrintableString 'OpenSSL Root CA'
      }
    }
  }</pre>
  
<p>Cela se traduit par les lignes suivantes dans le fichier <code>ee-TBSCertificate.asn.cnf</code> :</p>
  
<pre>[ee_issuer]
C = SET:ee_issuer_C_RDN
O = SET:ee_issuer_O_RDN
OU1 = SET:ee_issuer_OU1_RDN
OU2 = SET:ee_issuer_OU2_RDN

[ee_issuer_C_RDN]
rdn = SEQUENCE:ee_issuer_C_ATV

[ee_issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[ee_issuer_O_RDN]
rdn = SEQUENCE:ee_issuer_O_ATV

[ee_issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[ee_issuer_OU1_RDN]
rdn = SEQUENCE:ee_issuer_OU1_ATV

[ee_issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[ee_issuer_OU2_RDN]
rdn = SEQUENCE:ee_issuer_OU2_ATV

[ee_issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA</pre>

<p>De même, le DN de l'objet, <code>/C=FR/O=Mon Entité/OU=0002 987654321/CN=Prénom Nom</code> (selon la notation usuelle d'OpenSSL, cf. annexe <a href="#dn" class="appendix_section"/>) se traduit par les lignes suivantes :</p>

<pre>[ee_subject]
C = SET:ee_subject_C_RDN
O = SET:ee_subject_O_RDN
OU = SET:ee_subject_OU_RDN
CN = SET:ee_subject_CN_RDN

[ee_subject_C_RDN]
rdn = SEQUENCE:ee_subject_C_ATV

[ee_subject_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[ee_subject_O_RDN]
rdn = SEQUENCE:ee_subject_O_ATV

[ee_subject_O_ATV]
type = OID:organizationName
value = FORMAT:UTF8,UTF8String:Mon Entité

[ee_subject_OU_RDN]
rdn = SEQUENCE:ee_subject_OU_ATV

[ee_subject_OU_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 987654321

[ee_subject_CN_RDN]
rdn = SEQUENCE:ee_subject_CN_ATV

[ee_subject_CN_ATV]
type = OID:commonName
value = FORMAT:UTF8,UTF8String:Prénom Nom</pre>

<p>La période de validité du certificat a pour syntaxe ASN.1 :</p>

<pre>Validity ::= SEQUENCE {
     notBefore      Time,
     notAfter       Time
}</pre>

<p><code>Time</code> peut être de deux types possibles (<code>UTCTime</code> ou <code>GeneralizedTime</code>). Le type <code>UTCTime</code> est retenu pour le certificat à générer, avec la notation <code><em>aammjjhhmmss</em>Z</code> (pour une heure UTC) pour les dates et heures dans le fichier de configuration :</p>

<pre>[ee_validity]
notBefore = UTCTIME:120407151747Z
notAfter = UTCTIME:140407151747Z</pre>

<p>La clé publique est de type <code>SubjectPublicKeyInfo</code> : les sections correspondantes (<code>subjectPublicKeyInfo</code>, <code>rsa_AlgorithmIdentifier</code> et <code>subjectPublicKey</code>) du fichier <code>ee-SubjectPublicKeyInfo.asn.cnf</code> (cf. section <a href="#construction-cle-publique" class="section"/>) peuvent être reprises tel quel, en ajoutant simplement le préfixe <code>ee_</code> aux noms de sections :</p>

<pre>[ee_subjectPublicKeyInfo]
algorithm = SEQUENCE:ee_rsaEncryption
subjectPublicKey = BITWRAP,SEQUENCE:ee_subjectPublicKey

[ee_rsaEncryption]
algorithm = OID:rsaEncryption
parameters = NULL

[ee_subjectPublicKey]
n = INTEGER:0xB86F48F999F19971C66F8064D1CA0C1A6EC88AF3B939FD07088D97B2BE1E2795B\
D1E8688FF0E6172B73D37A5B81935C7C3AE57A27E5D46F38383089C4410EDA95D1EFA99C4931586\
CE57490060003902034A358E07F90FF2D347342E6BF95139E06E63F3C997874F4B35E8DA3A87F4F\
5188A8674C1B11BA0F329FC5C2EB6CD26F465751C3789C6B97E3963368AA1881910262BA9D8FEE7\
9D3434E722A2302DF4E82D3979355B6254D032A3A52C317FA5D298403693A6C3A1665F3FF6FCED4\
54A064597F5EF417E68BB7FD2D3892B4F04CD359F2B0133460012BE7B5282DB23AAD23FFB37640F\
655F98F3806F10D9B4BF752F41A7E5BD173AB8345B81FD5C8DD1
e = INTEGER:0x010001</pre>

<p>Chaque extension est représentée sous la forme d'une <code>SEQUENCE {extnID, extnValue}</code>, où <code>extnID</code> est l'OID d'identification de l'extension, et <code>extnValue</code> est une <code>OCTET STRING</code> dont le contenu est la représentation DER de la structure ASN.1 constituant l'extension, ce qui nécessitera d'utiliser le mot clé <code>OCTWRAP</code>, dont le principe est analogue à <code>BITWRAP</code> pour les <code>BIT STRING</code> (cf. la démarche de création du champ <code>subjectPublicKey</code> d'une clé publique dans la section <a href="#creation-champ-subjectpublickey" class="section"/>, page <a href="#creation-champ-subjectpublickey" class="page"/>). Ainsi, chaque extension sera définie selon le modèle suivant :</p>

<pre>[extensions]
…
<em>nom_extension</em>=SEQUENCE:<em>nom_extension</em>
…

[<em>nom_extension</em>]
extnID = OID:<em>oid_extension</em>
extnValue = OCTWRAP,<em>structure_ASN1_extension</em></pre>

<p>Ajouter tout d'abord la section <code>ee_extensions</code> ci-dessous :</p>

<pre>[ee_extensions]
subjectKeyIdentifier=SEQUENCE:ee_subjectKeyIdentifier
authorityKeyIdentifier=SEQUENCE:ee_authorityKeyIdentifier
keyUsage=SEQUENCE:ee_keyUsage
certificatePolicies=SEQUENCE:ee_certificatePolicies
crlDistributionPoints=SEQUENCE:ee_crlDistributionPoints
basicConstraints=SEQUENCE:ee_basicConstraints</pre>

<p>L'extension <code>subjectKeyIdentifier</code> contient une <code>OCTET STRING</code> dont la valeur est l'empreinte SHA-1 de la représentation DER de la structure <code>RSAPublicKey</code> représentant la clé publique de l'entité certifiée. Il suffit pour obtenir cette empreinte de hacher le fichier <code>ee-RSAPublicKey.der</code> généré dans la section <a href="#creation-champ-subjectpublickey" class="section"/>, page <a href="#creation-champ-subjectpublickey" class="page"/>.</p>

<pre><strong>$ openssl sha1 ee-RSAPublicKey.der</strong>
SHA1(ee-RSAPublicKey.der)= 8b28e4fe7743b005e3671f8aef13582bcb464060</pre>

<p>Ajouter la section suivante dans le fichier <code>ee-TBSCertificate.asn.cnf</code>, pour l'extension <code>subjectKeyIdentifier</code> :</p>

<pre>[ee_subjectKeyIdentifier]
extnID = OID:subjectKeyIdentifier
extnValue = OCTWRAP,FORMAT:HEX,OCTETSTRING:\
8b28e4fe7743b005e3671f8aef13582bcb464060</pre>

<p>L'extension <code>authorityKeyIdentifer</code> référence la clé publique de l'autorité de certification, et contrairement au champ <code>subjectKeyIdentifier</code>, plusieurs modes de référence sont possibles, comme indiqué dans la définition ASN.1 de l'extension :</p>
<pre>AuthorityKeyIdentifier ::= SEQUENCE {
   keyIdentifier             [0] KeyIdentifier           OPTIONAL,
   authorityCertIssuer       [1] GeneralNames            OPTIONAL,
   authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL
}

KeyIdentifier ::= OCTET STRING</pre>

<p>Le type de référence retenu pour le certificat en cours de création est <code>KeyIdentifier</code>, identifié par la balise ASN.1 <code>[0] IMPLICIT</code>.</p>

<p class="note">Le mot clé <code>IMPLICIT</code> est sous-entendu dans la définition de la structure <code>AuthorityKeyIdentifier</code> compte tenu de la ligne <code>DEFINITIONS IMPLICIT TAGS ::=</code> figurant en début du module ASN.1 correspondant.</p>

<p>Avec ce type de référence, le contenu de l'extension <code>authorityKeyIdentifier</code> est analogue à celui de <code>subjectKeyIdentifier</code>, mais il est calculé à partir de la structure <code>RSAPublicKey</code> représentant la clé publique de l'autorité de certification émettrice du certificat. La valeur hexadécimale à utiliser peut être déterminée de la manière suivante à partir du fichier <code>ca-key.pem</code> (le bi-clé de l'autorité de certification) :</p>

<pre><strong>$ openssl rsa -in ca-key.pem -RSAPublicKey_out -outform DER | openssl sha1</strong>
writing RSA key
(stdin)= 4c6d879382f72d2c0723a20fe0712d173f39f38f</pre>

<p>Ou encore, à partir du certificat de l'autorité de certification :</p>

<pre><strong>$ openssl x509 -in ca-crt.pem -noout -pubkey | openssl rsa -pubin \
  -RSAPublicKey_out -outform DER | openssl sha1</strong>
(stdin)= 4c6d879382f72d2c0723a20fe0712d173f39f38f</pre>

<p>Ajouter les sections suivantes au fichier de configuration ASN.1 :</p>

<pre>[ee_authorityKeyIdentifier]
extnID = OID:authorityKeyIdentifier
extnValue = OCTWRAP,SEQUENCE:ee_authorityKeyIdentifier_seq

[ee_authorityKeyIdentifier_seq]
keyIdentifier = IMPLICIT:0,FORMAT:HEX,OCTETSTRING:\
4c6d879382f72d2c0723a20fe0712d173f39f38f</pre>

<p>L'extension <code>keyUsage</code> présente la particularité, dans le cas du certificat étudié ici, d'être une extension critique, avec un champ <code>BOOLEAN</code> positionnée à une valeur vraie à inclure entre les champs <code>extnID</code> et <code>extnValue</code>. Par ailleurs, la valeur enrobée dans le champ <code>extnValue</code> est un champ de bits représenté par le type <code>BIT STRING</code>, et dont les valeurs possibles sont les suivantes :</p>

<pre>KeyUsage ::= BIT STRING {
  digitalSignature        (0),
  nonRepudiation          (1),
  keyEncipherment         (2),
  dataEncipherment        (3),
  keyAgreement            (4),
  keyCertSign             (5),
  cRLSign                 (6),
  encipherOnly            (7),
  decipherOnly            (8)
}</pre>

<p>Pour le certificat d'authentification, les bits 0 (<code>digitalSignature</code>) et 1 (<code>nonRepudiation</code>) sont activés, les autres sont désactivés.</p>

<p>La section correspondant à l'extension <code>keyUsage</code> est la suivante :</p>

<pre>[ee_keyUsage]
extnID = OID:keyUsage
critical = BOOLEAN:true
extnValue = OCTWRAP,FORMAT:BITLIST,BITSTRING:0,1</pre>

<p>La traduction de la définition ASN.1 de l'extension <code>certificatePolicies</code> ne pose aucun problème particulier :</p>

<pre>[ee_certificatePolicies]
extnID = OID:certificatePolicies
extnValue = OCTWRAP,SEQUENCE:ee_policyInformation

[ee_policyInformation]
policyInformation = SEQUENCE:ee_policyIdentifier

[ee_policyIdentifier]
policyIdentifier = OID:\
1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.2</pre>

<p>L'extension <code>crlDistributionPoints</code> mérite quelques commentaires. Les premières sections sont classiques :</p>

<pre>[ee_crlDistributionPoints]
extnID = OID:crlDistributionPoints
extnValue = OCTWRAP,SEQUENCE:ee_distributionPoints

[ee_distributionPoints]
distributionPoint = SEQUENCE:ee_distributionPoint</pre>

<p>Le type <code>DistributionPoint</code> s'appuie sur les définitions ASN.1 suivantes :</p>

<pre>DistributionPoint ::= SEQUENCE {
     distributionPoint       [0]     DistributionPointName OPTIONAL,
     reasons                 [1]     ReasonFlags OPTIONAL,
     cRLIssuer               [2]     GeneralNames OPTIONAL
}

DistributionPointName ::= CHOICE {
     fullName                [0]     GeneralNames,
     nameRelativeToCRLIssuer [1]     RelativeDistinguishedName
}

GeneralName ::= CHOICE {
     otherName                 [0]  AnotherName,
     rfc822Name                [1]  IA5String,
     dNSName                   [2]  IA5String,
     x400Address               [3]  ORAddress,
     directoryName             [4]  Name,
     ediPartyName              [5]  EDIPartyName,
     uniformResourceIdentifier [6]  IA5String,
     iPAddress                 [7]  OCTET STRING,
     registeredID              [8]  OBJECT IDENTIFIER
}</pre>

<p>Pour pouvoir définir une URI, correspondant au choix <code>[6]</code> du type <code>GeneralName</code>, il faut représenter la structure schématique suivante :</p>

<pre>[0] CHOICE {
  [0] CHOICE {
    [6] IA5String:…
  }
}</pre>

<p>La problématique est de déterminer si les balises sont <code>IMPLICIT</code> ou <code>EXPLICIT</code>. La règle ici est que, par défaut, les balises sont <code>IMPLICIT</code> (le module ASN.1 de définition des types comportant l'en-tête <code>DEFINITIONS IMPLICIT TAGS</code>), sauf — en application de la clause 30.8 de [X.680] — les types <code>CHOICE</code> qui sont <code>EXPLICIT</code>. En restituant les mots clés <code>EXPLICIT</code> et <code>IMPLICIT</code>, la structure ci-dessus devient :</p>

<pre>[0] EXPLICIT CHOICE {
  [0] EXPLICIT CHOICE {
    [6] IMPLICIT IA5String:…
  }
}</pre>

<p>Le type <code>CHOICE</code> étant codé comme l'élément choisi, la structure ci-dessus admet la représentation suivante :</p>

<pre>[0] EXPLICIT {
  [0] EXPLICIT {
    [6] IMPLICIT IA5String:…
  }
}</pre>

<p>Cela se traduit par la section suivante :</p>

<pre>[ee_distributionPoint]
distributionPoint = EXPLICIT:0,EXPLICIT:0,IMPLICIT:6,IA5STRING:\
http://tiny.cc/LatestCRL</pre>

<p>Enfin, la valeur de l'extension <code>basicConstraints</code> a la syntaxe suivante :</p>

<pre>BasicConstraints ::= SEQUENCE {
     cA                      BOOLEAN DEFAULT FALSE,
     pathLenConstraint       INTEGER (0..MAX) OPTIONAL
}</pre>

<p>Le certificat est un certificat d'entité finale sans contraintes sur la longueur de la chaîne de certification, donc les deux champs ci-dessus peuvent être omis, ce qui produit une <code>SEQUENCE</code> vide.</p>

<p>Cette extension est par ailleurs marquée critique (tout comme l'extension <code>keyUsage</code>), d'où la section suivante :</p>

<pre>[ee_basicConstraints]
extnID = OID:basicConstraints
critical = BOOLEAN:true
extnValue = OCTWRAP,SEQUENCE</pre>

<p>Générer la représentation DER de la structure <code>TBSCertificate</code> ainsi définie :</p>

<pre><strong>$ openssl asn1parse -genconf ee-TBSCertificate.asn.cnf \
  -out ee-TBSCertificate.der -i</strong></pre>
  
<h3 id="signature-certificat">Signature du certificat</h3>

<p>La signature du certificat correspond au chiffrement, par la clé privée RSA de l'autorité de certification, de la structure <code>DigestInfo</code> contenant l'empreinte SHA-256 du codage DER de la structure <code>TBSCertificate</code>.</p>

<p>Générer la représentation hexadécimale de cette empreinte SHA-256 :</p>

<pre><strong>$ openssl sha256 ee-TBSCertificate.der</strong>
SHA256(ee-TBSCertificate.der)= 45232ce57de879d9030142362a6c86186b0a1c95d8e583387
d9032b2e13ff677</pre>

<p>Créer le fichier <code>ee-DigestInfo.asn.cnf</code> représentant la structure <code>DigestInfo</code> contenant cette empreinte :</p>

<pre>asn1 = SEQUENCE:digestInfo

[digestInfo]
digestAlgorithm = SEQUENCE:digestAlgorithm
digest = FORMAT:HEX,OCTETSTRING:\
45232ce57de879d9030142362a6c86186b0a1c95d8e583387d9032b2e13ff677

[digestAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Générer le codage DER correspondant :</p>

<pre><strong>$ openssl asn1parse -genconf ee-DigestInfo.asn.cnf -i -out ee-DigestInfo.der</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:45232CE57DE879D903014
2362A6C86186B0A1C95D8E583387D9032B2E13FF677</pre>

<p>Générer la représentation hexadécimale (découpée sur plusieurs lignes à l'aide du caractère « <code>\</code> ») de la signature du codage DER obtenu :</p>

<pre><strong>$ openssl pkeyutl -sign -in ee-DigestInfo.der -inkey ca-key.pem \
  | od -tx1 -An -w | tr -d " " | sed 's/$/\\/'</strong>
092fbabfd986fd029c8a223ba0f2e481603a1a4ed698c179635e2452b8b3d9ae\
61074a802f1f3338bb19a0a09665a9dcbdbcbfd3f3cc8f410e634fa2b9775631\
72b0695b17394d50e6db308d62070d3873d264dc0d203c2fd652f2ccb798cce2\
2c451ba911c6a8949ec7c07034dff6382008325eda736057f9347bd3a90d7a67\
0607d4455cf6d91c94a87937d9e3e5b95c30b448dae857a35d7b4ea5c9360e1f\
155a598966cfe8a6c2f6b553ec433deaad75fa28a89a35985723874665999f8a\
8e7d19136dad9f0c2e52a0ed94a80c0367a83f444368453088baa61322cd6595\
08dbe499438568e9767473c891fe29af0e134dafb8d682eb241f41ea77cf6e8b\</pre>

<p>Cette valeur représente le contenu de la <code>BIT STRING</code> constituant le champ <code>signatureValue</code> du certificat.</p>

<h3 id="finalisation-certificat">Finalisation du certificat</h3>

<p>Copier le fichier <code>ee-TBSCertificate.asn.cnf</code> sous le nom <code>ee-Certificate.asn.cnf</code>.</p>

<p>Remplacer la première ligne de ce fichier par la ligne suivante :</p>

<pre>asn1=SEQUENCE:ee_certificate</pre>

<p>Ajouter la section <code>certificate</code> ci-dessous (la valeur de <code>signatureValue</code> est celle obtenue ci-avant, à l'exclusion du dernier caractère « <code>\</code> », qui doit être supprimé) :</p>

<pre>[ee_certificate]
tbsCertificate = SEQUENCE:ee_tbsCertificate
signatureAlgorithm  = SEQUENCE:ee_signatureAlgorithm
signatureValue=FORMAT:HEX,BITSTRING:\
092fbabfd986fd029c8a223ba0f2e481603a1a4ed698c179635e2452b8b3d9ae\
61074a802f1f3338bb19a0a09665a9dcbdbcbfd3f3cc8f410e634fa2b9775631\
72b0695b17394d50e6db308d62070d3873d264dc0d203c2fd652f2ccb798cce2\
2c451ba911c6a8949ec7c07034dff6382008325eda736057f9347bd3a90d7a67\
0607d4455cf6d91c94a87937d9e3e5b95c30b448dae857a35d7b4ea5c9360e1f\
155a598966cfe8a6c2f6b553ec433deaad75fa28a89a35985723874665999f8a\
8e7d19136dad9f0c2e52a0ed94a80c0367a83f444368453088baa61322cd6595\
08dbe499438568e9767473c891fe29af0e134dafb8d682eb241f41ea77cf6e8b</pre>

<p>Il reste uniquement à créer une section <code>ee_signatureAlgorithm</code> pour compléter la description du certificat :</p>

<pre>[ee_signatureAlgorithm]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL</pre>

<p class="note">Noter que la section <code>ee_signatureAlgorithm</code> est identique à la section <code>ee_signature</code>, comme prévu dans la section 5.1.1.2 de la RFC 5280.</p>

<p>Générer le certificat :</p>

<pre><strong>$ openssl asn1parse -genconf ee-Certificate.asn.cnf -i -out ee-Certificate.der</strong></pre>

<p>Pour confirmer que le certificat généré est valide, le convertir au format PEM et le vérifier en utilisant le certificat de l'autorité de certification émettrice :</p>

<pre><strong>$ openssl x509 -in ee-Certificate.der -inform DER \
  | openssl verify -CAfile ca-crt.pem</strong>
stdin: OK</pre>

<h1 id="lcr">Liste de certficats révoqués</h1>

<p>Ce chapitre décrit la génération d'une liste de certificats révoqués (LCR, ou CRL pour <i>certificate
revocation list</i>) par l'autorité de certification créée dans le chapitre précédent. Le profil utilisé est celui du RGS.</p>

<h2 id="emission-lcr">Émission d'une liste de certificats révoqués</h2>
<p>Créer le fichier <code>ca-crl.srl</code>, contenant la chaîne de caractères <code>01</code>, le numéro de série en hexadécimal à inclure dans l'extension <code>CRLNumber</code> de la LCR. Ce numéro est incrémenté à chaque nouvelle génération de LCR.</p>
<p>Créer le fichier vide <code>ca-db.txt</code>, constituant la base de données des certificats gérés par une AC via la commande <code>openssl ca</code>. Dans le cas présent, les certificats étant générés à l'aide de la commande <code>openssl x509</code>, la base de données est initialement vide, et est enrichie par la commande <code>openssl ca</code> lors de la révocation d'un certificat.</p>
<p class="note">Chaque ligne du fichier de base de données est au format suivant (<code>type</code> vaut <code>R</code> pour un certificat révoqué) :</p>
<pre>type  date_expiration  info_revocation  num_serie  nom_fichier  objet  numero</pre>
<p>Générer le fichier de configuration <code>ca-crl.cnf</code>, avec le contenu suivant :</p>
<pre>[ca_crl]
database = ca-db.txt
crlnumber = ca-crl.srl

[ca_crl_ext]
authorityKeyIdentifier=keyid</pre>
<p>Générer la LCR.</p>
<pre><strong>$ openssl ca -gencrl -cert ca-crt.pem -keyfile ca-key.pem -crlhours 48 \
  -md sha256 -config ca-crl.cnf -name ca_crl -crlexts ca_crl_ext \
  -out ca-crl.pem</strong>
Using configuration from ca-crl.cnf
Loading 'screen' into random state - done</pre>
<p>Suite à la génération de la LCR, observer que le numéro dans le fichier <code>ca-crl.srl</code> est incrémenté de 1 (après « <code>FF</code> », la valeur suivante est « <code>0100</code> »).</p>
<p>Afficher la LCR.</p>
<pre><strong>$ openssl crl -in ca-crl.pem -noout -text</strong>
Certificate Revocation List (CRL):
        Version 2 (0x1)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: /C=FR/O=Mon Entreprise/OU=0002 123456789/OU=OpenSSL Root CA
        Last Update: Apr  7 19:11:29 2012 GMT
        Next Update: Apr  9 19:11:29 2012 GMT
        CRL extensions:
            X509v3 Authority Key Identifier:
                keyid:4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8
F

            X509v3 CRL Number:
                1
No Revoked Certificates.
    Signature Algorithm: sha256WithRSAEncryption
         6a:c6:90:ac:cc:7a:93:db:6c:d6:23:44:d8:6e:a2:ad:1d:54:
         …
         3a:7b:32:8a</pre>

<h2 id="revocation-lcr">Révocation d'un certificat</h2>

<p class="note">Avant d'effectuer les opérations de cette section, il est recommandé d'effectuer une copie de sauvegarde des fichiers <code>ca-db.txt</code>, <code>ca-crl.srl</code> et <code>ca-crl.pem</code>.</p>

<p>Révoquer le certificat de confidentialité pour cause de compromission de clé.</p>

<pre><strong>$ openssl ca -cert ca-crt.pem -keyfile ca-key.pem -config ca-crl.cnf \
  -md sha256 -name ca_crl -revoke ee2-crt-confid.pem \
  -crl_compromise 20120616172700Z</strong>
Using configuration from ca-crl.cnf
Adding Entry with serial number 89FC7231AEC956C0 to DB for /C=FR/O=Mon Organisat
ion/OU=0002 963852741/CN=Entit\xC3\xA9 Finale
Revoking Certificate 89FC7231AEC956C0.
Data Base Updated</pre>

<p>Cette commande met uniquement à jour le fichier <code>ca-db.txt</code>, mais ne génère par la LCR.</p>

<p class="note">En conséquence, il ne devrait pas être nécessaire de préciser l'algorithme de hachage, mais la commande <code>openssl ca</code> l'impose.</p>

<p>Observer que le contenu du fichier <code>ca-db.txt</code> a été mis à jour, avec un contenu semblable au suivant :</p>
<pre>R  140407201901Z  120616153042Z,keyTime,20120616172700Z  89FC7231AEC956C0
  unknown /C=FR/O=Mon Organisation/OU=0002 963852741/CN=Entit\xC3\xA9 Finale</pre>

<p>Générer la LCR mise à jour puis l'afficher.</p>

<pre><strong>$ openssl ca -gencrl -cert ca-crt.pem -keyfile ca-key.pem -crlhours 48 \
  -md sha256 -config ca-crl.cnf -name ca_crl -crlexts ca_crl_ext \
  -out ca-crl.pem</strong>
Using configuration from ca-crl.cnf

<strong>$ openssl crl -in ca-crl.pem -noout -text</strong>
Certificate Revocation List (CRL):
        Version 2 (0x1)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: /C=FR/O=Mon Entreprise/OU=0002 123456789/OU=OpenSSL Root CA
        Last Update: Jun 16 15:44:42 2012 GMT
        Next Update: Jun 18 15:44:42 2012 GMT
        CRL extensions:
            X509v3 Authority Key Identifier:
                keyid:4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8
F

            X509v3 CRL Number:
                2
Revoked Certificates:
    Serial Number: 89FC7231AEC956C0
        Revocation Date: Jun 16 15:37:43 2012 GMT
        CRL entry extensions:
            X509v3 CRL Reason Code:
                Key Compromise
            Invalidity Date:
                Jun 16 17:27:00 2012 GMT
    Signature Algorithm: sha256WithRSAEncryption
         3d:76:18:27:a0:9c:e6:62:8f:f0:5d:c2:78:1d:34:e7:b4:a2:
         …
         84:bd:7e:35</pre>

<p class="note">Si les fichiers ont été préalablement sauvegardés, les restaurer, de manière à maintenir la validité des certificats.</p>

<h2 id="construction-lcr">Construction d'une liste de certificats révoqués</h2>

<p>La construction d'une liste de certificats révoqués est analogue à la construction d'un certificat. Dans l'exemple ci-après, la LCR reconstruite est celle contenant le numéro de série du certificat de confidentialité, générée dans la section <a href="#generation-certificat-confidentialite" class="section"/>.</p>

<h3 id="constitution-tbscertlist">Constitution d'une structure <code>TBSCertList</code></h3>

<p>Créer le fichier <code>crl-tbsCertList.asn.cnf</code> suivant.</p>

<pre>asn1 = SEQUENCE:tbsCertList

[tbsCertList]
version = INTEGER:1
signature = SEQUENCE:crl_signature
issuer = SEQUENCE:crl_issuer
thisUpdate = UTCTIME:120616154442Z
nextUpdate = UTCTIME:120618154442Z
revokedCertificates = SEQUENCE:revokedCertificates
crlExtensions = EXPLICIT:0,SEQUENCE:crlExtensions

[crl_signature]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL

[crl_issuer]
C = SET:crl_issuer_C_RDN
O = SET:crl_issuer_O_RDN
OU1 = SET:crl_issuer_OU1_RDN
OU2 = SET:crl_issuer_OU2_RDN

[crl_issuer_C_RDN]
rdn = SEQUENCE:crl_issuer_C_ATV

[crl_issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[crl_issuer_O_RDN]
rdn = SEQUENCE:crl_issuer_O_ATV

[crl_issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[crl_issuer_OU1_RDN]
rdn = SEQUENCE:crl_issuer_OU1_ATV

[crl_issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[crl_issuer_OU2_RDN]
rdn = SEQUENCE:crl_issuer_OU2_ATV

[crl_issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA

[revokedCertificates]
revokedCertificate = SEQUENCE:revokedCertificate_1

[revokedCertificate_1]
userCertificate = INTEGER:0x89fc7231aec956c0
revocationDate = UTCTIME:120616153743Z
crlEntryExtensions = SEQUENCE:crlEntryExtensions_1

[crlEntryExtensions_1]
CRLReason = SEQUENCE:CRLReason_1
invalidityDate = SEQUENCE:invalidityDate_1

[CRLReason_1]
extnID = OID:CRLReason
extnValue = OCTWRAP,ENUMERATED:1

[invalidityDate_1]
extnID = OID:invalidityDate
extnValue = OCTWRAP,GENERALIZEDTIME:20120616172700Z

[crlExtensions]
authorityKeyIdentifier = SEQUENCE:crl_authorityKeyIdentifier
crlNumber = SEQUENCE:crlNumber

[crl_authorityKeyIdentifier]
extnID = OID:authorityKeyIdentifier
extnValue = OCTWRAP,SEQUENCE:crl_authorityKeyIdentifier_seq

[crl_authorityKeyIdentifier_seq]
keyIdentifier = IMPLICIT:0,FORMAT:HEX,OCTETSTRING:\
4c6d879382f72d2c0723a20fe0712d173f39f38f

[crlNumber]
extnID = OID:crlNumber
extnValue = OCTWRAP,INTEGER:2</pre>

<p>La section <code>crl_issuer</code> (et ses dépendances) a été reprise de la section <code>ee_issuer</code> du fichier <code>ee-Certificate.asn.cnf</code>, en remplaçant le préfixe <code>ee_</code> par <code>crl_</code>. De même pour la section <code>crl_authorityKeyIdentifier</code>, copiée de la section <code>ee_authorityKeyIdentifier</code> en modifiant uniquement le préfixe.</p>

<p>Générer la représentation DER de la structure <code>TBSCertList</code> ainsi définie :</p>

<pre><strong>$ openssl asn1parse -genconf crl-tbsCertList.asn.cnf -out crl-tbsCertList.der</strong></pre>

<h3 id="signature-lcr">Signature de la liste de certificats révoqués</h3>

<p>Selon le processus de signature utilisé pour les certificats, déterminer la représentation hexadécimale de l'empreinte SHA-256 de la structure <code>TBSCertList</code> générée précédemment :</p>

<pre><strong>$ openssl sha256 crl-tbsCertList.der</strong>
SHA256(crl-tbsCertList.der)= d330d6ca5180ff1bbe87b9edcfc092cb50b96bffd537af6fb2a
07df524bde609</pre>

<p>Créer le fichier <code>crl-DigestInfo.asn.cnf</code> suivant, en copiant dans le champ <code>digest</code> l'empreinte hexadécimale :</p>

<pre>asn1 = SEQUENCE:digestInfo

[digestInfo]
digestAlgorithm = SEQUENCE:digestAlgorithm
digest = FORMAT:HEX,OCTETSTRING:\
d330d6ca5180ff1bbe87b9edcfc092cb50b96bffd537af6fb2a07df524bde609

[digestAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Générer le codage DER de la structure <code>DigestInfo</code> :</p>

<pre><strong>$ openssl asn1parse -genconf crl-DigestInfo.asn.cnf -i -out crl-DigestInfo.der</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:D330D6CA5180FF1BBE87B
9EDCFC092CB50B96BFFD537AF6FB2A07DF524BDE609</pre>

<p>Signer le fichier DER résultant à l'aide de la clé privée de l'autorité de certification, et en obtenir la représentation hexadécimale :</p>

<pre><strong>$ openssl pkeyutl -sign -in crl-DigestInfo.der -inkey ca-key.pem \
  | od -tx1 -An -w | tr -d " " | sed 's/$/\\/'</strong>
3d761827a09ce6628ff05dc2781d34e7b4a2c059cc844cdd95745d2929171670\
815ad8a81b8fb71b39d3ac97976030a4116e83a7c52e3416e27d1925b624fd05\
f1201a2488758fc14f7be440311e2d2490d1049c09fdfadbe913b37cd4204a70\
606b3cdacc5ea2665d46d44f6189d9018a80e5dc7cf87e82398bf5a8e30ce53a\
7a3458f5a48f184f5b9f83c962eabdc503289df775af605d9ac257aa4189ff52\
ebb05097a6f7db40c210ae82e24d638d01dbd4fc8df90f3f32f510ffbf8253cf\
dd85f3f27e902c7c1c456d1bca8ce3643f349bc0b60fccc31f25402eb3aa2b7e\
ba11819a2001316d3c3d409b5501ba74bb0c0b8d14a2f2ef388b4bd484bd7e35\</pre>

<h3 id="finalisation-lcr">Finalisation de la liste de certificats révoqués</h3>

<p>Copier le fichier <code>crl-tbsCertList.asn.cnf</code> sous le nom <code>crl-CertificateList.asn.cnf</code>. Y remplacer la première ligne par celle-ci :</p>

<pre>asn1 = SEQUENCE:certificateList</pre>

<p>Ajouter les sections suivantes, où le champ <code>signatureValue</code> contient la valeur de la signature numérique obtenue précédemment :</p>

<pre>[certificateList]
tbsCertList = SEQUENCE:tbsCertList
signatureAlgorithm = SEQUENCE:crl_signatureAlgorithm
signatureValue = FORMAT:HEX,BITSTRING:\
3d761827a09ce6628ff05dc2781d34e7b4a2c059cc844cdd95745d2929171670\
815ad8a81b8fb71b39d3ac97976030a4116e83a7c52e3416e27d1925b624fd05\
f1201a2488758fc14f7be440311e2d2490d1049c09fdfadbe913b37cd4204a70\
606b3cdacc5ea2665d46d44f6189d9018a80e5dc7cf87e82398bf5a8e30ce53a\
7a3458f5a48f184f5b9f83c962eabdc503289df775af605d9ac257aa4189ff52\
ebb05097a6f7db40c210ae82e24d638d01dbd4fc8df90f3f32f510ffbf8253cf\
dd85f3f27e902c7c1c456d1bca8ce3643f349bc0b60fccc31f25402eb3aa2b7e\
ba11819a2001316d3c3d409b5501ba74bb0c0b8d14a2f2ef388b4bd484bd7e35

[crl_signatureAlgorithm]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL</pre>

<p>Générer la LCR au format DER :</p>

<pre><strong>$ openssl asn1parse -genconf crl-CertificateList.asn.cnf -i \
  -out crl-CertificateList.der</strong></pre>
  
<h1 id="confidentialite-pkcs7-cms">Confidentialité — PKCS#7 et CMS</h1>

<p>Ce chapitre s'intéresse à la protection en confidentialité de données à l'aide de <i>Cryptographic Message Syntax</i>, plus connue à l'origine sous le nom de PKCS#7 d'après le document de RSA Security qui définit cette syntaxe, reprise par l'IETF sous le nom de PKCS#7 dans la RFC 2315, et étendue sous le nom de <i>Cryptographic Message Syntax</i>, ou CMS, dans la RFC 2630 (puis RFC 3369, RFC 3852, et RFC 5652, version actuelle à la date de rédaction). PKCS#7/CMS est au cœur de la norme S/MIME (<i>Secure/Multipurpose Internet Mail Extensions</i>), qui est notamment utilisée pour sécuriser les courriels (signature électronique et confidentialité). Le format PKCS#7 originel étant encore largement répandu (le support de la norme CMS dans OpenSSL a été introduit par la version 1.0.0, en mars 2010), dans ce chapitre, le terme PKCS#7 est employé lorsqu'aucune spécificité de CMS n'est employée.</p>
  
<p>Dans le cas d'usage le plus courant pour le chiffrement, PKCS#7/CMS génère une clé symétrique (ci-dessous une clé AES-256, avec l'option <code>-aes-256-cbc</code>), chiffre les données à l'aide de cette clé (ici en mode CBC), puis chiffre la clé symétrique avec la clé publique de chacun des destinataires et inclut inclut chaque exemplaire de la clé symétrique chiffrée dans la structure PKCS#7/CMS cible.</p>

<h2 id="chiffrement-fichier">Chiffrement d'un fichier</h2>

<p>Chiffrer le fichier de test <code>data.txt</code> avec le certificat de confidentialité généré ci-avant (<code>ee2-crt-confid.pem</code>), au format PKCS#7 codé en DER.</p>
<pre><strong>$ openssl smime -encrypt -in data.txt -aes-256-cbc -outform DER \
  -out data.enc.p7.der ee2-crt-confid.pem</strong></pre>
<p class="note">La commande historique <code>openssl smime</code> gère les structures PKCS#7 uniquement. Pour manipuler des structures CMS, utiliser <code>openssl cms</code> (dont la syntaxe est très proche).</p>

<h2 id="dechiffrement-fichier">Déchiffrement d'un fichier</h2>

<p>Déchiffrer les données contenues dans la structure obtenue, en utilisant la clé privée de déchiffrement <code>ee2-key.pem</code> associée à la clé publique de chiffrement incluse dans le certificat de confidentialité :</p>
<pre><strong>$ openssl smime -decrypt -in data.enc.p7.der -inform DER -inkey ee2-key.pem
texte en clair</strong></pre>

<p>Sous Windows il est possible de déchiffrer un fichier à l'aide d'une clé privée associée à un certificat du magasin de certificats de Windows, comme décrit ci-après.</p>

<p>Créer le fichier PKCS#12 rassemblant le certificat de confidentialité et la clé privée. Il n'est pas utile d'ajouter le certificat de l'AC racine si celle-ci a déjà été importée dans le magasin de certificats de Windows (cf. section <a href="#importation-magasin-windows" class="section"/>).</p>
<pre><strong>$ openssl pkcs12 -export -in ee2-crt-confid.pem -inkey ee2-key.pem \
  -name "OpenSSL EE2" -out ee2-confid.p12</strong>
Loading 'screen' into random state - done
Enter Export Password:</pre>

<p>Dans l'explorateur Windows, double-cliquer sur le fichier <code>ee2-confid.p12</code> généré et suivre la procédure d'importation.</p>

<p>Au besoin configurer l'environnement pour utiliser le moteur cryptographique <code>capi</code> d'OpenSSL (cf. annexe <a href="#openssl-capi" class="appendix_section"/>), et initier le déchiffrement du fichier chiffré, en utilisant l'option <code>-keyform ENGINE</code> et en passant en paramètre de <code>-inkey</code> une sous-chaîne de l'objet du certificat (en l'occurrence le contenu du CN).</p>

<pre><strong>$ openssl smime -decrypt -in data.enc.p7.der -inform DER -keyform ENGINE \
  -inkey "Entité Finale" -engine capi</strong></pre>
 
<p class="note">Les accents et caractères spéciaux <em>sont</em> gérés correctement dans le paramètre passé à l'option <code>-inkey</code>.</p>

<p class="note">Pour identifier la clé privée à partir du nom convivial du certificat au lieu d'une sous-chaîne de l'object du certificat (par exemple dans le cas où le nom convivial permettrait de distinguer deux certificats portant le même objet), ajouter, dans la section du fichier de configuration concernant la configuration du moteur <code>capi</code>, la ligne <code>lookup_method=2</code> après la ligne <code>init=1</code>.</p> 
 
 <p>Si la protection renforcée de la clé privée a bien été activée lors de l'importation du fichier PKCS#12, alors une alerte Windows s'affiche, demandant l'autorisation d'utiliser la clé privée à des fins de déchiffrement.</p>
 
 <img alt="Boîte de dialogue sollicitant l'autorisation de l'utilisateur pour utiliser sa clé privée" src="img/P7_CAPI_decrypt.fr.png"/>
 
 <p>Cliquer sur le bouton « Oui », et le déchiffrement s'effectue.</p>
 
<h2 id="analyse-pkcs7-cms-confidentialite">Analyse d'une structure PKCS#7/CMS</h2>

<p>Au niveau le plus général, la syntaxe ASN.1 d'une structure PKCS#7/CMS est la suivante :</p>
<pre>ContentInfo ::= SEQUENCE {
     contentType ContentType,
     content
       [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }</pre>
<p>Pour des données chiffrées à l'intention d'un ou de plusieurs destinataires, le type de contenu (<code>contentType</code>) est <code>pkcs7-envelopedData</code>, qui correspond à la structure ASN.1 <code>EnvelopedData</code> de PKCS#7. Celle-ci contient les informations sur les destinataires et leur clé publique de chiffrement dans <code>recipientInfos</code>), et des données chiffrées dans <code>encryptedContentInfo </code> (à comparer au type de contenu <code>EncryptedData</code>, qui inclut uniquement les données chiffrées).</p>

<p>Analyser le contenu du fichier <code>data.enc.p7.der</code>, à l'aide de la commande <code>openssl cms</code> qui, contrairement à <code>openssl smime</code>, propose un affichage mis en forme (en combinant les options <code>-cmsout</code> et <code>-print</code>) :</p>
<pre><strong>$ openssl cms -cmsout -in data.enc.p7.der -inform DER -print</strong>
CMS_ContentInfo:
  contentType: pkcs7-envelopedData (1.2.840.113549.1.7.3)
  d.envelopedData:
    version: &lt;ABSENT&gt;
    originatorInfo: &lt;ABSENT&gt;
    recipientInfos:
      d.ktri:
        version: &lt;ABSENT&gt;
        d.issuerAndSerialNumber:
          issuer: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
          serialNumber: 9942947635038607040
        keyEncryptionAlgorithm:
          algorithm: rsaEncryption (1.2.840.113549.1.1.1)
          parameter: NULL
        encryptedKey:
          0000 - 59 1c 7b 93 3a 30 17 a6-55 e5 af 7e 02 db 67   Y.{.:0..U..~..g
          …
          00f0 - a6 bb 75 c5 09 de 8a 93-b0 c5 fc f9 69 2c e5   ..u.........i,.
          00ff - c2                                             .
    encryptedContentInfo:
      contentType: pkcs7-data (1.2.840.113549.1.7.1)
      contentEncryptionAlgorithm:
        algorithm: aes-256-cbc (2.16.840.1.101.3.4.1.42)
        parameter: OCTET STRING:
          0000 - a4 42 ee f2 d5 87 1b d0-d2 33 32 1d 36 98 25   .B.......32.6.%
          000f - de                                             .
      encryptedContent:
        0000 - ed fa 00 e0 1d d0 1a 96-59 bd f5 55 fd 7d ac   ........Y..U.}.
        000f - c8                                             .
    unprotectedAttrs:
      &lt;EMPTY&gt;</pre>
<p class="note">Les valeurs obtenues par le lecteur seront différentes de celles ci-dessus, la clé de chiffrement et le vecteur d'initialisation étant générés aléatoirement.</p>
<div class="note">
<p>Même mis en forme par <code>-print</code>, l'affichage manque un peu de finition : numéros de version marqués absents au lieu de nuls, champ KeyTransRecipientInfo (correspondant à RecipientInfo dans la nomenclature de PKCS#7) abrégé en <code>d.ktri</code> etc. À titre d'exercice, le lecteur peut installer la bibliothèque pyasn1<span class="fn">http://sourceforge.net/projects/pyasn1/</span> pour Python<span class="fn">http://www.python.org/</span>, avec le module pyasn1_modules<span class="fn">http://sourceforge.net/projects/pyasn1/files/pyasn1-modules/</span> qui propose dans le sous-répertoire <code>tools</code> un outil de mise en forme d'une structure PKCS#7 au format PEM, nommé <code>pkcs7dump.py</code>. Le résultat obtenu est une vue plus fidèle de la structure (au détriment du contenu, parfois affiché en hexadécimal sans décodage DER, et des OID non convertis en nom convivial) :</p>
<pre><strong>$ openssl pkcs7 -in data.enc.p7.der -inform DER -outform PEM | \
  python <em>chemin_vers/</em>pkcs7dump.py</strong>
ContentInfo:
 contentType=1.2.840.113549.1.7.3
 content=0x308201c7020100318201823082017e02010030663059310b300906035504061302465
…
3321d369825de8010edfa00e01dd01a9659bdf555fd7dacc8

EnvelopedData:
 version=0
 recipientInfos=RecipientInfos:
  RecipientInfo:
   version=0
   issuerAndSerialNumber=IssuerAndSerialNumber:
    issuer=Name:
     =RDNSequence:
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.6
        value=0x13024652
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.10
        value=0x130e4d6f6e20456e7472657072697365
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.11
        value=0x130e3030303220313233343536373839
      RelativeDistinguishedName:
       AttributeTypeAndValue:
        type=2.5.4.11
        value=0x130f4f70656e53534c20526f6f74204341


    serialNumber=9942947635038607040

   keyEncryptionAlgorithm=KeyEncryptionAlgorithmIdentifier:
    algorithm=1.2.840.113549.1.1.1
    parameters=0x0500

   encryptedKey=0x591c7b933a3017a655e5af7e02db67d26a5f981c2cbc9dddbbc26c72a112ce
…
d1e4a840115f51192da6bb75c509de8a93b0c5fcf9692ce5c2

 encryptedContentInfo=EncryptedContentInfo:
  contentType=1.2.840.113549.1.7.1
  contentEncryptionAlgorithm=ContentEncryptionAlgorithmIdentifier:
   algorithm=2.16.840.1.101.3.4.1.42
   parameters=0x0410a442eef2d5871bd0d233321d369825de

  encryptedContent=0xedfa00e01dd01a9659bdf555fd7dacc8</pre></div>

<h2 id="dechiffrement-manuel-fichier">Déchiffrement manuel d'un fichier</h2>

<p>La suite de cette section s'intéresse au déchiffrement manuel des données, à travers les opérations successives suivantes :</p>
<ul>
<li>Extraire la clé symétrique chiffrée contenue dans le champ <code>encryptedKey</code> du <code>recipientInfo</code> de l'unique destinataire.</li>
<li>Déchiffrer la clé symétrique chiffrée, à l'aide de la clé privée du destinataire.</li>
<li>Extraire le contenu chiffré par la clé symétrique.</li>
<li>Extraire le vecteur d'initialisation.</li>
<li>Déchiffrer le contenu chiffré, en utilisant la clé symétrique et le vecteur d'initialisation.</li>
</ul>

<p>Afficher tout d'abord l'analyse ASN.1 de la structure PKCS#7, de manière à déterminer l'octet de début et la longueur des champs à extraire.</p>

<pre><strong>$ openssl asn1parse -in data.enc.p7.der -inform DER -i</strong>
    0:d=0  hl=4 l= 474 cons: SEQUENCE
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-envelopedData
   15:d=1  hl=4 l= 459 cons:  cont [ 0 ]
   19:d=2  hl=4 l= 455 cons:   SEQUENCE
   23:d=3  hl=2 l=   1 prim:    INTEGER           :00
   26:d=3  hl=4 l= 386 cons:    SET
   30:d=4  hl=4 l= 382 cons:     SEQUENCE
   34:d=5  hl=2 l=   1 prim:      INTEGER           :00
   37:d=5  hl=2 l= 102 cons:      SEQUENCE
   39:d=6  hl=2 l=  89 cons:       SEQUENCE
   41:d=7  hl=2 l=  11 cons:        SET
   43:d=8  hl=2 l=   9 cons:         SEQUENCE
   45:d=9  hl=2 l=   3 prim:          OBJECT            :countryName
   50:d=9  hl=2 l=   2 prim:          PRINTABLESTRING   :FR
   54:d=7  hl=2 l=  23 cons:        SET
   56:d=8  hl=2 l=  21 cons:         SEQUENCE
   58:d=9  hl=2 l=   3 prim:          OBJECT            :organizationName
   63:d=9  hl=2 l=  14 prim:          PRINTABLESTRING   :Mon Entreprise
   79:d=7  hl=2 l=  23 cons:        SET
   81:d=8  hl=2 l=  21 cons:         SEQUENCE
   83:d=9  hl=2 l=   3 prim:          OBJECT            :organizationalUnitName
   88:d=9  hl=2 l=  14 prim:          PRINTABLESTRING   :0002 123456789
  104:d=7  hl=2 l=  24 cons:        SET
  106:d=8  hl=2 l=  22 cons:         SEQUENCE
  108:d=9  hl=2 l=   3 prim:          OBJECT            :organizationalUnitName
  113:d=9  hl=2 l=  15 prim:          PRINTABLESTRING   :OpenSSL Root CA
  130:d=6  hl=2 l=   9 prim:       INTEGER           :89FC7231AEC956C0
  141:d=5  hl=2 l=  13 cons:      SEQUENCE
  143:d=6  hl=2 l=   9 prim:       OBJECT            :rsaEncryption
  154:d=6  hl=2 l=   0 prim:       NULL
  156:d=5  hl=4 l= 256 prim:      OCTET STRING      [HEX DUMP]:591C7B933A3017A65
5E5AF7E02DB67D26A5F981C2CBC9DDDBBC26C72A112CEBFDE42EC86C8CC2E8F180348A0EC0288675
…
0C5FCF9692CE5C2
  416:d=3  hl=2 l=  60 cons:    SEQUENCE
  418:d=4  hl=2 l=   9 prim:     OBJECT            :pkcs7-data
  429:d=4  hl=2 l=  29 cons:     SEQUENCE
  431:d=5  hl=2 l=   9 prim:      OBJECT            :aes-256-cbc
  442:d=5  hl=2 l=  16 prim:      OCTET STRING      [HEX DUMP]:A442EEF2D5871BD0D
233321D369825DE
  460:d=4  hl=2 l=  16 prim:     cont [ 0 ]</pre>

<p class="note">Se reporter aux affichages mis en forme obtenus précédemment pour mieux visualiser la correspondance entre le décodage ASN.1 brut et la structure PKCS#7.</p>
<p>Extraire la clé symétrique chiffrée, qui démarre dans le cas ci-dessus à l'octet 160 (le champ <code>encryptedKey</code> démarre à l'octet <code>156</code>, et son contenu démarre après l'en-tête du champ, soit <code>hl=4</code> octets plus loin), et a une longueur de <code>l=256</code> octets (sans surprise, puisque la taille du bloc RSA est égale à la taille de la clé RSA, soit 2048 bits, et que la taille de la clé AES-256 à chiffrer est de taille inférieure à la taille du bloc, donc un seul bloc de 256 octets suffit pour stocker la clé symétrique chiffrée).</p>
<pre><strong>$ openssl asn1parse -inform DER -in data.enc.p7.der -offset 160 -length 256 \
  -out data.enc.p7.encryptedkey.bin -noout</strong></pre>
<p>Déchiffrer la clé symétrique chiffrée, à l'aide de la clé privée du destinataire (<code>ee2-key.pem</code>) :</p>
<pre><strong>$ openssl pkeyutl -decrypt -in data.enc.p7.encryptedkey.bin -inkey ee2-key.pem \
  -out data.enc.p7.decryptedkey.bin</strong></pre>
<p class="note">Inutile ici d'employer l'option <code>-pkeyopt rsa_padding_mode</code>, le <i>padding</i> employé est celui par défaut, c'est-à-dire celui d'EME-PKCS1-v1_5 de PKCS#1.</p>

<p>Extraire également le contenu chiffré (<code>encryptedContent</code>), d'une longueur de 16 octets à partir de l'octet 462 (= 460 + 2).</p>
<pre><strong>$ openssl asn1parse -inform DER -in data.enc.p7.der -i -offset 462 -length 16 \
  -out data.enc.p7.encryptedcontent.bin -noout</strong></pre>

<p>Dans le cas où l'algorithme AES est utilisé par PKCS#7/CMS en mode CBC, le champ (<code>contentEncryptionAlgorithm</code>), de type <code>AlgorithmIdentifier</code> (dont la syntaxe est donnée ci-dessous), doit contenir l'identifiant de l'algorithme (l'OID d'AES-256-CBC dans le champ <code>algorithm</code>) et le vecteur d'initialisation (dans <code>parameters</code>).</p>
<pre>AlgorithmIdentifier ::= SEQUENCE {
    algorithm OBJECT IDENTIFIER,
    parameters ANY DEFINED BY algorithm OPTIONAL
}</pre>
<p>Extraire le vecteur d'initialisation (début à l'octet 444 = 442 + 2, longueur de 16 octets) :</p>
<pre><strong>$ openssl asn1parse -inform DER -in data.enc.p7.der -i -offset 444 -length 16 \
  -out data.enc.p7.iv.bin -noout</strong></pre>
<p>Convertir la clé AES-256 et le vecteur d'initialisation en leur représentation hexadécimale. Pour le vecteur d'initialisation, il suffit de copier la chaîne de caractères suivant <code>[HEX DUMP]</code> dans le dernier <code>OCTET STRING</code> du résultat de la commande <code>openssl asn1parse</code> initiale. Une autre option, basée sur les commandes <code>od</code> et <code>tr</code> est proposée pour convertir des données binaires en leur représentation hexadécimale :</p>
<pre><strong>$ od -An -tx1 data.enc.p7.iv.bin | tr -d "\r\n "</strong>
a442eef2d5871bd0d233321d369825de

<strong>$ od -An -tx1 data.enc.p7.decryptedkey.bin | tr -d "\r\n "</strong>
decbe54a194b77363c591fc747cd08eba8ba75e654d28b657b5b50815e68cfdc</pre>
<p>Déchiffrer enfin les données du fichier <code>data.enc.p7.encryptedcontent.bin</code> à l'aide d'<code>openssl pkeyutl</code> et des représentations hexadécimales de la clé AES-256 et du vecteur d'initialisation.</p>
<pre><strong>$ openssl aes-256-cbc -d -in data.enc.p7.encryptedcontent.bin \
  -K decbe54a194b77363c591fc747cd08eba8ba75e654d28b657b5b50815e68cfdc \
  -iv a442eef2d5871bd0d233321d369825de</strong>
texte en clair</pre>

<p>Le résultat obtenu est bien identique au texte en clair initial.</p>

<h2 id="specificites-cms">Spécificités de CMS</h2>

<p>L'option <code>-keyid</code> de la commande <code>openssl cms</code>, spécifique à CMS par rapport à PKCS#7 dans le cadre du chiffrement, permet de référencer les certificats des destinataires par leur champ <code>subjectKeyIdentifier</code> (s'il est présent dans le certificat, ce qui est le cas pour les certificats RGS) plutôt que par DN de l'émetteur et numéro de série. Noter qu'avec cette option, le champ <code>version</code> de <code>KeyTransRecipientInfo</code> est valué à <code>2</code> (au lieu de <code>0</code> pour PKCS#7).</p>

<pre><strong>$ openssl cms -encrypt -in data.txt -aes-256-cbc -outform DER \
  -keyid ee2-crt-confid.pem | openssl cms -cmsout -inform DER -print</strong>
CMS_ContentInfo:
  contentType: pkcs7-envelopedData (1.2.840.113549.1.7.3)
  d.envelopedData:
    version: &lt;ABSENT&gt;
    originatorInfo: &lt;ABSENT&gt;
    recipientInfos:
      d.ktri:
        version: 2
        d.subjectKeyIdentifier:
          0000 - 56 50 65 3f af 52 89 e6-ff 4f 1b d7 7b cd 74   VPe?.R...O..{.t
          000f - e6 87 33 19 9f                                 ..3..
        keyEncryptionAlgorithm:
…</pre>

<div class="note">
<p>L'autre fonctionnalité spécifique à la production de capsules CMS de type <code>EnvelopedData</code> de la commande <code>openssl cms</code>, est la possibilité de chiffrer la clé symétrique à l'aide d'une clé symétrique AES, laquelle est supposée être connue des destinataires. La première clé est dite enrobée — <i>wrapped</i> en anglais — par la seconde, ce qui est reflété dans l'identifiant et le nom de l'algorithme de chiffrement symétrique, comme illustré ci-dessous (et cf. la RFC 3565 sur l'utilisation d'AES avec CMS). Ce cas d'usage est rare.</p>

<pre><strong>$ openssl rand -hex 32</strong>
dd91174bf24b73d3e995d47c7fa649f974dc32b048a77495d4ce8876db4bf6c7

<strong>$ openssl cms -encrypt -in data.txt -aes-256-cbc -outform DER \
  -secretkey dd91174bf24b73d3e995d47c7fa649f974dc32b048a77495d4ce8876db4bf6c7 \
  -secretkeyid 0123 | openssl cms -cmsout -inform DER -print</strong>
CMS_ContentInfo:
  contentType: pkcs7-envelopedData (1.2.840.113549.1.7.3)
  d.envelopedData:
    version: &lt;ABSENT&gt;
    originatorInfo: &lt;ABSENT&gt;
    recipientInfos:
      d.kekri:
        version: 4
        kekid:
          keyIdentifier:
            0000 - 01 23                                       .#
          date: &lt;ABSENT&gt;
          other: &lt;ABSENT&gt;
        keyEncryptionAlgorithm:
          algorithm: id-aes256-wrap (2.16.840.1.101.3.4.1.45)
          parameter: &lt;ABSENT&gt;
        encryptedKey:
          0000 - ef af da 73 6d 03 92 db-57 57 16 c6 97 1d e8   ...sm...WW.....
…</pre></div>

<h1 id="confidentialite-xml-encryption">Confidentialité — XML Encryption</h1>

<p>La norme XML Encryption (souvent appelé « XML Enc ») a été conçue par le W3C pour pouvoir encapsuler des données (XML ou non) chiffrées dans un document XML, par exemple au sein d'un message SOAP dans le cas de <i>web services</i> (services web).</p>

<div class="note">
<p>Le lecteur intéressé pourra lire, dans cette présentation<span class="fn">https://www.owasp.org/images/5/5a/07A_Breaking_XML_Signature_and_Encryption_-_Juraj_Somorovsky.pdf</span>, formalisée par ce document<span class="fn">http://www.nds.rub.de/media/nds/veroeffentlichungen/2011/10/22/HowToBreakXMLenc.pdf</span>, comment, dans certains contextes d'utilisation de XML Encryption, et notamment pour chiffrer des messages de type <i>web service</i>, les caractéristiques de XML Encrytion constituent une faille permettant de déchiffrer un texte chiffré. Cette faille résulte essentiellement de l'associativité de l'opération ou-exclusif employée par le mode CBC, et du caractère prévisible de la structure d'un message XML et des caractères qu'il contient (en particulier le délimiteur de balises <code>&lt;</code>).</p>
</div>

<p>Pour protéger la confidentialité de données, XML Encryption substitue à celles-ci un élément XML <code>xenc:EncryptedData</code> (le préfixe <code>xenc:</code> désigne ci-après l'espace de nommage — ou <i>namespace</i> — <code>http://www.w3.org/2001/04/xmlenc#</code>), contenant obligatoirement les données chiffrées (<code>xenc:CipherData</code>), souvent l'algorithme de chiffrement (<code>xenc:EncryptionMethod</code>) et les informations d'identification de la (ou des) clé(s) de chiffrement (<code>ds:KeyInfo</code><a name="KeyInfo"/>, où le préfixe <code>ds:</code> représente l'espace de nommage <code>http://www.w3.org/2000/09/xmldsig#</code>), et quelquefois des informations complémentaires (<code>xenc:EncryptionProperties</code>).</p>

<p>Parmi les modes d'utilisation proposés par XML Encryption, celui retenu dans les exemples ci-après consiste à chiffrer (en mode CBC) les données à protéger avec une clé symétrique (AES-256), elle-même chiffrée par la clé publique (RSA) du destinataire, et à inclure clé chiffrée et données chiffrées dans l'élément <code>xenc:EncryptedData</code> résultant.</p>

<p>Cette section s'appuie sur l'outil en ligne de commande <code>xmlsec</code> issu de XML Security Library, cet outil étant l'équivalent XML de la commande <code>openssl smime</code> ou <code>openssl cms</code> du monde binaire, aussi bien pour la fonction de confidentialité que pour la fonction de signature électronique (abordée dans le prochain chapitre).</p>

<p>La commande <code>xmlenc --encrypt</code> fonctionne sur la base d'un fichier d'entrée (XML ou non) et d'un fichier dit <i>template</i> (ou modèle) représentant le squelette de l'élément <code>xenc:EncryptedData</code> à constituer pour remplacer l'élément à chiffrer, lequel peut être le fichier d'entrée dans son intégralité s'il s'agit d'un fichier non XML, ou tout ou partie d'un fichier XML.</p>

<h2 id="chiffrement-fichier-non-xml">Chiffrement d'un fichier non XML</h2>

<p>Créer le fichier modèle <code>xenc-tmpl-ki-certificate.xml</code> (<code>ki-certificate</code> indique que l'élément <code>ds:KeyInfo</code> référencera la clé publique de confidentialité via son certificat), avec le contenu suivant :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xenc:EncryptedData
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
  <xenc:EncryptionMethod
      Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/>
  <ds:KeyInfo>
    <xenc:EncryptedKey>
      <xenc:EncryptionMethod
          Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"/>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate/>
        </ds:X509Data>
      </ds:KeyInfo>
      <xenc:CipherData>
        <xenc:CipherValue/>
      </xenc:CipherData>
    </xenc:EncryptedKey>
  </ds:KeyInfo>
  <xenc:CipherData>
    <xenc:CipherValue/>
  </xenc:CipherData>
</xenc:EncryptedData>]]></pre>

<p>Les trois nœuds fils de <code>xenc:EncryptedData</code> sont les éléments évoqués ci-dessus :</p>

<ul>
<li><code>xenc:EncryptionMethod</code> identifie l'algorithme de chiffrement des données, en l'occurrence AES-256 en mode CBC.</li>
<li><code>ds:KeyInfo</code> référence la clé de chiffrement AES-256, comme décrit ci-après.</li>
<li><code>xenc:CipherData</code> contient les données chiffrées ou plus exactement, dans le cas du chiffrement par bloc (ce qui est le cas de CBC), cet élément contient la concaténation du vecteur d'initialisation et des données chiffrées.</li>
</ul>

<p>L'élément <code>ds:KeyInfo</code> sous <code>xenc:EncryptedData</code> contient un seul nœud fils, <code>xenc:EncryptedKey</code>. Cet élément a un schéma très proche de celui de <code>xenc:EncryptedData</code> mais est prévu pour contenir des clés de chiffrement (à l'exclusion de tout autre type de donnée) chiffrées, en l'occurrence la clé symétrique AES-256. Il contient ainsi les éléments suivants :</p>

<ul>
<li><code>xenc:EncryptionMethod</code>, qui identifie l'algorithme de chiffrement de la clé symétrique, RSA (en mode PKCS#1 version 1.5).</li>
<li><code>ds:KeyInfo</code> référence la clé publique de confidentialité du destinataire. Comme celle-ci est contenue dans un certificat X.509, il a été choisi de la représenté par des données X.509 (<code>ds:X509Data</code>), et plus précisément par le certificat lui-même (<code>ds:X509Certificate</code>), d'autres possibilités étant proposées plus loin.</li>
<li><code>xenc:CipherData</code> contient la clé chiffrée.</li>
</ul>

<p>Dans le fichier squelette <code>xenc-tmpl-ki-certificate.xml</code>, les trois éléments laissées vides sont à renseigner par <code>xmlenc</code> lors de l'opération de chiffrement :</p>

<ul>
<li><code>ds:Certificate</code> contiendra le codage Base64 du codage DER du certificat de confidentialité contenant la clé publique avec laquelle a été chiffrée la clé symétrique de chiffrement (ou clé de session dans la terminologie de <code>xmlsec</code>).</li>
<li>Le premier élément <code>xenc:CipherData</code>, sous <code>xenc:EncryptedKey</code>, contiendra le codage Base64 de la clé symétrique de chiffrement chiffrée</li>
</ul>

<p>Chiffrer le fichier <code>data.txt</code> créé au début de ce document, à l'aide d'une clé de session AES-256, elle-même chiffrée avec la clé publique générée en début de chapitre. Ajouter l'option <code>--output data.xenc-ki-certificate.xml</code> avant le nom du fichier <i>template</i> pour sauvegarder</p>

<pre><strong>$ xmlsec --encrypt --binary-data data.txt --pubkey-cert-pem ee2-crt-confid.pem \
  --session-key aes-256 --output data.xenc-ki-certificate.xml \
  xenc-tmpl-ki-certificate.xml</strong></pre>

<p>Le fichier <code>data.xenc-ki-certificate.xml</code> résultant est le suivant (au contenu des champs <code>CipherValue</code> près, la clé de session étant générée aléatoirement) :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xenc:EncryptedData xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
  <xenc:EncryptionMethod
      Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/>
  <ds:KeyInfo>
    <xenc:EncryptedKey>
      <xenc:EncryptionMethod
          Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"/>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>
MIID9jCCAt6gAwIBAgIJAIn8cjGuyVbAMA0GCSqGSIb3DQEBCwUAMFkxCzAJBgNV
…
Xu2IRj0LE3ZRthFl+PLDZeaKDClOq/DEtJAV/K25DKzEJ9/FinOnhGGPHHwjkjuj
y2/ys5JBXFMBOw==</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
      <xenc:CipherData>
        <xenc:CipherValue>
j+eQRCIXznXjvHnJS3dK+a/UGeuXlmA+JV6B/Rl5053XG/zjvmYOqv2NUb7fxM3S
T/c0xy8RV9T83P6fYtFcELpY+sasOkHdFqBAvCihAYNd/y8MIz/wv+wM7iCiMdU6
tKGvDs3L6ATYe93dxt8YEMPQj9zo4G3FdzMRHGdr2Y8mCORVKQ9GyBuPymi6ZGKr
2gQXzSeI+SjCMcpsRMw3tr/yLRqwf0gzfqDigr7OGLJxwJl5uBUiMwItXG+zvPVA
HApPMFyBbGQpA9tnmHYVQ6h3yqivlzzKM+vGzcbbgFcAt/U68ndPn4FlELM9sIXM
cyM6Hmo58yS3e3HJQS5ihQ==
        </xenc:CipherValue>
      </xenc:CipherData>
    </xenc:EncryptedKey>
  </ds:KeyInfo>
  <xenc:CipherData>
    <xenc:CipherValue>
      9f4cxjwvWx2yP6amxRJzwgscq4w+Yv3yA+B2Fje9JRs=
    </xenc:CipherValue>
  </xenc:CipherData>
</xenc:EncryptedData>]]></pre>

<p class="note">Le résultat a été remis en page pour tenir compte des contraintes d'affichage de ce document, mais ces modifications n'impactent nullement l'intégrité du contenu, le format XML et le codage Base64 étant très permissifs quant à l'utilisation des espaces (au sens large, incluant les tabulations et les retours chariot).</p>

<h2 id="dechiffrement-fichier-xmlsec">Déchiffrement d'un fichier</h2>

<p>Déchiffrer ce fichier, en notant que <code>xmlsec</code> a besoin de la chaîne de certification (option <code>--trusted-pem</code>, voire <code>--untrusted-pem</code>) pour vérifier le certificat de chiffrement, sans quoi le résultat du déchiffrement sera assorti d'un message d'erreur (<code>unable to get local issuer certificate</code>).</p>

<pre><strong>$ xmlsec --decrypt --privkey-pem ee2-key.pem --trusted-pem ca-crt.pem \
  data.xenc-ki-certificate.xml</strong>
texte en clair</pre>

<p class="note">La commande <code>xmlsec</code> ne permet pas d'utiliser le moteur <code>capi</code> d'OpenSSL.</p>

<h2 id="dechiffrement-manuel-fichier-xmlsec">Déchiffrement manuel d'un fichier</h2>

<p>Le déchiffrement manuel d'un fichier XML Encryption s'appuie sur l'outil en ligne de commande XMLStarlet<span class="fn">http://xmlstar.sourceforge.net/</span>, dont la commande <code>xml sel</code> permet notamment d'extraire les valeurs de nœuds XML à partir d'un chemin XPath.</p>

<p class="note">L'extraction manuelle de ces valeurs est évidemment possible, mais l'objectif secondaire ici est d'ajouter un outil à l'arsenal du lecteur.</p>

<p>Pour illustrer la commande <code>xml sel</code>, voici comment afficher la valeur du nœud <code>xenc:CipherData</code> contenant le vecteur d'initialisation et la clé de session chiffrée par la clé publique du destinataire :</p>

<pre><strong>$ xml sel -N enc=http://www.w3.org/2001/04/xmlenc# \
 -N ds=http://www.w3.org/2000/09/xmldsig# -t -v \
 /enc:EncryptedData/ds:KeyInfo/enc:EncryptedKey/enc:CipherData/enc:CipherValue \
 data.xenc-ki-certificate.xml</strong>
j+eQRCIXznXjvHnJS3dK+a/UGeuXlmA+JV6B/Rl5053XG/zjvmYOqv2NUb7fxM3S
T/c0xy8RV9T83P6fYtFcELpY+sasOkHdFqBAvCihAYNd/y8MIz/wv+wM7iCiMdU6
tKGvDs3L6ATYe93dxt8YEMPQj9zo4G3FdzMRHGdr2Y8mCORVKQ9GyBuPymi6ZGKr
2gQXzSeI+SjCMcpsRMw3tr/yLRqwf0gzfqDigr7OGLJxwJl5uBUiMwItXG+zvPVA
HApPMFyBbGQpA9tnmHYVQ6h3yqivlzzKM+vGzcbbgFcAt/U68ndPn4FlELM9sIXM
cyM6Hmo58yS3e3HJQS5ihQ==</pre>

<p>L'option <code>-N</code> permet de déclarer un espace de nommage, <code>-t</code> introduit les traitements à appliquer, et le paramètre de l'option <code>-v</code> définit le chemin XPath du nœud dont la valeur est à extraire.</p>

<p class="note">La commande <code>xml sel</code> applique une feuille de style XSLT, dont chaque élément <code>xsl:template</code> (le préfixe <code>xsl:</code> représente ici l'espace de nommage <code>http://www.w3.org/1999/XSL/Transform</code>) est généré par une option <code>-t</code>. Dans le cas ci-dessus, l'option <code>-v</code> fait appel à la fonction XSLT <code>xsl:value-of</code>. L'option globale <code>-C</code> permet d'afficher la XSLT intermédiaire appliquée (rarement optimale mais toujours efficace !).</p>

<div class="note">
<p>La bibliothèque libxml2, utilisée par <code>xmlsec</code> et <code>xml</code>, inclut un outil en ligne de commande, <code>xmllint</code>, permettant de manipuler des structures XML, et proposant un mini-shell pour effectuer des opérations en mode interactif. L'affichage de la valeur d'un nœud par son chemin XPath par le shell s'effectue de la manière suivante :</p>
<pre><strong>$ xmllint --shell data.xenc-ki-certificate.xml
/ > setns enc=http://www.w3.org/2001/04/xmlenc#
/ > setns ds=http://www.w3.org/2000/09/xmldsig#
/ > cat /enc:EncryptedData/ds:KeyInfo/enc:EncryptedKey/enc:CipherData/enc:Cipher
Value/text()</strong>
 -------
j+eQRCIXznXjvHnJS3dK+a/UGeuXlmA+JV6B/Rl5053XG/zjvmYOqv2NUb7fxM3S
T/c0xy8RV9T83P6fYtFcELpY+sasOkHdFqBAvCihAYNd/y8MIz/wv+wM7iCiMdU6
tKGvDs3L6ATYe93dxt8YEMPQj9zo4G3FdzMRHGdr2Y8mCORVKQ9GyBuPymi6ZGKr
2gQXzSeI+SjCMcpsRMw3tr/yLRqwf0gzfqDigr7OGLJxwJl5uBUiMwItXG+zvPVA
HApPMFyBbGQpA9tnmHYVQ6h3yqivlzzKM+vGzcbbgFcAt/U68ndPn4FlELM9sIXM
cyM6Hmo58yS3e3HJQS5ihQ==</pre>
<p>Pour sauvegarder la valeur du nœud dans un fichier, utiliser, dans la suite de la session shell ci-dessus :</p>
<pre><strong>/ > cd /enc:EncryptedData/ds:KeyInfo/enc:EncryptedKey/enc:CipherData/enc:CipherV
alue/text()
text > write data.xenc-ki-certificate.encryptedkey.b64</strong></pre>
</div>

<p>La valeur intermédiaire extraite n'a pas d'intérêt particulier codée en Base64, et peut donc être transmise à <code>openssl base64</code> sans fichier intermédiaire pour obtenir la valeur finale :</p>

<pre><strong>$ xml sel -N enc=http://www.w3.org/2001/04/xmlenc# \
 -N ds=http://www.w3.org/2000/09/xmldsig# -t -v \
 /enc:EncryptedData/ds:KeyInfo/enc:EncryptedKey/enc:CipherData/enc:CipherValue \
 data.xenc-ki-certificate.xml \
 | openssl base64 -d -out data.xenc-ki-certificate.encryptedkey.bin</strong></pre>

<p class="note">Pour passer par un fichier intermédiaire, utiliser le caractère de redirection <code>></code> pour écrire le résultat de la commande <code>xml sel</code> dans un fichier.</p>
 
<p class="note">Les valeurs codées en Base64 par <code>xmlsec</code> sont découpées en lignes de 64 caractères. Cette limite de 64 caractères était initialement imposée dans la RFC 1421 qui définit le codage Base64, avant d'être relevée à 76 caractères par MIME dans la RFC 2045. Ces limites se retrouvent notamment dans OpenSSL, qui découpe ses codages Base64 en lignes de 64 caractères par souci de compatibilité, et refuse de traiter des lignes de Base64 de plus de 76 caractères. Les valeurs codées en Base64 dans les structures XML sont souvent représentées par le type base64Binary défini par la norme XML Schema. Ce type recommande une limite de 76 caractères sans l'imposer, et il n'est pas rare d'avoir à traiter des nœuds XML contenant des données codées en Base64 sur une seule ligne de longueur (parfois très largement) supérieure à 76 caractères, ce qui n'est pas du goût de tous les décodeurs Base64, à commencer par OpenSSL. La commande UNIX/GNU/Gnuwin32 <code>fold -w 64</code> permet de découper une telle ligne en lignes de 64 caractères.</p>

<p>Extraire le contenu chiffré codé en Base64 et le décoder :</p>

<pre><strong>$ xml sel -N enc=http://www.w3.org/2001/04/xmlenc# \
  -t -v /enc:EncryptedData/enc:CipherData/enc:CipherValue \
  data.xenc-ki-certificate.xml \
  | openssl base64 -d -out data.xenc-ki-certificate.cipherdata.bin</strong></pre>

<p>Le contenu obtenu concaténant le vecteur d'initialisation et les données chiffrées, ces deux éléments doivent être séparés.</p>

<p>Le vecteur d'initialisation a une taille égale à la taille d'un bloc de l'algorithme symétrique de chiffrement, c'est-à-dire 128 bits pour AES, soit 16 octets, qui peuvent être extraits par la commande UNIX/GNU/GnuWin <code>head</code> (via <code>head -c 16</code>). Le déchiffrement de la clé de chiffrement s'effectuant à l'aide de la commande <code>openssl aes-256-cbc</code>, qui attend des valeurs hexadécimales pour le vecteur d'initialisation et la clé AES-256 (cf. chapitre <a href="#crypto-symetrique" class="chapter"/>), il faut obtenir la représentation hexadécimale du vecteur d'initialisation, ce qui est par exemple possible en utilisant <code>od -An -tx1</code> pour obtenir une représentation mise en forme (indentée et sur éventuellement sur plusieurs lignes), à filtrer par <code>tr -d "\n\r "</code> qui supprime espaces et retours chariot.</p>

<pre><strong>$ head -c 16 data.xenc-ki-certificate.cipherdata.bin | od -An -tx1 \
  | tr -d "\n\r "</strong>
f5fe1cc63c2f5b1db23fa6a6c51273c2</pre>

<p>Extraire les données chiffrées, situées après les 16 premiers octets, à l'aide de la commande UNIX/GNU/GnuWin <code>dd</code> :</p>
<pre>$ dd bs=1 skip=16 if=data.xenc-ki-certificate.cipherdata.bin \
  of=data.xenc-ki-certificate.decryptedcontent.bin
16+0 enregistrements lus.
16+0 enregistrements écrits.
16 bytes (16 B) copied, 0 seconds, Infinity B/s</pre>

<p>Déchiffrer à présent la clé de session chiffrée, en utilisant la clé privée du destinataire, et en obtenir la représentation hexadécimale attendue par <code>openssl aes-cbc-256</code>, comme précédemment :</p>

<pre><strong>$ openssl pkeyutl -decrypt -in data.xenc-ki-certificate.encryptedkey.bin \
  -inkey ee2-key.pem | od -An -tx1 | tr -d "\n\r "</strong>
50b858866904ede6d01f1d09b4bead9595d6a280e4cfc1c7e8373f50090f959b</pre>

<p>Tenter de déchiffrer le contenu chiffré en utilisant la clé de session et le vecteur d'initialisation :</p>

<pre><strong>$ openssl aes-256-cbc -d -iv f5fe1cc63c2f5b1db23fa6a6c51273c2 \
  -K 50b858866904ede6d01f1d09b4bead9595d6a280e4cfc1c7e8373f50090f959bc29 \
  -in data.xenc-ki-certificate.decryptedcontent.bin</strong>
bad decrypt
6960:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:.\
crypto\evp\evp_enc.c:548:</pre>

<p>Le déchiffrement n'échoue pas à cause d'une clé ou d'un vecteur d'initialisation incorrect mais à cause de l'impossibilité pour OpenSSL de décoder le <i>padding</i> mis en œuvre par XML Encryption, qui fixe uniquement le dernier octet au nombre d'octets de remplissage et les autres octets de remplissage à une valeur aléatoire, contrairement au <i>padding</i> standard PKCS#5 qui fixe les <em>n</em> derniers octets au nombre <em>n</em> d'octets de remplissage.</p>

<p class="note">Le déchiffrement peut réussir ci-dessus si les octets de remplissage aléatoires prennent tous la valeur <em>n</em>, ce qui se produit avec une probabilité de 1 sur 256<sup><em>n</em>-1</sup>.</p>

<p>Déchiffrer les données en désactivant le décodage du <i>padding</i> et en injectant le résultat dans la commande <code>od</code> :</p>

<pre><strong>$ openssl aes-256-cbc -d -iv f5fe1cc63c2f5b1db23fa6a6c51273c2 \
  -K 50b858866904ede6d01f1d09b4bead9595d6a280e4cfc1c7e8373f50090f959bc29 \
  -in data.xenc-ki-certificate.decryptedcontent.bin -nopad | od -tx1z</strong>
<![CDATA[0000000 74 65 78 74 65 20 65 6e 20 63 6c 61 69 72 59 02  >texte en clairY.<
0000020]]></pre>

<p>Le texte en clair est bien rétabli, et les octets de <i>padding</i> <code>0x59 0x02</code> sont visualisés (avec le dernier octet <code>0x02</code> indiquant le nombre d'octets de <i>padding</i> à ignorer).</p>

<h2 id="chiffrement-element-xml">Chiffrement d'un élément XML</h2>

<p>Le chiffrement d'un élément XML s'appuie sur un fichier squelette semblable à celui utilisé pour le chiffrement d'un fichier non XML, mais l'élément <code>EncryptedData</code> contient un attribut <code>Type</code> dont la valeur (à savoir <code>http://www.w3.org/2001/04/xmlenc<em>#Element</em></code>) indique que les données à chiffrées sont un élément XML.</p>

<p>Dans le fichier squelette ci-dessous (nommé <code>xenc-tmpl-element-ki-ski.xml</code>), il a été choisi de référencer le certificat de chiffrement dans la structure finale par la valeur de son champ <code>SubjectKeyIdentifier</code> en utilisant l'élément <code>X509SKI</code>.</p>

<p class="note">Il est également possible de référencer le certificat par le DN de son émetteur et son numéro de série (élement <code>X509IssuerSerial</code>) et/ou par le DN de son objet (<code>X509SubjectName</code>), comme défini dans la section 4 de [XML-DSIG]<span class="fn">http://www.w3.org/TR/2001/PR-xmldsig-core-20010820/#sec-X509Data</span>.</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xenc:EncryptedData
    xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
    Type="http://www.w3.org/2001/04/xmlenc#Element">
<xenc:EncryptionMethod
    Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/>
<ds:KeyInfo>
<xenc:EncryptedKey>
<xenc:EncryptionMethod
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"/>
<ds:KeyInfo>
<ds:X509Data>
<ds:X509SKI/>
</ds:X509Data>
</ds:KeyInfo>
<xenc:CipherData>
<xenc:CipherValue/>
</xenc:CipherData>
</xenc:EncryptedKey>
</ds:KeyInfo>
<xenc:CipherData>
<xenc:CipherValue/>
</xenc:CipherData>
</xenc:EncryptedData>
]]></pre>

<p>Créer ensuite le fichier de test <code>data.xml</code> suivant.</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
<data>Texte en clair</data>
</root>
]]></pre>

<p>Procéder au chiffrement du nœud dont le chemin XPath est <code>/root/data</code>, en utilisant l'option <code>--node-xpath</code> de <code>xmlsec</code> pour spécifier ce chemin. Le contenu de ce nœud sera remplacé par une arborescence XML correspondant au fichier squelette.</p>

<pre><strong>$ xmlsec --encrypt --xml-data data.xml --pubkey-cert-pem ee2-crt-confid.pem
  --session-key aes-256 --node-xpath /root/data xenc-tmpl-element-ki-ski.xml</strong>
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <EncryptedData xmlns="http://www.w3.org/2001/04/xmlenc#"
    Type="http://www.w3.org/2001/04/xmlenc#Element">
    <EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/>
    <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
      <EncryptedKey xmlns="http://www.w3.org/2001/04/xmlenc#">
        <EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"/>
        <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
          <X509Data>
            <X509SKI>VlBlP69Sieb/TxvXe8105oczGZ8=</X509SKI>
          </X509Data>
        </KeyInfo>
        <CipherData>
          <CipherValue>
Dsjod0+WEHWYOt8MYxUZeVmpba9ByvM5wzB73HxDtcVIqSRzxW2YH1wpSvBuLlps
i5qiB7U9rybQOebulZ2fFyTooxB1JMMJAItmDBGwgBNbyFTPxjDBTpNQRlM9RUV3
EscmZOKLlUSqmqikx3DYh4M7pawmAkzYBiIhh3/5jpL3yWhnEHSjq8Q3Xdv6ysOF
HIr4gS+KxKudNn8xlBj+MROyxHK9WBdnbL5TkKnC9HfNM1hqmJUgrwIv60QtZs38
tGcHiV9ouP2DJyGScOhMtdDBVN5x5VMs7OOmosTpt70vKAOq0w0r4PUWnA9ABns+
62wLfUxyB6qcfhJ86p3+AQ==
          </CipherValue>
        </CipherData>
      </EncryptedKey>
    </KeyInfo>
    <CipherData>
      <CipherValue>
        Eaar+WnM3H/t0hVC9ynXzEs0QbTquYQ7Z8Kt1AkB/7KlHRAyiCmD0S/TLWIA2kuj
      </CipherValue>
    </CipherData>
  </EncryptedData>
</root>]]>
</pre>

<p>Pour chiffrer la valeur de l'élément (c'est-à-dire le contenu textuel) au lieu de l'élément entier, utiliser le chemin XPath <code>/root/data/text()</code> en paramètre de <code>--node-xpath</code> :</p>

<pre><strong>$ xmlsec --encrypt --xml-data data.xml --pubkey-cert-pem ee2-crt-confid.pem \
--session-key aes-256 --node-xpath /root/data/text() \
xenc-tmpl-element-ki-ski.xml</strong>
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data><xenc:EncryptedData xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
    Type="http://www.w3.org/2001/04/xmlenc#Element">
    …
    </xenc:EncryptedData></data>
</root>]]></pre>

<h1 id="signature-pkcs7-cms">Signature électronique — PKCS#7/CMS</h1>

<p>La structure de données <i>Cryptographic Message Syntax</i> présentée dans le chapitre précédent avec les structures PKCS#7 et CMS, permet d'inclure des données signées, et est adaptée à la signature de données binaires (au sens large, c'est-à-dire par opposition aux données structurées au format XML). Elle est à la base des formats de signature électronique avancée CAdES et PAdES.</p>

<p>Indépendamment du format de signature électronique, une signature et les données faisant l'objet de la signature peuvent coexister de plusieurs manières :</p>

<ul>
<li>La signature et les données sont dans deux fichiers séparés : la signature est dite <em>détachée</em>, et contient parfois — en plus de l'empreinte des données — une référence technique au contenu signé, à l'exemple d'un URI (<i>uniform resource identifier</i>, ou identifiant de ressource uniforme, dont les URL usuelles sont un cas particulier).</li>
<li>La structure de données constituant la signature électronique contient les données : la signature est <em>enveloppante</em>.</li>
<li>Les données englobent la signature : la signature est <em>enveloppée</em>.</li>
</ul>

<p>Une structure PKCS#7/CMS peut contenir les données signées pour produire une signature enveloppante. Sinon elle peut être détachée ou, par exemple dans le cas de PAdES, enveloppée.</p>

<h2 id="signature-fichier">Signature d'un fichier</h2>

<p>Signer le fichier de test <code>data.txt</code> avec le certificat d'authentification et signature généré dans la section <a href="#generation-certificat-ee-authsig" class="section"/> (<code>ee-crt-authsig.pem</code>), au format PKCS#7 détaché, codé en DER, en utilisant l'algorithme de signature RSA (implicite) avec SHA-256.</p>
<pre><strong>$ openssl smime -sign -in data.txt -signer ee-crt-authsig.pem \
  -inkey ee-key.pem -outform DER -out sig-p7.der -md sha256 \
  -nosmimecap</strong></pre>

<p class="note">L'option <code>-nosmimecap</code> est non documentée pour la commande <code>openssl smime</code> (elle l'est pour <code>openssl cms</code>) : elle évite d'inclure l'attribut <code>SMIMECapabilities</code>, spécifique à S/MIME (cf. RFC 3851, section 2.5.2) dans les attributs signés.</p>

<p>Produire une signature PKCS#7 enveloppante avec le même fichier de test, à l'aide de l'option <code>-nodetach</code> :</p>

<pre><strong>$ openssl smime -sign -in data.txt -signer ee-crt-authsig.pem \
  -inkey ee-key.pem -outform DER -nodetach -out data.sig-enveloping.p7.der \
  -md sha256 -nosmimecap</strong></pre>

<p>Sous Windows il est possible de signer un fichier à l'aide d'une clé privée associée à un certificat du magasin de certificats de Windows. Importer le certificat d'authentification et signature dans le magasin de certificats de Windows si cela n'a pas déjà été fait (cf. section <a href="#importation-magasin-windows" class="section"/>). Configurer au besoin l'environnement (fichier de configuration spécifique et variable d'environnement <code>OPENSSL_CONF</code>, cf. annexe <a href="#openssl-capi" class="appendix_section"/>) pour utiliser le moteur cryptographique <code>capi</code> d'OpenSSL, puis initier la signature du fichier en utilisant les options <code>-keyform ENGINE</code> et <code>-engine capi</code>, et en passant en paramètre de <code>-inkey</code> une sous-chaîne de l'objet du certificat (ci-dessous le contenu du CN).</p>

<pre><strong>$ openssl smime -sign -in data.txt -signer ee-crt-authsig.pem \
  -keyform ENGINE -engine capi -inkey "Nom Prénom" -outform DER \
  -out sig-p7.der -md sha1 -nosmimecap</strong></pre>
 
<p class="note">Les accents et caractères spéciaux sont gérés correctement dans le paramètre passé à l'option <code>-inkey</code>.</p>

<div class="note">
<p>L'algorithme de hachage a été dégradé à SHA-1, le moteur <code>capi</code> d'OpenSSL supportant uniquement l'utilisation des algorithmes de hachage du fournisseur cryptographique Microsoft Enhanced Cryptographic Provider v1.0 (SHA-1 et MD5), excluant les algorithmes de hachage de la famille SHA-2, qui sont seulement supportés par le fournisseur cryptographique Microsoft Enhanced RSA and AES Cryptographic Provider, introduit dans le <i>service pack</i> 3 de Windows XP.</p>
<p>Pour prendre en compte SHA-256, en théorie, il suffirait d'ajouter quelques lignes de code dans la fonction <code>capi_rsa_sign()</code> du fichier source <code>engines\e_capi.c</code> d'OpenSSL pour associer l'identifiant d'algorithme <code>NID_sha256</code> d'OpenSSL à l'identifiant <code>CALG_SHA_256</code> de la CryptoAPI de Microsoft, de recompiler le code source d'OpenSSL pour obtenir une nouvelle bibliothèque <code>capi.dll</code>, et de configurer l'utilisation du moteur <code>capi</code> pour utiliser le bon type de fournisseur cryptographique (<code>csp_type = 24</code> dans le fichier de configuration d'OpenSSL, correspondant au type <code>PROV_RSA_AES</code> de la CryptoAPI<span class="fn">http://msdn.microsoft.com/en-us/library/windows/desktop/aa387447%28v=vs.85%29.aspx</span>) et le bon fournisseur cryptographique (<code>csp_name = Microsoft Enhanced RSA and AES Cryptographic Provider</code>), mais en pratique, le fournisseur cryptographique est réinitialisé à celui par défaut lors du chargement de la clé privée (il s'agit sans doute d'un bug), laissant l'utilisation de SHA-256 hors de portée.</p>
</div>
 
 <p>Si la protection renforcée de la clé privée a bien été activée lors de l'importation du fichier PKCS#12, alors une alerte Windows s'affiche, demandant l'autorisation d'utiliser la clé privée à des fins de signature.</p>
 
 <img alt="Boîte de dialogue sollicitant l'autorisation de l'utilisateur pour utiliser sa clé privée pour signer des données" src="img/P7_CAPI_sign.en.png"/>
 
 <p>Cliquer sur le bouton « Oui », et la signature s'effectue.</p>

<h2 id="verification-signature">Vérification d'une signature</h2>

<p>Vérifier la signature détachée. Le fichier d'origine doit être fourni pour effectuer cette opération.</p>
<pre><strong>$ openssl smime -verify -inform DER -in sig-p7.der \
  -content data.txt -CAfile ca-crt.pem</strong>
texte en clairVerification successful</pre>

<p class="note">Le contenu signé est affiché sur la sortie standard. Pour éviter cet affichage, qui n'est pas utile dans le cas d'une signature détachée, rediriger la sortie standard vers <code>nul</code> (Windows) ou <code>/dev/null</code> (environnements de type UNIX).</p>

<p>Vérifier la signature enveloppante, en restituant les données enveloppées :</p>

<pre><strong>$ openssl smime -verify -inform DER -in data.sig-enveloping.p7.der \
  -CAfile ca-crt.pem -out data-restored.txt</strong>
Verification successful

<strong>$ cat data-restored.txt</strong>
texte en clair</pre>

<h2 id="analyse-pkcs7-cms-signature">Analyse d'une structure PKCS#7/CMS</h2>

<p>Analyser le contenu du fichier constituant la signature détachée :</p>

<pre><strong>$ openssl cms -in sig-p7.der -inform DER -cmsout -print</strong>
CMS_ContentInfo:
  contentType: pkcs7-signedData (1.2.840.113549.1.7.2)
  d.signedData:
    version: 1
    digestAlgorithms:
        algorithm: sha256 (2.16.840.1.101.3.4.2.1)
        parameter: NULL
    encapContentInfo:
      eContentType: pkcs7-data (1.2.840.113549.1.7.1)
      eContent: &lt;ABSENT&gt;
    certificates:
      d.certificate:
        … <em>certificat du signataire</em>…
    crls:
      &lt;EMPTY&gt;
    signerInfos:
        version: 1
        d.issuerAndSerialNumber:
          issuer: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
          serialNumber: 15911814405079687111
        digestAlgorithm:
          algorithm: sha256 (2.16.840.1.101.3.4.2.1)
          parameter: NULL
        signedAttrs:
            object: contentType (1.2.840.113549.1.9.3)
            value.set:
              OBJECT:pkcs7-data (1.2.840.113549.1.7.1)

            object: signingTime (1.2.840.113549.1.9.5)
            value.set:
              UTCTIME:Apr 27 19:19:32 2012 GMT

            object: messageDigest (1.2.840.113549.1.9.4)
            value.set:
              OCTET STRING:
                0000 - 89 bd 92 28 6d 6c 80 14-c0 60 30 b2 5f   ...(ml...`0._
                000d - 8b 40 cc 1d 56 56 d4 b3-b7 b4 83 18 74   .@..VV......t
                001a - f5 0d 6f 55 57 f3                        ..oUW.
        signatureAlgorithm:
          algorithm: rsaEncryption (1.2.840.113549.1.1.1)
          parameter: NULL
        signature:
          0000 - 25 86 40 af f2 9b d2 79-76 5a 63 c8 dc 4b f0   %.@....yvZc..K.
          …
          00f0 - 6d 15 5a af 5a aa b5 dc-a7 9d d0 f6 94 20 0f   m.Z.Z........ .
          00ff - 7f                                             .
        unsignedAttrs:
          &lt;EMPTY&gt;</pre>

<p>Le type de contenu (<code>contentType</code>) de la capsule PKCS#7 est <code>pkcs7-signedData</code>, correspondant au type ASN.1 <code>SignedData</code> de PKCS#7, conçu comme son nom l'indique pour stocker des données signées. Le type <code>SignedData</code> contient la liste des algorithmes de hachage employés par les signataires (champ <code>digestAlgorithms</code>), les données signées (<code>encapContentInfo</code>, dont le champ <code>eContent</code> est absent, s'agissant d'une signature détachée et les données étant donc externes à la signature), les certificats des signataires (<code>certificates</code>), rarement les LCR associées aux certificats (<code>crls</code>, vide ici) et, sous le champ <code>signerInfos</code>, autant d'élements de type <code>SignerInfo</code> que de signataires (en réalité de signatures).</p>

<p>La signature portée par chaque champ <code>signerInfo</code> ne s'applique pas uniquement aux données à signer mais à un ensemble d'attributs (dits authentifiés dans la terminologie de PKCS#7, ou signés dans celle de CMS), parmi lesquels se trouve l'empreinte des données à signer. Chaque champ <code>signerInfo</code> référence le certificat du signataire par le DN de son AC émettrice et son numéro de série (<code>issuerAndSerialNumber</code>), ou (dans le champ <code>sid</code> spécifique à CMS) par son champ <code>subjectKeyIdentifier</code>. Il précise l'algorithme de hachage appliqué aux données à signer (<code>digestAlgorithm</code>), les attributs authentifiés (champ <code>authenticatedAttributes</code>) ou signés (champ <code>signedAttrs</code>), l'algorithme de signature ou de chiffrement asymétrique de l'empreinte (<code>signatureAlgorithm</code>), la signature numérique (<code>signature</code>), et d'éventuels attributs non authentifiés/non signés (champ <code>unauthenticatedAttributes</code> ou <code>unsignedAttrs</code>, absent ici).</p>

<p>À noter dans les attributs authentifiés/signés la présence de l'heure de signature (<code>signingTime</code>) : celle-ci est déclarative et correspond à l'heure de la machine de l'utilisateur. Pour obtenir une heure de signature opposable, le format de signature électronique avancée CAdES étend CMS en définissant un attribut <code>contentTimestamp</code>permettant de stocker un jeton d'horodatage portant sur les données à signer et lui-même signé par une autorité d'horodatage (supposée digne de confiance, au même titre qu'une autorité de certification pour la délivrance de certificats).</p>

<p class="note"><a name="openssl-smime-algo-hachage"/>Les commandes <code>openssl smime</code> et <code>openssl cms</code> produisent des signatures dont l'algorithme de signature, lorsqu'il met en œuvre des clés RSA, est identifié comme étant <code>rsaEncryption</code>, sans préciser l'algorithme de hachage : c'est le comportement par défaut prévu par la RFC 3370 (section 3.2). Si l'algorithme de hachage est précisé (par exemple <code>sha256WithRSAEncryption</code>, introduit dans CMS par la RFC 5754 avec les autres algorithmes à base des algorithmes de hachage de la famille SHA-2), alors OpenSSL est capable de vérifier la signature. (D'ailleurs, OpenSSL considère la signature valide même si l'algorithme de hachage référencé par l'algorithme de signature est incorrect, car il utilise l'algorithme de hachage identifé dans le champ <code>digestAlgorithm</code> de la structure <code>SignerInfo</code> associée.)</p>

<h2 id="verification-manuelle-signature">Vérification manuelle d'une signature</h2>

<p>Le mécanisme de vérification manuelle d'une signature PKCS#7/CMS est analogue à celui utilisé pour vérifier la signature d'un certificat (cf. section <a href="#verification-manuelle-sig-certificat" class="section"/>), la particularité résidant dans la détermination des données sur lesquelles portent la signature.</p>

<p>Les premiers niveaux de la structure d'une signature PKCS#7 sont les suivants :</p>

<pre>ContentInfo ::= SEQUENCE {
  contentType ContentType,
  content [0] EXPLICIT SEQUENCE {
    version Version,
    digestAlgorithms DigestAlgorithmIdentifiers,
    contentInfo ContentInfo,
    certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL,
    crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
    signerInfos SET OF SEQUENCE {
      version Version,
      issuerAndSerialNumber IssuerAndSerialNumber,
      digestAlgorithm DigestAlgorithmIdentifier,
      authenticatedAttributes [0] IMPLICIT SET OF Attribute OPTIONAL,
      digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
      encryptedDigest EncryptedDigest,
      unauthenticatedAttributes [1] IMPLICIT SET OF Attribute OPTIONAL
    }
  }
}</pre>

<p>Pour une signature CMS, la structure correspondante est la suivante :</p>

<pre>ContentInfo ::= SEQUENCE {
  contentType ContentType,
  content [0] EXPLICIT SEQUENCE {
    version CMSVersion,
    digestAlgorithms DigestAlgorithmIdentifiers,
    encapContentInfo EncapsulatedContentInfo,
    certificates [0] IMPLICIT CertificateSet OPTIONAL,
    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
    signerInfos SET OF SEQUENCE {
      version CMSVersion,
      sid SignerIdentifier,
      digestAlgorithm DigestAlgorithmIdentifier,
      signedAttrs [0] IMPLICIT SET OF Attribute OPTIONAL,
      signatureAlgorithm SignatureAlgorithmIdentifier,
      signature SignatureValue,
      unsignedAttrs [1] IMPLICIT SET OF Attribute OPTIONAL
    }
  }
}</pre>

<p>Les données faisant l'objet de la signature, laquelle est incluse dans le champ <code>signature</code> de chaque élément <code>SignerInfo</code> du champ <code>signerInfos</code>, dépendent de la présence ou non du champ <code>authenticatedAttributes</code> (PKCS#7) ou <code>signedAttrs</code> (CMS). Si ce champ est absent, alors les données signées sont les octets de contenu DER (hors octets d'identifiant de balise et de longueur) du champ <code>contentInfo</code> (PKCS#7) ou <code>encapContentInfo</code> (CMS). Si le champ <code>authenticatedAttributes</code>/<code>signedAttrs</code> est présent, alors les données à signer sont le codage DER du <code>SET OF Attribute</code> constituant ce champ, avec un balisage <code>EXPLICIT</code>, c'est-à-dire sans le balisage <code>[0] IMPLICIT</code>.</p>

<p class="note">Ces règles sont définies dans la section 9.3 de [PKCS#7] et dans la section 5.4 des RFC successives définissant CMS ([RFC 2630] , [RFC 3369] et [RFC 3852]).</p>

<p>Deux méthodes sont proposées pour générer le codage DER faisant l'objet de la signature :</p>
<ul>
<li>Soit remplacer le codage DER de la balise <code>[0]</code> par le codage DER de la balise <code>SET</code> dans le codage DER du champ <code>authenticatedAttributes</code>/<code>signedAttrs</code> : cette méthode est plus simple à réaliser mais plus compliquée à comprendre.</li>
<li>Soit reconstruire l'ensemble du champ en créant un fichier de configuration ASN.1 interprétable par la commande <code>openssl asn1parse -genconf</code> : cette méthode est plus longue, mais sera réutilisable pour ajouter de nouveaux attributs signés dans le cadre de la constitution de signatures avancées au format CAdES.</li>
</ul>

<p>Dans les deux cas, la première étape est d'extraire le champ <code>authenticatedAttributes</code>/<code>signedAttrs</code>.</p>

<h3 id="extraction-authenticatedattributes">Extraction du champ <code>authenticatedAttributes</code>/<code>signedAttrs</code></h3>

 <p>Afficher tout d'abord les six premiers niveaux de l'analyse ASN.1 de la signature détachée générée précédemment pour faciliter la mise en correspondance de celle-ci avec la structure ASN.1 :</p>

<pre><strong>$ openssl asn1parse -in sig-p7.der -inform DER -i | grep d=[0-5]</strong>
    0:d=0  hl=4 l=1578 cons: SEQUENCE
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-signedData
   15:d=1  hl=4 l=1563 cons:  cont [ 0 ]
   19:d=2  hl=4 l=1559 cons:   SEQUENCE
   23:d=3  hl=2 l=   1 prim:    INTEGER           :01
   26:d=3  hl=2 l=  15 cons:    SET
   28:d=4  hl=2 l=  13 cons:     SEQUENCE
   30:d=5  hl=2 l=   9 prim:      OBJECT            :sha256
   41:d=5  hl=2 l=   0 prim:      NULL
   43:d=3  hl=2 l=  11 cons:    SEQUENCE
   45:d=4  hl=2 l=   9 prim:     OBJECT            :pkcs7-data
   56:d=3  hl=4 l=1010 cons:    cont [ 0 ]
   60:d=4  hl=4 l=1006 cons:     SEQUENCE
   64:d=5  hl=4 l= 726 cons:      SEQUENCE
  794:d=5  hl=2 l=  13 cons:      SEQUENCE
  809:d=5  hl=4 l= 257 prim:      BIT STRING
 1070:d=3  hl=4 l= 508 cons:    SET
 1074:d=4  hl=4 l= 504 cons:     SEQUENCE
 1078:d=5  hl=2 l=   1 prim:      INTEGER           :01
 1081:d=5  hl=2 l= 102 cons:      SEQUENCE
 1185:d=5  hl=2 l=  13 cons:      SEQUENCE
 1200:d=5  hl=2 l= 105 cons:      cont [ 0 ]
 1307:d=5  hl=2 l=  13 cons:      SEQUENCE
 1322:d=5  hl=4 l= 256 prim:      OCTET STRING      [HEX DUMP]:258640AFF29BD2797
…
79DD0F694200F7F</pre>

<p>Le champ <code>authenticatedAttributes</code>/<code>signedAttrs</code> de l'unique <code>SignerInfo</code> se situe à l'octet 1200 : l'extraire (pour les besoins de la première méthode) et l'afficher (pour clarifier les opérations à réaliser dans le cadre de la deuxième méthode).</p>

<pre><strong>$ openssl asn1parse -in sig-p7.der -inform DER -i -strparse 1200 \
  -out sig-p7.signedAttrs.der</strong>
    0:d=0  hl=2 l= 105 cons: cont [ 0 ]
    2:d=1  hl=2 l=  24 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :contentType
   15:d=2  hl=2 l=  11 cons:   SET
   17:d=3  hl=2 l=   9 prim:    OBJECT            :pkcs7-data
   28:d=1  hl=2 l=  28 cons:  SEQUENCE
   30:d=2  hl=2 l=   9 prim:   OBJECT            :signingTime
   41:d=2  hl=2 l=  15 cons:   SET
   43:d=3  hl=2 l=  13 prim:    UTCTIME           :120427191932Z
   58:d=1  hl=2 l=  47 cons:  SEQUENCE
   60:d=2  hl=2 l=   9 prim:   OBJECT            :messageDigest
   71:d=2  hl=2 l=  34 cons:   SET
   73:d=3  hl=2 l=  32 prim:    OCTET STRING      [HEX DUMP]:89BD92286D6C8014C06
030B25F8B40CC1D5656D4B3B7B4831874F50D6F5557F3</pre>

<h3 id="remplacement-codage-der-0">Remplacement du codage DER de la balise <code>[0]</code></h3>

<p>Pour la première méthode, il s'agit de remplacer la balise <code>[CONTEXT 0]</code> (affichée sous la forme <code>cont [0]</code> ci-dessus, à l'octet 0) par un type <code>SET OF</code>. Pour un type construit (à l'exemple de <code>SET OF</code>), le codage DER de la balise <code>[CONTEXT 0]</code> est l'octet <code>0xa0</code> (ce que révèle aisément la commande <code>od -tx1</code> appliquée au fichier extrait). Le type <code>SET OF</code> est représenté en DER par l'octet <code>0x31</code>. Les règles DER n'ont pas d'impact sur cette valeur par rapport aux règles BER.</p>

<p class="note">Plus précisément, le type <code>SET OF</code> est représenté par une balise de classe <code>UNIVERSAL</code> numéro 17 ou <code>0x11</code> (règle 27.2 de [X.680]), et admet un codage construit (<i>constructed</i>, par opposition à <i>primitive</i>) d'après la règle 8.12.1 de [X.690]. En application des règles de codage BER définies dans la famille de règles 8.1.2 de [X.690], la représentation binaire de l'identifiant du type <code>SET OF</code> est <code>0b00110001</code>, soit <code>0x31</code>. Dans le détail, la valeur binaire se découpe en <code>00.1.10001</code>, le séparateur « <code>.</code> » étant employé pour séparer les bits représentant successivement : la classe <code>UNIVERSAL</code> (<code>00</code>), le codage construit (<code>1</code>), et le numéro de balise (<code>10001</code>, soit 17 en décimal). Les règles DER n'ont pas d'impact sur cette valeur par rapport aux règles BER.</p>

<p>Le remplacement du premier octet <code>0xa0</code> par l'octet <code>0x31</code> peut s'effectuer de plusieurs manières. La méthode la plus simple est d'utiliser un éditeur hexadécimal, à l'exemple de HexEdit<span class="fn">http://www-physics.mps.ohio-state.edu/~prewett/hexedit/index.html</span> sous Windows. Une deuxième méthode consiste, sous UNIX/Linux, à convertir le fichier binaire en hexadécimal à l'aide de l'outil <code>xxd</code>, à modifier l'octet, puis à convertir le fichier hexadécimal résultant en binaire. Une troisième option s'appuie sur OpenSSL, et consiste à convertir le fichier en Base64, à effectuer la modification, puis à convertir le fichier obtenu en binaire.</p>

<p>Coder le fichier <code>sig-p7.signedAttrs.der</code> en Base64.</p>

<pre><strong>$ openssl base64 -in sig-p7.signedAttrs.der \
  -out sig-p7.signedAttrs.b64</strong></pre>
  
<p>Le contenu du fichier obtenu est le suivant :</p>
<pre>oGkwGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTIw
NDI3MTkxOTMyWjAvBgkqhkiG9w0BCQQxIgQgib2SKG1sgBTAYDCyX4tAzB1WVtSz
t7SDGHT1DW9VV/M=</pre>

<p>Le premier octet est codé sur les deux premiers caractères, <code>oG</code>, soit les indices 40 et 6 de l'alphabet Base64, donc, en binaire sur 6 bits, <code>101000</code> et <code>000110</code>, soit, en regroupant les huit premiers bits représentant l'octet <code>0xa0</code>, <code>10100000 0110</code>. Le remplacement du premier octet par <code>0x31</code> sans modifier les quatre derniers bits donne <code>00110001 0110</code>, soit, en regroupant par blocs de 6 bits, <code>001100 010110</code>, soit 12 et 22 en décimal, soit encore <code>MW</code> dans l'alphabet Base64.</p>

<p>Copier le fichier <code>sig-p7.signedAttrs.b64</code> sous le nom <code>sig-p7.explicit-signedAttrs.b64</code>, y remplacer les deux premiers caractères <code>oG</code> par <code>MW</code>, puis reconstituer le fichier binaire.</p>
   
<pre><strong>$ openssl base64 -d -in sig-p7.explicit-signedAttrs.b64 \
  -out sig-p7.explicit-signedAttrs.der</strong></pre>

<p>Analyser le fichier résultant pour observer que la balise <code>[CONTEXT 0]</code> a bien été remplacée par un type <code>SET</code>.</p>

<pre><strong>$ openssl asn1parse -i -inform DER \
  -in sig-p7.explicit-signedAttrs.der</strong>
    0:d=0  hl=2 l= 105 cons: SET
    2:d=1  hl=2 l=  24 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :contentType
   15:d=2  hl=2 l=  11 cons:   SET
   17:d=3  hl=2 l=   9 prim:    OBJECT            :pkcs7-data
   28:d=1  hl=2 l=  28 cons:  SEQUENCE
   30:d=2  hl=2 l=   9 prim:   OBJECT            :signingTime
   41:d=2  hl=2 l=  15 cons:   SET
   43:d=3  hl=2 l=  13 prim:    UTCTIME           :120427191932Z
   58:d=1  hl=2 l=  47 cons:  SEQUENCE
   60:d=2  hl=2 l=   9 prim:   OBJECT            :messageDigest
   71:d=2  hl=2 l=  34 cons:   SET
   73:d=3  hl=2 l=  32 prim:    OCTET STRING      [HEX DUMP]:89BD92286D6C8014C06
030B25F8B40CC1D5656D4B3B7B4831874F50D6F5557F3</pre>

<h3 id="reconstruction-authenticatedattributes">Reconstruction du champ <code>authenticatedAttributes</code>/<code>signedAttrs</code></h3>

<p>La deuxième méthode permettant de générer le fichier <code>sig-p7.explicit-signedAttrs.der</code> consiste à créer un fichier de configuration définissant la structure ASN.1 souhaitée, interprétable par la commande <code>openssl asn1parse -genconf</code>, à l'image de ce qui a été fait pour constituer manuellement une clé publique (cf. section <a href="#construction-cle-publique" class="section"/>) ou un certificat (cf. section <a href="#construction-certificat" class="section"/>). Créer pour cela le fichier <code>sig-p7.explicit-signedAttrs.asn.cnf</code> suivant :</p>

<pre>asn1 = SET:signedAttrs

[signedAttrs]
attr_contentType = SEQUENCE:attr_contentType
attr_signingTime = SEQUENCE:attr_signingTime
attr_messageDigest = SEQUENCE:attr_messageDigest

[attr_contentType]
attrType = OID:contentType
attrValues = SET:attr_contentType_values

[attr_contentType_values]
attr_contentType_value = OID:pkcs7-data

[attr_signingTime]
attrType = OID:signingTime
attrValues = SET:attr_signingTime_values

[attr_signingTime_values]
attr_signingTime_value = UTCTIME:120427191932Z

[attr_messageDigest]
attrType = OID:messageDigest
attrValues = SET:attr_messageDigest_values

[attr_messageDigest_values]
attr_messageDigest_value = FORMAT:HEX,OCTETSTRING:\
89bd92286d6c8014c06030b25f8b40cc1d5656d4b3b7b4831874f50d6f5557f3</pre>

<p>Générer le codage DER de la structure ASN.1 correspondante :</p>

<pre><strong>$ openssl asn1parse -genconf sig-p7.explicit-signedAttrs.asn.cnf \
  -i -out sig-p7.explicit-signedAttrs.der</strong>
    0:d=0  hl=2 l= 105 cons: SET
    2:d=1  hl=2 l=  24 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :contentType
   15:d=2  hl=2 l=  11 cons:   SET
   17:d=3  hl=2 l=   9 prim:    OBJECT            :pkcs7-data
   28:d=1  hl=2 l=  28 cons:  SEQUENCE
   30:d=2  hl=2 l=   9 prim:   OBJECT            :signingTime
   41:d=2  hl=2 l=  15 cons:   SET
   43:d=3  hl=2 l=  13 prim:    UTCTIME           :120427191932Z
   58:d=1  hl=2 l=  47 cons:  SEQUENCE
   60:d=2  hl=2 l=   9 prim:   OBJECT            :messageDigest
   71:d=2  hl=2 l=  34 cons:   SET
   73:d=3  hl=2 l=  32 prim:    OCTET STRING      [HEX DUMP]:89BD92286D6C8014C06
030B25F8B40CC1D5656D4B3B7B4831874F50D6F5557F3</pre>

<p>Noter que le résultat est identique à celui obtenu à l'aide de la première méthode.</p>

<h3 id="verification-signature-pkcs7">Vérification de la signature</h3>

<p>Une fois le fichier <code>sig-p7.explicit-signedAttrs.der</code> généré à l'aide de l'une des méthodes ci-dessus, en calculer l'empreinte SHA-256 :</p>

<pre><strong>$ openssl sha256 sig-p7.explicit-signedAttrs.der</strong>
SHA256(sig-p7.explicit-signedAttrs.der)= 1e656e089e0e9c8196eb547af
f9fb3808fe837a35351b9b1a3a8dc4de8769479</pre>

<p>Extraire ensuite la signature numérique correspondant au champ <code>signature</code> (pour CMS, ou <code>encryptedDigest</code> pour PKCS#7) de <code>SignerInfo</code> : elle est située à l'octet 1326 (1322 + <code>hl</code>), pour une longueur de 256 octets.</p>

<pre><strong>$ openssl asn1parse -in sig-p7.der -inform DER -i -offset 1326 \
  -length 256 -out sig-p7.signature.bin</strong></pre>

<p class="note">L'erreur de décodage est normale (les données extraites sont le contenu d'une <code>OCTET STRING</code> « arbitraire » et non une structure DER valide) et peut être ignorée. Alternativement, la commande <code>dd</code> peut être utilisée pour réaliser l'extraction des octets avec un outil plus « naturel ».</p>

<p>Déchiffrer la signature avec la clé publique du signataire et analyser la structure <code>DigestInfo</code> résultante :</p>

<pre><strong>$ openssl pkeyutl -verifyrecover -in sig-p7.signature.bin \
  -inkey ee-key.pem -pubin | openssl asn1parse -i -inform DER</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:1E656E089E0E9C8196EB5
47AFF9FB3808FE837A35351B9B1A3A8DC4DE8769479</pre>

<p>L'empreinte portée par cette structure <code>DigestInfo</code> est égale à l'empreinte des données signées/authentifiées calculée précédemment, ce qui achève la vérification de la signature numérique.</p>

<p>Par ailleurs, l'empreinte portée par l'attribut <code>messageDigest</code> du <code>SignerInfo</code> est l'empreinte du fichier <code>data.txt</code> (cf. chapitre <a href="#hachage" class="chapter"/>), ce qui permet d'affirmer que la signature PKCS#7/CMS porte sur le fichier <code>data.txt</code>.</p>

<h2 id="construction-signature-pkcs7-cms">Construction d'une signature électronique PKCS#7/CMS</h2>

<p>La construction d'une signature électronique PKCS#7/CMS ne pose aucun problème en partant de la structure <code>ContentInfo</code> rappelée dans la section <a href="#verification-manuelle-signature" class="section"/> et en utilisant les méthodes de construction déjà vues pour les certificats.</p>

<h3 id="constitution-attributs-authentifies">Constitution des attributs authentifiés/signés</h3>

<p>La première étape est de créer la structure <code>SET OF Attributes</code> correspondant aux attributs signés/authentifiés : reprendre le fichier <code>sig-p7.explicit-signedAttrs.asn.cnf</code> défini dans la section <a href="#verification-manuelle-signature" class="section"/>, en l'adaptant au besoin (heure de signature dans la section <code>attr_signingTime_values</code>, et empreinte dans la section <code>attr_messageDigest_values</code>), puis générer le codage DER de la structure :</p>

<pre><strong>$ openssl asn1parse -genconf sig-p7.explicit-signedAttrs.asn.cnf \
  -i -out sig-p7.explicit-signedAttrs.der</strong></pre>
  
<h3 id="signature-attributs-authentifies">Signature des attributs authentifiés/signés</h3>

<p>La démarche pour générer la signature est semblable à celle utilisée pour signer la structure <code>TBSCertificate</code> d'un certificat (cf. section <a href="#signature-certificat" class="section"/>).</p>

<p>Calculer la valeur hexadécimale de l'empreinte SHA-256 du fichier DER généré :</p>

<pre><strong>$ openssl sha256 sig-p7.explicit-signedAttrs.der</strong>
SHA256(sig-p7.explicit-signedAttrs.der)= 1e656e089e0e9c8196eb547aff9fb3808fe837a
35351b9b1a3a8dc4de8769479</pre>

<p>Créer le fichier <code>sig-p7.DigestInfo.asn.cnf</code> suivant, représentant la structure <code>DigestInfo</code> associée à cette empreinte, en reportant la valeur hexadécimale de l'empreinte ci-dessus dans le champ <code>digest</code> de la section <code>digestInfo</code> :</p>

<pre>asn1 = SEQUENCE:digestInfo

[digestInfo]
digestAlgorithm = SEQUENCE:digestAlgorithm
digest = FORMAT:HEX,OCTETSTRING:\
1e656e089e0e9c8196eb547aff9fb3808fe837a35351b9b1a3a8dc4de8769479

[digestAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Générer le codage DER de la structure <code>DigestInfo</code> :</p>

<pre><strong>$ openssl asn1parse -genconf sig-p7.DigestInfo.asn.cnf -i \
  -out sig-p7.DigestInfo.der</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:1E656E089E0E9C8196EB5
47AFF9FB3808FE837A35351B9B1A3A8DC4DE8769479</pre>

<p>Signer ce codage DER à l'aide de la clé publique du signataire, et produire la représentation hexadécimale de cette signature :</p>

<pre><strong>$ openssl pkeyutl -sign -in sig-p7.DigestInfo.der -inkey ee-key.pem \
  | od -tx1 -An -w | tr -d " " | sed 's/$/\\/'</strong>
258640aff29bd279765a63c8dc4bf0b0b2a74acd14dae89ba5703a129c0518bb\
b7bc88c91998c820974f9ad3f409ffd55ec55cabb48eafbc5cac57f672a8b05a\
906918ed3575beca60fc40bdf4e04ae340647e86f31a732bffa239912515f670\
4d5cd3215455da2ac196efab2e94a79b88c7409bc53279c73a5801bed8d4e585\
0d705384953a1271d29a225389eb705167bb25f8028ea9f2ffe2b86b448f01bd\
9e52484d3a6d8e78e6f902d0592041ccdb430acdcb5126d590db7e5e54e34282\
3a1e134c1c8f33b91be8ffefdf3dec82903deb51d4378608c8d5c756d19ae301\
f9b90e502d2ae6917f6e4d2a1b3745e26d155aaf5aaab5dca79dd0f694200f7f\</pre>

<h3 id="construction-signerinfo">Construction de la structure <code>SignerInfo</code></h3>

<p>Dans un fichier <code>sig-p7.asn.cnf</code>, créer la section suivante correspondant à la structure <code>SignerInfo</code> (la valeur de l'<code>OCTET STRING</code> du champ <code>signature</code> est la valeur hexadécimale de la signature obtenue précédemment) :</p>

<pre>[signerInfo]
version = INTEGER:1
sid = SEQUENCE:sid
digestAlgorithm  = SEQUENCE:signerInfo_digestAlgorithm
signedAttrs = IMPLICIT:0,SET:signedAttrs
signatureAlgorithm = SEQUENCE:signatureAlgorithm 
signature = FORMAT:HEX,OCTETSTRING:\
258640aff29bd279765a63c8dc4bf0b0b2a74acd14dae89ba5703a129c0518bb\
b7bc88c91998c820974f9ad3f409ffd55ec55cabb48eafbc5cac57f672a8b05a\
906918ed3575beca60fc40bdf4e04ae340647e86f31a732bffa239912515f670\
4d5cd3215455da2ac196efab2e94a79b88c7409bc53279c73a5801bed8d4e585\
0d705384953a1271d29a225389eb705167bb25f8028ea9f2ffe2b86b448f01bd\
9e52484d3a6d8e78e6f902d0592041ccdb430acdcb5126d590db7e5e54e34282\
3a1e134c1c8f33b91be8ffefdf3dec82903deb51d4378608c8d5c756d19ae301\
f9b90e502d2ae6917f6e4d2a1b3745e26d155aaf5aaab5dca79dd0f694200f7f</pre>

<p>Le champ <code>sid</code> identifie le certificat du signataire par son numéro de série et par le DN de l'émetteur. Les champs et sections correspondantes du fichier <code>ee-Certificate.asn.cnf</code> peuvent être repris :</p>

<pre>[sid]
issuer = SEQUENCE:issuer
serialNumber = INTEGER:0xdcd21ee5a2b7dfc7

[issuer]
issuer_C_RDN = SET:issuer_C_RDN
issuer_O_RDN = SET:issuer_O_RDN
issuer_OU1_RDN = SET:issuer_OU1_RDN
issuer_OU2_RDN = SET:issuer_OU2_RDN

[issuer_C_RDN]
issuer_C_ATV = SEQUENCE:issuer_C_ATV

[issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[issuer_O_RDN]
issuer_O_ATV = SEQUENCE:issuer_O_ATV

[issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[issuer_OU1_RDN]
issuer_OU1_ATV = SEQUENCE:issuer_OU1_ATV

[issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[issuer_OU2_RDN]
issuer_OU2_ATV = SEQUENCE:issuer_OU2_ATV

[issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA</pre>

<p>Ajouter la section suivante pour le champ <code>digestAlgorithm</code> :</p>

<pre>[signerInfo_digestAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Inclure ensuite toutes les sections du fichier <code>sig-p7.explicit-signedAttrs.asn.cnf</code> (en prenant soin d'omettre la ligne initiale <code>asn1 = SET:signedAttrs</code>).</p>

<p>Terminer avec la section suivante :</p>
<pre>[signatureAlgorithm]
algorithm = OID:rsaEncryption
parameters = NULL</pre>

<p class="note">Il serait possible d'utiliser <code>algorithm = OID:sha256WithRSAEncryption</code> (cf. note page <a href="#openssl-smime-algo-hachage" class="page"/>) sans corrompre la signature et en préservant sa validité.</p>

<h3 id="finalisation-pkcs7-cms">Finalisation de la structure PKCS#7/CMS</h3>

<p>Ajouter au début du fichier <code>sig-p7.asn.cnf</code> les lignes suivantes :</p>

<pre>asn1 = SEQUENCE:contentInfo

[contentInfo]
contentType = OID:pkcs7-signedData
content = EXPLICIT:0,SEQUENCE:content

[content]
version = INTEGER:1
digestAlgorithms = SET:content_digestAlgorithms
encapContentInfo = SEQUENCE:encapContentInfo
certificates = IMPLICIT:0,SEQUENCE:certificates
signerInfos = SET:signerInfos

[content_digestAlgorithms]
digestAlgorithm = SEQUENCE:content_digestAlgorithm

[content_digestAlgorithm]
algorithm = OID:sha256
parameters = NULL

[encapContentInfo]
eContentType = OID:pkcs7-data

[certificates]
certificate = SEQUENCE:ee_certificate

[signerInfos]
signerInfo = SEQUENCE:signerInfo</pre>

<p>Faire suivre ces lignes de la copie de toutes les sections du fichier <code>ee-Certificate.asn.cnf</code> (en excluant la ligne initiale <code>asn1 = SEQUENCE:ee_certificate</code>), correspondant au certificat du signataire, qui est référencé dans la section <code>certificates</code> ci-dessus.</p>

<p>Générer le codage DER de la signature PKCS#7/CMS :</p>

<pre><strong>$ openssl asn1parse -genconf sig-p7.asn.cnf -i -out sig-p7.der</strong></pre>

<p>Vérifier la signature électronique ainsi obtenue :</p>

<pre><strong>$ openssl smime -verify -inform DER -in sig-p7.der -content data.txt \
  -CAfile ca-crt.pem</strong>
texte en clairVerification successful</pre>

<h1 id="xml-signature">Signature électronique — XML Signature</h1>

<p>La norme XML Signature (souvent appelée « XML DSig », avec « DSig » pour <i>digital signature</i> ou signature numérique) du W3C<span class="fn">http://www.w3.org/TR/xmldsig-core/</span> permet de signer des données (XML ou non, mais seul le cas XML est abordé ici, le cas non XML étant rare), et est à la base du format de signature électronique avancée XAdES.</p>

<p>Une signature XML Signature portant sur des données XML se matérialise par un élément XML <code>ds:Signature</code> (où le préfixe <code>ds:</code> représente l’espace de nommage <code>http://www.w3.org/2000/09/xmldsig#</code>), qui peut être inclus dans les données à signer (signature enveloppée), ou contenir les données à signéer (signature enveloppante), ou être séparé (nœud disjoint d'un même document XML ou document XML séparé) des données à signer (signature détachée). Le cas le plus courant est celui de la signature enveloppée.</p>

<p>L'élément <code>ds:Signature</code> contient les informations sur la signature (algorithmes, identification et empreinte des données signées) dans un élément <code>ds:SignedInfo</code>, la valeur de la signature numérique (élement <code>ds:SignatureValue</code>) de cet élément <code>ds:SignedInfo</code>, souvent les informations d'identification de la clé de signature (élément <code>ds:KeyInfo</code> introduit dans le chapitre <a href="#KeyInfo" class="chapter"/>, page <a href="#KeyInfo" class="page"/>), et dans certains cas un élément <code>ds:Object</code> (contenant par exemple les données à signer dans le cas d'une signature enveloppante, ou encore les propriétés avancées de la signature dans le cas d'une la signature XAdES).</p>

<p>L'élément <code>ds:SignedInfo</code> contient les éléments suivants :</p>

<ul>
<li><code>ds:CanonicalizationMethod</code>, qui définit l'algorithme de canonicalisation (abrégé en « c14n », c'est-à-dire la première lettre, 14 pour le nombre de lettres omises, et la dernière lettre). Le rôle de la canonicalisation est crucial dans le contexte de la signature électronique pour le maintien de l'intégrité des données. En effet, contrairement au monde binaire où l'information est représentée sans ambiguïté par une suite d'octets, dans le monde XML une information admet plusieurs représentations. Par exemple, les éléments <code>&lt;tag attr1 = "val1" attr2 = "val2" /&gt;</code> et <code>&lt;tag attr2="val2" attr1="val1"/&gt;</code> (noter les espaces et l'ordre des attributs) représentent la même information, même si les suites d'octets de leur représentation sont différentes. La canonicalisation d'un document XML consiste à appliquer un ensemble de règles permettant d'obtenir un document XML canonique, représentation unique de l'information contenue dans un document XML. Dans le contexte de la signature électronique, des informations représentées différemment admettent la même empreinte après canonicalisation. Le W3C définit une méthode de canonicalisation générale<span class="fn">http://www.w3.org/TR/xml-c14n</span>, enrichie par des règles complémentaires sous le nom de canonicalisation exclusive<span class="fn">http://www.w3.org/TR/xml-exc-c14n/</span> visant à préserver les déclarations des espaces de nommage lors d'extractions de sous-arbres à partir d'un document XML, ce qui est particulièrement utile dans le cadre de la signature électronique de portions d'un document XML employant plusieurs espaces de nommage.</li>
<li><code>ds:SignatureMethod</code>, qui spécifie l'algorithme de signature.</li>
<li>Un ou plusieurs nœuds <code>ds:Reference</code>, contenant l'algorithme de hachage et l'empreinte d'un ensemble de données, lesquelles peuvent être référencées dans le nœud.</li>
</ul>

<h2 id="signature-fichier-xml-signature">Signature d'un fichier</h2>

<p>À l'image de XML Encryption (cf. chapitre <a href="#confidentialite-xml-encryption" class="chapter"/>), l'outil xmlsec ajoute des signatures électroniques à un document XML en s'appuyant sur des squelettes d'éléments <code>ds:Signature</code>. À la différence de XML Encryption, ces modèles d'éléments <code>ds:Signature</code> doivent être contenus dans le document incluant la signature.</p>

<p>Voici un exemple de modèle d'élément <code>ds:Signature</code> :</p>

<pre><![CDATA[<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
  <ds:SignedInfo>
    <ds:CanonicalizationMethod
      Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
    <ds:SignatureMethod
      Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
    <ds:Reference URI="">
      <ds:Transforms>
        <ds:Transform
          Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
        <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
      </ds:Transforms>
      <ds:DigestMethod
        Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
      <ds:DigestValue/>
    </ds:Reference>
  </ds:SignedInfo>
  <ds:SignatureValue/>
  <ds:KeyInfo>
    <ds:X509Data>
      <ds:X509Certificate/>
    </ds:X509Data>
  </ds:KeyInfo>
</ds:Signature>]]></pre>

<p>Les nœuds fils de <code>ds:Signature</code> contiennent les informations présentées ci-dessus :</p>

<p>L'élément <code>ds:SignedInfo</code> de <code>ds:Signature</code> définit les caractéristiques de la signature à appliquer :</p>
<ul>
<li>L'algorithme de canonicalisation exclusive, référencé dans l'attribut <code>Algorithm</code> de <code>ds:CanonicalizationMethod</code>, utilisé pour canonicaliser l'élément <code>ds:SignedInfo</code> faisant l'objet de la signature numérique inscrite dans <code>ds:SignatureValue</code>.</li>
<li>L'algorithme de signature SHA-256 et RSA (<code>ds:SignatureMethod/@Algorithm</code>). À noter que la famille des algorithmes SHA-2 a été introduite dans la version de travail de la version 1.1 de la norme XML Signature<span class="fn">http://www.w3.org/TR/2009/WD-xmldsig-core1-20090226/</span>.</li>
<li>Les données faisant l'objet de la signature électronique, c'est-à-dire ici l'ensemble du document XML parent de l'élément <code>ds:Signature</code> (identifié par l'attribut vide <code>URI</code> de l'élément <code>ds:Reference</code>), auquel est appliqué la transformation de signature enveloppée, qui supprime ledit élément <code>ds:Signature</code> (voir l'encadré page <a href="#enveloped-signature" class="page"/> pour une explication plus précise), puis une canonicalisation exclusive. L'élément <code>ds:DigestValue</code> est vide, et sera complété lors de la signature par l'empreinte des données, calculée en utilisant l'algorithme SHA-256, identifié par l'élément <code>ds:DigestMethod</code>.</li>
</ul>

<p>L'élément <code>ds:SignatureValue</code> est laissé vide, et sera complété par la signature numérique lors de la signature, tout comme la référence à la clé de signature <code>ds:KeyInfo</code>, dont le sous-élément <code>ds:X509Certificate</code> sera complété avec le codage en Base64 de la représentation DER du certificat du signataire.</p>

<p>Générer le fichier <code>data.dsig-tmpl.xml</code> suivant :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data>Texte en clair</data>
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
    <ds:SignedInfo>
      <ds:CanonicalizationMethod
        Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
      <ds:SignatureMethod
        Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
      <ds:Reference URI="">
        <ds:Transforms>
          <ds:Transform
            Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        </ds:Transforms>
        <ds:DigestMethod
          Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue/>
      </ds:Reference>
    </ds:SignedInfo>
    <ds:SignatureValue/>
    <ds:KeyInfo>
      <ds:X509Data>
        <ds:X509Certificate/>
      </ds:X509Data>
    </ds:KeyInfo>
  </ds:Signature>
</root>]]></pre>

<p>Signer le fichier à l'aide de la clé privée et du certificat d'authentification et signature créé dans la section <a href="#generation-certificat-ee-authsig" class="section"/>, en prenant garde à la syntaxe particulière de l'option <code>--privkey-pem</code>, qui prend pour paramètre obligatoire le nom du fichier de la clé privée (au format PEM) suivi, pour pouvoir renseigner l'élément <code>ds:X509Data</code>, du nom du fichier du certificat associé, les noms de fichier étant séparés par une virgule.</p>

<pre><strong>$ xmlsec --sign --privkey-pem ee-key.pem,ee-crt-authsig.pem data.dsig-tmpl.xml</strong>
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data>Texte en clair</data>
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
    <ds:SignedInfo>
      <ds:CanonicalizationMethod 
        Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
      <ds:SignatureMethod 
        Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
      <ds:Reference URI="">
        <ds:Transforms>
          <ds:Transform 
            Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        </ds:Transforms>
        <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue>
          o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=
        </ds:DigestValue>
      </ds:Reference>
    </ds:SignedInfo>
    <ds:SignatureValue>
RtMVv8LrmyjHSU3ZUlTb+BPnpirsAlfBEWwT93TXDdfEM2JDMbDSEE+G0jNczNhU
7OottfaSMFVrMELbUjhx/qAen1vtb+XyMe1aZClcAyeNAhqhWM9KqTJKmeFxhxwe
rHya6XcSZaMLKNE7er0DbKL05GArtoQposC680MT4yO3uwc+hAwpnqAxci45NlB1
NS86K35E5F+xxGTbWFqodan8m6T01t3c4vuoUCBvGZK7eSvtC2ufirkmxhtmk8hw
pjFFRJchlqyY2tISseWYfdUEA8pZi5w3aSXtCC1No59Ae5L/zfXPxCVzrAvp3rAn
1mvQHwQ3Q6X9HNqvzgMZdQ==</ds:SignatureValue>
    <ds:KeyInfo>
      <ds:X509Data>

      <ds:X509Certificate>
MIID7jCCAtagAwIBAgIJANzSHuWit9/HMA0GCSqGSIb3DQEBCwUAMFkxCzAJBgNV
…
bos=</ds:X509Certificate>
</ds:X509Data>
    </ds:KeyInfo>
  </ds:Signature>
</root>]]></pre>

<p class="note">Les « espaces blancs » (<i>whitespaces</i>) — de type espace, tabulation et retour chariot — entre les balises faisant partie des données à signer, le résultat obtenu peut différer.</p>

<p>Utiliser la même ligne de commande avec l'option <code>--output data.dsig.xml</code> en prévision de la vérification de la signature :</p>
<pre><strong>$ xmlsec --sign --privkey-pem ee-key.pem,ee-crt-authsig.pem \
  --output data.dsig.xml data.dsig-tmpl.xml</strong></pre>

<div class="longnote">
<div class="notetitle">Automatisation de l'ajout d'un modèle de <code>ds:Signature</code> à un document XML existant</div>
<p>Pour pouvoir maintenir séparément un document XML et le fichier modèle de l'élément <code>ds:Signature</code>, le fichier de transformation XSLT suivant, nommé <code>dsig-addafternode.xslt</code> est proposé.</p>
<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes"/>
  
  <!-- insert-doc parameter:
     specifies the filename of the document to be inserted after the node -->
  <xsl:param name="insert-doc"/>
  
  <xsl:template match="/root/data"> <!-- change XPath value as required -->
    <xsl:copy-of select="."/> <!-- copies matching XPath node -->
    <xsl:copy-of select="document($insert-doc)"/> <!-- inserts file -->
  </xsl:template>

  <!-- identity transform template:
    copies nodes recursively unless another template applies -->
  <xsl:template match="node() | @*">
    <xsl:copy>
      <xsl:apply-templates select="node() | @*"/>
    </xsl:copy>
  </xsl:template>
</xsl:stylesheet>]]></pre>
<p>Cette transformation ajoute le contenu du fichier passé en tant que paramètre <code>insert-doc</code> après le nœud dont le chemin XPath est spécifié dans l'attribut <code>match</code> du premier élément <code>xsl:template</code> (soit <code>/root/data</code> ci-dessus, à adapter en fonction du besoin).</p>
<p>À titre d'exemple, copier le contenu du modèle d'élément <code>ds:Signature</code> dans un fichier <code>dsig-tmpl.xml</code>, et exécuter la commande suivante pour obtenir un le fichier <code>data.dsig-tmpl.xml</code> :</p>
<pre><strong>$ xsltproc --stringparam insert-doc dsig-tmpl.xml dsig-addafternode.xslt \
  data.xml</strong></pre>
</div>

<h2 id="verification-xml-signature">Vérification d'une signature</h2>

<p>Vérifier la signature électronique du fichier signé obtenu précédemment.</p>

<pre><strong>$ xmlsec --verify --trusted-pem ca-crt.pem data.dsig.xml</strong>
OK
SignedInfo References (ok/all): 1/1
Manifests References (ok/all): 0/0</pre>

<p>Le certificat du signataire étant inclus dans l'élément <code>ds:KeyInfo</code>, il est utilisé pour valider la signature : seul le certificat de l'AC émettrice est à fournir en plus.</p>

<p>Si le certificat n'est pas inclus dans la l'élément <code>ds:KeyInfo</code>, par exemple si la clé est référencée par le champ <code>SubjectKeyIdentifier</code> du certificat dans un élément <code>ds:X509SKI</code> sous <code>ds:X509Data</code>, alors il doit être précisé en ligne de commande avec l'option <code>--pubkey-cert-pem</code>.</p>

<h2 id="verification-manuelle-xml-signature">Vérification manuelle d'une signature</h2>

<p>La vérification manuelle d'une signature XML Signature implique de réaliser les opérations suivantes pour un élément <code>ds:Signature</code> donné :</p>
<ul>
<li>Extraire l'élément <code>ds:SignedInfo</code>, et le canonicaliser en utilisant l'algorithme défini dans l'élément <code>ds:CanonicalizationMethod</code>.</li>
<li>Pour chacun des éléments <code>ds:Reference</code> sous <code>ds:SignedInfo</code>, obtenir les données référencées (généralement via l'attribut <code>URI</code> si la signature est contenue dans le même document XML que les données sur lesquelles elle porte), et vérifier que le codage Base64 de leur empreinte — calculée en utilisant l'algorithme de hachage défini dans <code>ds:DigestMethod</code> — est égal au contenu de l'élément <code>ds:DigestValue</code>.</li>
<li>Vérifier à l'aide de la clé référencée dans l'élément <code>ds:KeyInfo</code> que la signature numérique de l'élément <code>ds:SignedInfo</code> par l'algorithme défini dans l'élément <code>ds:SignatureMethod</code> correspond à la valeur renseignée dans l'élément <code>ds:SignatureValue</code>.</li>
</ul>

<p>La suite de cette section s'appuie sur le fichier signé <code>data.dsig.xml</code> généré précédemment.</p>

<h3 id="extraction-c14n-signedinfo">Extraction et canonicalisation de l'élément <code>ds:SignedInfo</code></h3>

<p>Extraire l'élément <code>ds:SignedInfo</code> en utilisant l'outil XMLStarlet présenté dans la section <a href="#dechiffrement-manuel-fichier-xmlsec" class="section"/>.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -c /root/ds:Signature/ds:SignedInfo data.dsig.xml > data.dsig.signedinfo.xml</strong></pre>

<p>Effectuer une canonicalisation exclusive de cet élément :</p>

<pre><strong>$ xmllint --exc-c14n data.dsig.signedinfo.xml > data.dsig.signedinfo.c14n.xml</strong></pre>

<p>À ce stade, une petite précision s'impose sous Windows. La canonicalisation normalise les retours chariot, en supprimant les caractères <i>carriage return</i> (ou CR, codé par l'octet <code>0x0d</code>, et représenté par le caractère spécial <code>\r</code>)… mais certaines applications sous Windows (dont les outils <code>xmllint</code> et <code>xml</code>) les restituent lorsqu'elles rencontrent un caractère <i>line feed</i> (ou LF, codé par l'octet <code>0x0a</code>, et représenté par le caractère spécial <code>\n</code>). Dans ce cas, il convient, après la canonicalisation exclusive, de supprimer les caractères CR ou <code>\r</code>, ce qui peut s'effectuer en chaînant la commande <code>xmllint</code> ci-dessus avec une commande <code>tr</code>, comme ceci :</p>

<pre><strong>> xmllint --exc-c14n data.dsig.signedinfo.xml | tr -d "\r" \
  > data.dsig.signedinfo.c14n.xml</strong></pre>

<p class="note">Il est possible de vérifier avec la commande <code>od -tx1</code> qu'aucun octet <code>0x0d</code> ne subsiste avant les octets <code>0x0a</code>.</p>

<h3 id="extraction-transformation-references">Extraction et transformation des références</h3>

<p>L'attribut <code>URI</code> de l'unique élément <code>ds:Reference</code> du fichier exemple contenant une chaîne vide, la référence à considérer est le fichier dans son intégralité.</p>

<p>La première transformation à appliquer, spécifier par le premier élément <code>ds:Transform</code>, est la transformation de signature enveloppée, qui supprime l'élément <code>ds:Signature</code> contenant l'élément <code>ds:Transform</code> considéré.</p>

<div class="longnote">
<div class="notetitle"><a name="enveloped-signature"/>Comprendre la transformation de signature enveloppée</div>
<p>La transformation de signature enveloppée réalise une opération simple à comprendre, mais dont le principe mérite quelques explications.</p>
<p>L'extrait suivant du fichier d'exemple est repris pour illustrer :</p>
<pre><![CDATA[<root>
  <data>Texte en clair</data>
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
    <ds:SignedInfo>
      …
      <ds:Reference URI="">
        <ds:Transforms>
          <ds:Transform
            Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          …
        </ds:Transforms>
        …
  </ds:Signature>
</root>]]></pre>
<p>Il s'agit d'une signature enveloppée, portant sur l'ensemble du fichier XML. Les données faisant l'objet de la signature sont l'ensemble des nœuds du fichier, à l'exception du nœud <code>ds:Signature</code>, car la signature ne peut pas porter sur elle-même (cela créerait une dépendance circulaire impossible à traiter), d'où la transformation de signature enveloppée référencée dans l'élément <code>ds:Transform</code> : <code>Algorithm="…#enveloped-signature"</code>, qui supprime d'un document XML l'élément <code>ds:Signature</code> incriminé. Après application de la transformation, le fichier obtenu est donc :</p>
<pre><![CDATA[<root>
  <data>Texte en clair</data>
  
</root>]]></pre>
<p>Intuitivement, la notion d'« élément <code>ds:Signature</code> incriminé » à supprimer est claire, mais plus formellement, la norme XML Signature définit le résultat de la transformation de signature enveloppée comme étant l'ensemble des nœuds dont un ancêtre ou soi (au sens de l'axe <code>ancestor-or-self::</code> de XPath) est le nœud <code>ds:Signature</code> parent de l'élément <code>ds:Transform</code> concerné, c'est-à-dire que la transformation doit avoir un résultat identique à la transformation suivante :</p>
<pre><![CDATA[<ds:Transform Algorithm="http://www.w3.org/TR/1999/REC-xpath-19991116">
  <ds:XPath>
    count(ancestor-or-self::ds:Signature |
    here()/ancestor::ds:Signature[1]) >
    count(ancestor-or-self::ds:Signature)</XPath>]]></pre>
<p>Dit autrement, tous les nœuds pour lesquels l'expression XPath ci-dessus est évaluée à vrai sont conservés.</p>
<p>Pour un nœud donné, l'expression <code>count(ancestor-or-self::ds:Signature)</code> est égale au nombre d'éléments <code>ds:Signature</code> de niveau supérieur ou égal au nœud considéré. L'expression <code>count(ancestor-or-self::ds:Signature | here()/ancestor::ds:Signature[1])</code> dénombre quant à elle les éléments <code>ds:Signature</code> qui sont de niveau supérieur ou égal au nœud considéré, ainsi que le premier élément <code>ds:Signature</code> rencontré en remontant l'arborescence XML en partant du nœud <code>ds:Transform</code> considéré (en d'autres mots, le <code>ds:Signature</code> contenant le <code>ds:Transform</code>), en excluant les doublons.</p>
<p>Pour illustrer numériquement les valeurs obtenues, soit l'arborescence XML schématisée ci-dessous :</p>
<pre>doc (1)
  …
  ds:Signature (2)
  …
  ds:Signature (3)
    …
    ds:Transform (3a)
    …</pre>
<p>L'élément <code>ds:Transform</code> en (3a) référençant la transformation signature enveloppée définie par l'expression XPath précédente, soit à déterminer le document XML résultant de l'application de la transformation.</p>
<p>Au nœud (1), l'expression XPath se simplifie en <code>1 &gt; 0</code> : il n'existe aucun élément <code>ds:Signature</code> de niveau supérieur à cet emplacement (d'où le terme de droite 0), et l'élément <code>ds:Signature</code> du nœud (3) compte pour 1 dans le terme de gauche. Donc l'expression est vraie et le nœud (1) est inclus dans le document résultant. Cela s'applique également à tous les nœuds en dehors des deux éléments <code>ds:Signature</code>.</p>
<p>Au nœud (2), il existe un élément <code>ds:Signature</code> de niveau supérieur ou égal (le nœud lui-même), donc le terme de droite de l'expression XPath vaut 1. Le terme de gauche dénombre les éléments <code>ds:Signature</code> de niveau supérieur ou égal (le nœud (2) uniquement) ainsi que l'élément <code>ds:Signature</code> du nœud (3), soit deux nœuds en tout. L'expression résultante, <code>2 &gt; 1</code> est vraie, et le nœud (2) est inclus, tout comme ses sous-éléments pour lesquels le même raisonnement s'applique.</p>
<p>Au nœud (3), il existe un élément <code>ds:Signature</code> de niveau supérieur ou égal, qui est le nœud (3) lui-même, donc le terme de droite de l'expression XPath vaut 1. Le terme de gauche dénombre les éléments <code>ds:Signature</code> de niveau supérieur ou égal (le nœud (3) uniquement) ainsi que l'élément <code>ds:Signature</code> du nœud (3), soit un seul nœud distinct, qui est le nœud (3). L'expression devient <code>1 &gt; 1</code>, donc une valeur booléenne fausse, et le nœud (3) n'est pas inclus dans le résultat de la transformation, tout comme ses sous-éléments.</p>
<p>À l'issue de la transformation, le document obtenu a l'arborescence suivante :</p>
<pre>doc (1)
  …
  ds:Signature (2)
  …</pre>
<p>Cela correspond au résultat attendu : l'élément <code>ds:Signature</code> contenant la transformation de signature enveloppée a été supprimée en préparation de la production de la signature à l'emplacement du nœud (3).</p>
<p>En pratique, les API de signature utilisent des algorithmes optimisés pour effectuer la transformation de signature enveloppée via l'algorithme <code>http://www.w3.org/2000/09/xmldsig#enveloped-signature</code> au lieu d'appliquer la transformation XPath qui, bien que fonctionnellement équivalente, est peu performante.</p>
</div>
<p>Le fichier XSLT suivant (nommé <code>enveloped-signature.xslt</code>) effectue la transformation de signature enveloppée en utilisant l'expression XPath définie dans la section 6.6.4 de la norme XML Signature<span class="fn">http://www.w3.org/TR/xmldsig-core/#sec-EnvelopedSignature</span> :</p>
<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
  <xsl:output method="xml" version="1.0" encoding="UTF-8" indent="no"/>
  
  <xsl:template match="node() | @*">
    <xsl:if test="count(ancestor-or-self::ds:Signature 
      | /root/ds:Signature/ds:SignedInfo/ds:Reference/ds:Transforms
      /ds:Transform/ancestor::ds:Signature[1]) 
      > count(ancestor-or-self::ds:Signature)">
      <xsl:copy>
        <xsl:apply-templates select="node() | @*"/>
      </xsl:copy>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>]]></pre>
<p class="note">La fonction <code>here()</code> n'étant pas une fonction XPath standard (elle est définie dans la section 6.6.3 de la norme XML Signature<span class="fn">http://www.w3.org/TR/xmldsig-core/#sec-XPath</span>), elle doit donc être remplacée par le chemin XPath explicite de l'élément <code>ds:Transform</code> de référence, soit, dans l'exemple précédent, <code>/root/ds:Signature/ds:SignedInfo/ds:Reference/ds:Transforms/ds:Transform</code>.</p>
<p>Pour appliquer la transformation XSLT au fichier d'entrée <code>data.dsig.xml</code>, utiliser la ligne de commande suivante :</p>
<pre><strong>$ xsltproc enveloped-signature.xslt data.dsig.xml \
  > data.dsig.transform-enveloped-signature.xml</strong></pre>

<p>Le document XML résultant doit ensuite subir une canonicalisation exclusive, tel que prévu par le deuxième élément <code>ds:Transform</code> de <code>ds:SignedInfo</code>.</p>

<pre><strong>$ xmllint --exc-c14n data.dsig.transform-enveloped-signature.xml \
  > data.dsig.transforms.xml</strong></pre>

<p class="note">Sous Windows, penser à chaîner cette commande dans la commande <code>tr -d "\r"</code> pour supprimer les caractères CR superflus.</p>

<h3 id="verification-digestvalue">Vérification de l'élément <code>ds:DigestValue</code></h3>

<p>Calculer l'empreinte du document XML <code>data.dsig.transforms.xml</code>, obtenu — pour rappel — après application aux données référencées par l'élément <code>ds:Reference</code> des transformations indiquées dans l'élément <code>ds:Transforms</code>, en utilisant l'algorithme SHA-256 spécifié dans l'élément <code>ds:DigestMethod</code>, puis coder cette empreinte en Base64.</p>

<pre><strong>$ openssl sha256 -binary data.dsig.transforms.xml | openssl base64</strong>
o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=</pre>

<p>La valeur obtenue est identique à la valeur du nœud <code>ds:DigestValue</code> de l'élément <code>ds:Reference</code> considéré :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  …
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
    <ds:SignedInfo>
      …
      <ds:Reference URI="">
        …
        <ds:DigestValue>
          o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=
        </ds:DigestValue>
      </ds:Reference>
    </ds:SignedInfo>
    …
  </ds:Signature>
</root>]]></pre>

<p>La référence est donc valide.</p>

<h3 id="verification-signature-numerique-xml-signature">Vérification de la signature numérique</h3>

<p>Les références étant validées, il reste à vérifier la signature à proprement parler.</p>

<p>La valeur du nœud <code>ds:SignatureValue</code> est le codage Base64 de la signature numérique de l'élément <code>ds:SignedInfo</code> canonicalisé par l'algorithme indiqué dans l'élément <code>ds:CanonicalizationMethod</code>. Cet élément a été extrait précédemment dans le fichier <code>data.dsig.signedinfo.c14n.xml</code>, et est reproduit ci-dessous (sans remise en forme des lignes trop longues, afin de préserver l'intégrité du document canonicalisé).</p>

<pre><![CDATA[<ds:SignedInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
      <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c1
4n#"></ds:CanonicalizationMethod>
      <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-
sha256"></ds:SignatureMethod>
      <ds:Reference URI="">
        <ds:Transforms>
          <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-s
ignature"></ds:Transform>
          <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></ds
:Transform>
        </ds:Transforms>
        <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"></d
s:DigestMethod>
        <ds:DigestValue>o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=</ds:DigestV
alue>
      </ds:Reference>
    </ds:SignedInfo>]]></pre>

<p class="note">En vertu du principe idéal de WYSIWYS (<i>what you see is what you sign</i>, soit littéralement « ce que vous voyez est ce que vous signez ») en vigueur dans le domaine de la signature électronique (par exemple dans certains contextes réglementaires), c'est ce document XML canonique qui devrait être affiché à l'utilisateur pour signature. En pratique et par souci de convivialité, lorsque le principe WYSIWYS n'est pas explicitement imposé, c'est le document XML référencé par l'élément <code>ds:Reference</code> qui est affiché à l'utilisateur.</p>

<p>L'algorithme de signature utilisé est SHA-256 et RSA, comme indiqué dans l'élément <code>ds:SignatureMethod</code>.</p>

<p>Calculer l'empreinte SHA-256 de l'élément <code>ds:SignedInfo</code> canonicalisé :</p>

<pre><strong>$ openssl sha256 data.dsig.signedinfo.c14n.xml</strong>
SHA256(data.dsig.signedinfo.c14n.xml)= 2d4d71e14ebf862476ffd6b3da3666c50661e139c
08f3fb9f6c845a2f4c5fe41</pre>

<p>Extraire, à partir du certificat de signature inclus dans l'élément <code>ds:X509Certificate</code> du nœud <code>ds:KeyInfo</code>, la clé publique du signature, dans le fichier <code>ee-key.pub.pem</code>.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -v /root/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate \
  data.dsig.xml | openssl base64 -d | openssl x509 -inform DER -pubkey -noout \
  > ee-key.pub.pem</strong></pre>

<p class="note">Le lecteur étant supposé familiarisé avec les outils <code>xml</code> et <code>openssl</code>, les commandes successives ont été chaînées sans passer par des fichiers intermédiaires.</p>

<p>Déchiffrer la signature numérique contenue dans l'élément <code>ds:SignatureValue</code> à l'aide de la clé publique de signature extraite, et analyser la structure ASN.1 <code>DigestInfo</code> (cf. section <a href="#DigestInfo" class="section"/>) résultante.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -v /root/ds:Signature/ds:SignatureValue data.dsig.xml | openssl base64 -d \
  | openssl pkeyutl -verifyrecover -pubin -inkey rsakey.pub.pem \
  | openssl asn1parse -i -inform DER</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:2D4D71E14EBF862476FFD
6B3DA3666C50661E139C08F3FB9F6C845A2F4C5FE41</pre>

<p>La valeur de l'empreinte à partir de l'octet 18 concorde avec l'empreinte de l'élément <code>ds:SignedInfo</code> canonicalisé calculée précédemment, donc la signature numérique est valide.</p>

<p class="note">Pour achever la vérification de la signature électronique, il faut vérifier que le certificat est valide, ce qui a été traité dans la section <a href="#verification-manuelle-sig-certificat" class="section"/>.</p>

<h1 id="auth-web">Authentification web</h1>
<p>Les tutoriaux sur l'utilisation de certificats SSL avec les serveurs web Apache et IIS étant légion, cette section s'intéresse à la génération de certificats EV<span class="fn">http://www.cabforum.org/certificates.html</span> (<i>Extended Validation</i> ou validation étendue) et à leur utilisation avec le serveur web nginx, recompilé pour pouvoir utiliser TLSv1.2, première version du protocole TLS à supporter l'algorithme de hachage SHA-256 (du fait d'attaques partielles à son encontre, SHA-1 est interdit par le RGS en France à partir du 6 mai 2013, et commence à être déconseillé ou est interdit ailleurs). Côté client, TLSv1.2 est encore très peu implémenté<span class="fn">http://en.wikipedia.org/wiki/Transport_Layer_Security#Browser_implementations</span> à la date de rédaction, y compris sur les versions les plus récentes des navigateurs web, donc le cas d'étude ci-après s'appuiera sur Internet Explorer 8 et 9 sous Windows 7.</p>
<p class="note">Le document<span class="fn">http://www.cabforum.org/Baseline_Requirements_V1.pdf</span> définissant les exigences liées aux certificats EV tolère SHA-1 tant que les algorithmes de la famille SHA-2 ne sont pas largement répandus dans les navigateurs : si la conformité au RGS n'est pas requise, alors ce chapitre peut être suivi pour mettre en place un serveur web avec un certificat ayant un profil EV avec une version de TLS antérieure à 1.2. Une section est dédiée à la configuration de Firefox en mode <i>debug</i> pour accepter un certificat de test comme étant de type EV.</p>

<h2 id="generation-certificats-lcr-auth-web">Génération des certificats et des listes de certificats révoqués</h2>
<p>Sommairement, les principales spécificités d'un certificat EV sont les suivantes :</p>
<ul>
<li>Référencer l'entité en charge du serveur dans le champ objet à l'aide des RDN usuels (tels que <code>C</code>, <code>O</code>, et <code>CN</code> — qui peut être omis au profit d'un <code>dNSName</code> dans l'extension <code>SubjectAlternativeName</code> ), mais aussi des RDN moins couramment utilisés (pour l'adresse et le type d'entité : <code>postalCode</code>, <code>serialNumber</code>, etc.) et enfin des RDN propriétaires (dont <code>jurisdictionOfIncorporationCountryName</code>).</li>
<li>Référencer, dans l'extension <code>certificatePolicies</code> du certificat serveur, l'OID de la politique de certification associée aux certificats EV. Internet Explorer s'attend à ce que les certificats de niveau supérieur contiennent soit ce même OID (peu réaliste d'un point de vue fonctionnel), soit <code>anyPolicy</code> (la solution retenue ci-après).</li>
<li>Référencer les ressources permettant de vérifier le statut de révocation des certificats, OCSP (<i>Online Certificate Status Protocol</i> ou protocole de statut de certificat en ligne) étant imposé depuis 2011. L'URL du serveur (<i>responder</i> ou répondeur) OCSP est à inclure — sauf cas particulier de l'agrafage OCSP (<i>OCSP stapling</i>, cf. RFC 4366) qui n'est pas traité ici pour le moment — dans l'extension <code>authorityInformationAccess</code> du certificat d'AC et des certificats d'AC intermédiaires).</li>
</ul>
<p>Pour un peu plus de « réalisme » (toutes proportions gardées !), une hiérarche de certification indépendante de celle créée précédemment est générée, comprenant une AC racine et une AC fille, de laquelle sera issu le certificat d'authentification serveur. Le RGS recommandant l'usage d'OCSP, et les exigences sur les certificats EV ainsi que Firefox l'imposant pour les certificats EV, un serveur OCSP est également mis en place.</p>
<p>L'objet d'un certificat EV d'entité final doit contenir des RDN qui ne sont pas connus d'OpenSSL et doivent donc être définis dans un fichier d'OID complémentaires. Créer le fichier <code>ev-oid.tsv</code> avec le contenu suivant :</p>
<pre>1.3.6.1.4.1.311.60.2.1.1  jurL  jurisdictionOfIncorporationLocalityName
1.3.6.1.4.1.311.60.2.1.2  jurST  jurisdictionOfIncorporationStateOrProvinceName
1.3.6.1.4.1.311.60.2.1.3  jurC  jurisdictionOfIncorporationCountryName</pre>
<p>Créer le fichier <code>req-empty-ev.cnf</code> suivant, référençant le fichier d'OID.</p>
<pre>oid_file = ev-oid.tsv

[ req ]
distinguished_name = req_distinguished_name

[ req_distinguished_name ]</pre>
<p>Générer en une seule passe — successivement pour l'AC racine, l'AC fille, le serveur OCSP rattaché à l'AC racine, le serveur OCSP rattaché à l'AC fille, et le serveur TLS — un bi-clé RSA de 2048 bits et une CSR contenant un objet (<i>subject</i>) conforme aux exigences associées aux certicats EV et aux profils de certificats RGS (les structures de DN utilisées précédemment conviennent).</p>
<pre><strong>$ openssl req -new -newkey rsa:2048 -nodes -keyout tls-rootca-key.pem \
  -subj "/C=FR/O=Mon Organisme/OU=0002 147258369/OU=OpenSSL TLS Root CA" \
  -sha256 -config req-empty-ev.cnf -out tls-rootca-req.pem
$ openssl req -new -newkey rsa:2048 -nodes -keyout tls-subca-key.pem \
  -subj "/C=FR/O=Mon Organisme/OU=0002 147258369/OU=OpenSSL TLS Subordinate CA" 
  -sha256 -config req-empty-ev.cnf -out tls-subca-req.pem
$ openssl req -new -newkey rsa:2048 -nodes -keyout tls-server-key.pem \
  -subj "/jurC=FR/businessCategory=Private Organization/serialNumber=789456123/C
  =FR/postalCode=99000/ST=France/L=Ma Ville/street=1 rue du Village/O=Ma Boutiqu
  e/OU=0002 789456123/CN=localhost" -sha256 -config req-empty-ev.cnf \
  -out tls-server-req.pem
$ openssl req -new -newkey rsa:2048 -nodes -keyout tls-rootca-ocsp-key.pem \
  -subj "/C=FR/O=Mon Organisme/OU=0002 147258369/CN=OpenSSL TLS Root CA OCSP Res
  ponder" -sha256 -config req-empty-ev.cnf -out tls-rootca-ocsp-req.pem
$ openssl req -new -newkey rsa:2048 -nodes -keyout tls-subca-ocsp-key.pem \
  -subj "/C=FR/O=Mon Organisme/OU=0002 147258369/CN=OpenSSL TLS Subordinate CA O
  CSP Responder" -sha256 -config req-empty-ev.cnf -out tls-subca-ocsp-req.pem</strong></pre>
<p class="note">Le DN objet de la CSR des serveurs TLS et OCSP est à saisir sur la même ligne.</p>
<p class="note">Noter l'emploi du nom court <code>jurC</code> pour désigner le type de RDN associé à l'OID 1.3.6.1.4.1.311.60.2.1.3.</p>
<p>Contrôler le contenu de l'objet du serveur TLS (le petit souci d'affichage du premier RDN est dû à la longueur du nom long du type du RDN).</p>
<pre><strong>$ openssl req -in tls-server-req.pem -config req-empty-ev.cnf -noout -subject \
  -nameopt multiline</strong>
subject=
 = FRurisdictionOfIncorporationCountryName
    businessCategory          = Private Organization
    serialNumber              = 789456123
    countryName               = FR
    postalCode                = 99000
    stateOrProvinceName       = France
    localityName              = Ma Ville
    streetAddress             = 1 rue du Village
    organizationName          = Ma Boutique
    organizationalUnitName    = 0002 789456123
    commonName                = localhost</pre>
<p>Créer le fichier de configuration pour les certificats et LCR émis par l'AC racine, <code>tls-rootca.cnf</code>.</p>
<pre>[tls_rootca]
database = tls-rootca-db.txt
serial = tls-rootca-crt.srl
crlnumber = tls-rootca-crl.srl
certificate = tls-rootca-crt.pem
private_key = tls-rootca-key.pem
default_md = sha256
default_crl_hours = 48
new_certs_dir = certs

[tls_ca_crt_dnpolicy]
C = supplied
O = supplied
OU = supplied

[tls_server_crt_dnpolicy]
C = supplied
O = supplied
OU = supplied
CN = supplied

[tls_rootca_crt_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,keyCertSign,cRLSign
certificatePolicies \
=1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.1,\
 anyPolicy
basicConstraints=critical,CA:TRUE

[tls_rootca_crl_ext]
authorityKeyIdentifier=keyid

[tls_subca_crt_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,keyCertSign,cRLSign
certificatePolicies \
=1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.2,\
 anyPolicy
crlDistributionPoints=URI:http://localhost/tls-rootca-crl.der
basicConstraints=critical,CA:TRUE
authorityInfoAccess=OCSP;URI:http://ocsp-rootca

[tls_rootca_ocsp_crt_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,digitalSignature
certificatePolicies=@tls_rootca_ocsp_crt_pol
crlDistributionPoints=URI:http://localhost/tls-rootca-crl.der
basicConstraints=critical,CA:FALSE
extendedKeyUsage=OCSPSigning

[tls_rootca_ocsp_crt_pol]
policyIdentifier = \
  1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.4
CPS = http://localhost/rootca-ocsp-CPS.pdf</pre>
<p>Ce fichier de configuration mérite quelques explications par rapport à ce qui a été fait précédemment :</p>
<ul>
<li>L'utilisation du serveur OCSP inclus dans OpenSSL suppose que la tenue à jour de la base des certificats émis par l'AC racine (<code>database = tls-rootca-db.txt</code> ci-dessus), ce qui impose l'utilisation de la commande <code>openssl ca</code> (au lieu de <code>openssl x509</code>) pour émettre les certificats.</li>
<li>La commande <code>openssl ca</code> impose la définition dans le fichier de configuration d'une politique de nommage régissant les RDN obligatoires ou acceptés de la CSR pour inclusion dans le certificat, d'où les sections <code>[…_dnpolicy]</code>.</li>
<li>Cette commande impose aussi la publication des certificats dans un répertoire local (<code>new_certs_dir = certs</code>), répertoire qui n'est plus utilisé par la suite.</li>
<li>Le nom de domaine du serveur OCSP associé à l'AC racine (c'est-à-dire capable de déterminer le statut d'un certificat émis par l'AC racine) est <code>ocsp-rootca</code> (un alias de la machine locale, qui sera configuré plus tard), et est à remplacer par un autre (vrai) nom de domaine s'il est hébergé sur un serveur autre que la machine locale.</li>
<li>De même, la LCR est publiée en local dans cette infrastructure d'exemple : la publier sur un autre serveur et modifier le champ <code>crlDistributionPoints</code> à sa convenance.</li>
<li>L'AC racine et l'AC fille référencent deux politiques de certification : la vraie politique de certification (au sens du RGS), et la méta-politique <code>anyPolicy</code> (comparable au métacaractère « <code>*</code> » pour un nom de fichier), facultative d'après le guide des certificats EV, mais obligatoire en réalité pour fonctionner avec Internet Explorer.</li>
</ul>
<p>Créer le fichier de configuration pour les certificats et LCR émis par l'AC fille, <code>tls-subca.cnf</code>.</p>
<pre>oid_file = ev-oid.tsv

[tls_subca]
database = tls-subca-db.txt
serial = tls-subca-crt.srl
crlnumber = tls-subca-crl.srl
certificate = tls-subca-crt.pem
private_key = tls-subca-key.pem
default_md = sha256
default_crl_hours = 48
new_certs_dir = certs

[tls_server_crt_dnpolicy]
C = supplied
O = supplied
OU = supplied
CN = supplied

[tls_server_ev_crt_dnpolicy]
jurC = supplied
jurST = optional
jurL = optional
businessCategory = supplied
serialNumber = supplied
C = supplied
postalCode = optional
ST = supplied
L = supplied
street = optional
O = supplied
OU = supplied
CN = supplied

[tls_subca_crl_ext]
authorityKeyIdentifier=keyid

[tls_subca_ocsp_crt_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,digitalSignature
certificatePolicies=@tls_subca_ocsp_crt_pol
crlDistributionPoints=URI:http://localhost/tls-subca-crl.der
basicConstraints=critical,CA:FALSE
extendedKeyUsage=OCSPSigning

[tls_subca_ocsp_crt_pol]
policyIdentifier = \
  1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.5
CPS = http://localhost/subca-ocsp-CPS.pdf

[tls_server_crt_ext]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
keyUsage=critical,keyEncipherment,digitalSignature
certificatePolicies=@tls_server_crt_pol
crlDistributionPoints=URI:http://localhost/tls-subca-crl.der
basicConstraints=critical,CA:FALSE
extendedKeyUsage=serverAuth
authorityInfoAccess=OCSP;URI:http://ocsp-subca

[tls_server_crt_pol]
policyIdentifier = \
  1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.3
CPS = http://localhost/server-auth-CPS.pdf</pre>
<p>Quelques commentaires s'imposent ici aussi :</p>
<ul>
<li>Le fichier d'OID est référencé (<code>oid_file = ev-oid.tsv</code>) pour que les RDN correspondants puissent être utilisés dans la politique de nommage <code>tls_server_ev_crt_dnpolicy</code>.</li>
<li>En dépit de l'exigence du RGS, deux bits du <code>keyUsage</code> sont positionnés (<code>digitalSignature</code> pour l'authentification, et <code>keyEncipherment</code> pour le chiffrement de la clé de session TLS) : du fait de la criticité du champ <code>keyUsage</code>, il s'agit d'éviter un jour d'être confronté au cas d'une application empêchant l'établissement d'une session TLS pour cause de bit manquant. Cet écart est provisoirement autorisé par le RGS depuis avril 2012<span class="fn">http://www.ssi.gouv.fr/fr/reglementation-ssi/referentiel-general-de-securite/modification-immediate_var_mode_calcul.html</span> (par effet de bord, l'erratum étant initialement prévu pour gérer la coexistence de l'échange de clés via RSA et via Diffie-Hellman).</li>
<li>1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.3 est l'identifiant de la politique de certification faisant l'objet du processus de référencement EV.</li>
<li>Les remarques précédentes sur l'emplacement du point de distribution des LCR et du serveur OCSP s'appliquent ici aussi.</li>
</ul>
<p>Créer les fichiers vides <code>tls-rootca-db.txt</code> et <code>tls-subca-db.txt</code> pour les bases de données des AC (utiliser par exemple la commande <code>touch</code> sous Linux/UNIX ou <code>cat nul &gt; <i>nomfichier</i>
</code> en ligne de commande DOS).</p>
<p>Créer le sous-répertoire <code>certs</code>.</p>
<p>Générer le certificat de l'AC racine, puis successivement — après avoir généré pour chacun un numéro de série aléatoire sur huit octets — celui de l'AC fille, </p>
<pre><strong>$ openssl x509 -req -in tls-rootca-req.pem -extfile tls-rootca.cnf \
  -extensions tls_rootca_crt_ext -signkey tls-rootca-key.pem -sha256 \
  -days 3652 -out tls-rootca-crt.pem</strong>
Signature ok
subject=/C=FR/O=Mon Organisme/OU=0002 147258369/OU=OpenSSL TLS Root CA
Getting Private key

<strong>$ openssl rand -hex 8 -out tls-rootca-crt.srl
$ openssl ca -batch -in tls-subca-req.pem -config tls-rootca.cnf \
  -name tls_rootca -extensions tls_subca_crt_ext -policy tls_ca_crt_dnpolicy \
  -days 2191 -out tls-subca-crt.pem</strong>
Using configuration from tls-rootca.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
organizationName      :PRINTABLE:'Mon Organisme'
organizationalUnitName:PRINTABLE:'0002 147258369'
organizationalUnitName:PRINTABLE:'OpenSSL TLS Subordinate CA'
Certificate is to be certified until Apr 15 13:21:52 2018 GMT (2191 days)

Write out database with 1 new entries
Data Base Updated

<strong>$ openssl rand -hex 8 -out tls-rootca-crt.srl
$ openssl ca -batch -in tls-rootca-ocsp-req.pem -config tls-rootca.cnf \
  -name tls_rootca -extensions tls_rootca_ocsp_crt_ext \
  -policy tls_server_crt_dnpolicy -days 2191 -out tls-rootca-ocsp-crt.pem</strong>
Using configuration from tls-rootca.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
organizationName      :PRINTABLE:'Mon Organisme'
organizationalUnitName:PRINTABLE:'0002 147258369'
commonName            :PRINTABLE:'OpenSSL TLS Root CA OCSP Responder'
Certificate is to be certified until Apr 15 13:21:54 2018 GMT (2191 days)

Write out database with 1 new entries
Data Base Updated

<strong>$ openssl rand -hex 8 -out tls-subca-crt.srl
$ openssl ca -batch -in tls-server-req.pem -config tls-subca.cnf \
  -name tls_subca -extensions tls_server_crt_ext \
  -policy tls_server_ev_crt_dnpolicy -days 365 -out tls-server-crt.pem</strong>
Using configuration from tls-subca.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
:PRINTABLE:'FR'ncorporationCountryName
businessCategory      :PRINTABLE:'Private Organization'
serialNumber          :PRINTABLE:'789456123'
countryName           :PRINTABLE:'FR'
postalCode            :PRINTABLE:'99000'
stateOrProvinceName   :PRINTABLE:'France'
localityName          :PRINTABLE:'Ma Ville'
streetAddress         :PRINTABLE:'1 rue du Village'
organizationName      :PRINTABLE:'Ma Boutique'
organizationalUnitName:PRINTABLE:'0002 789456123'
commonName            :PRINTABLE:'localhost'
Certificate is to be certified until Apr 15 13:21:55 2013 GMT (365 days)

Write out database with 1 new entries
Data Base Updated

<strong>$ openssl rand -hex 8 -out tls-subca-crt.srl
$ openssl ca -batch -in tls-subca-ocsp-req.pem -config tls-subca.cnf \
  -name tls_subca -extensions tls_subca_ocsp_crt_ext \
  -policy tls_server_crt_dnpolicy -days 2191 -out tls-subca-ocsp-crt.pem</strong>
Using configuration from tls-subca.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
organizationName      :PRINTABLE:'Mon Organisme'
organizationalUnitName:PRINTABLE:'0002 147258369'
commonName            :PRINTABLE:'OpenSSL TLS Subordinate CA OCSP Responder'
Certificate is to be certified until Apr 15 13:21:57 2018 GMT (2191 days)

Write out database with 1 new entries
Data Base Updated</pre>
<p>Créer le fichier <code>tls-rootca-crl.srl</code> et le fichier <code>tls-subca-crl.srl</code>, contenant chacun la chaîne de caractères « <code>01</code> ».</p>
<p>Générer la LCR émise par l'AC racine et par l'AC fille.</p>
<pre><strong>$ openssl ca -gencrl -config tls-rootca.cnf -name tls_rootca \
  -crlexts tls_rootca_crl_ext -out tls-rootca-crl.pem
$ openssl ca -gencrl -config tls-subca.cnf -name tls_subca \
  -crlexts tls_subca_crl_ext -out tls-subca-crl.pem</strong></pre>
<p>Vérifier la cohérence globale de la chaîne en validant le certificat du serveur TLS :</p>
<pre><strong>$ cat tls-subca-crl.pem tls-rootca-crl.pem tls-rootca-crt.pem \
  > tls-cafile-chain.pem
$ openssl verify -untrusted tls-subca-crt.pem -CAfile tls-cafile-chain.pem \
  -crl_check_all -verbose tls-server-crt.pem</strong>
tls-server-crt.pem: OK</pre>
<p>Convertir les deux LCR au format DER.</p>
<pre><strong>$ openssl crl -in tls-rootca-crl.pem -outform DER -out tls-rootca-crl.der
$ openssl crl -in tls-subca-crl.pem -outform DER -out tls-subca-crl.der</strong></pre>
<p>Si les points de distribution des LCR sont sur une machine autre que la machine locale, déposer les LCR au format DER aux points de distribution appropriés.</p>

<h2 id="compilation-installation-nginx">Compilation et installation du serveur web nginx</h2>
<p>À la date de rédaction, les serveurs web libres usuels ne supportent pas nativement TLSv1.2, et il est nécessaire de procéder à leur recompilation (pour Apache, avant la parution de la branche 1.0.1 d'OpenSSL, la solution était de compiler Apache avec GnuTLS<span class="fn">http://www.linuxunbound.com/2011/07/using-gnutls-with-apache-httpd-2-2/</span>). Cette section s'intéresse à la compilation du serveur web nginx avec OpenSSL 1.0.1 sous Windows (les instructions générales sont disponibles ici<span class="fn">http://nginx.org/en/docs/howto_build_on_win32.html</span>), ce serveur web ayant été choisi car plus simple à compiler et à configurer qu'Apache. En environnement Linux/UNIX, la compilation par les outils classiques <code>make</code> et <code>gcc</code> ne pose aucun problème particulier, mais des explications complémentaires semblent nécessaires pour Windows.</p>
<p>La compilation proposée de nginx sous Windows repose sur l'environnement MSYS pour les outils GNU usuels, et sur la suite Microsoft Visual Studio Express 2010 pour le compilateur C.</p>
<p>Télécharger<span class="fn">http://www.microsoft.com/express</span> et installer Visual Studio Express 2010, disponible gratuitement sur le site de Microsoft.</p>
<p>Télécharger MinGW depuis la page principale<span class="fn">mingw-get-inst</span>, suivre le lien <i>Downloads</i>, et sur le site Sourceforge télécharger la dernière version de l'exécutable <code>mingw-get-inst-….exe</code>, situé dans le dossier <code>Installer</code> puis <code>mingw-get-inst</code>. Installer MinGW, puis ouvrir une invite de commande DOS, et saisir la commande suivante :</p>
<pre><strong>> mingw-get install msys</strong></pre>
<p class="note">Cette commande suppose que répertoire des binaires de MinGW a bien été ajouté à la variable d'environnement <code>PATH</code> lors de l'installation, sinon saisir le chemin complet de <code>mingw-get</code> (le répertoire des binaires de MinGW est le sous-répertoire <code>bin</code> du répertoire d'installation de MinGW).</p>
<p>Fermer l'invite de commande DOS, puis démarrer l'invite de commande de MSYS. Exécuter le script de post-installation :</p>
<pre><strong>$ /postinstall/pi.sh</strong></pre>
<p class="note">Le lecteur prévoyant d'utiliser MSYS au-delà de cette section peut être intéressé par l'invite de commande améliorée Console2<span class="fn">http://sourceforge.net/projects/console/</span>, installable pour MSYS via <code>$ mingw-get install msys-console</code> puis <code>$ mingw-get install msys-console</code> (l'exécutable devrait se trouver dans le sous-répertoire <code>msys\1.0\lib\Console2</code> du répertoire d'installation de MinGW).</p>
<p>Installer un client Subversion en préparation du téléchargement de la dernière branche de nginx.</p>
<p class="note">Voici une piste possible pour intégrer les binaires de SVN à l'installation de MinGW/MSYS sous MSYS (cette procédure est très aisément réalisable sans passer par MSYS, mais présentant l'avantage d'installer les outils <code>wget</code> et <code>unzip</code>). La version de Subversion pour Windows<span class="fn">http://alagazam.net/</span> disponible à la date d'écriture est la version 1.7.4. Les commandes ci-dessous sont à adapter pour une version différente.</p>
<pre><strong>$ mingw-get install msys-wget
$ mingw-get install msys-unzip
$ wget http://sourceforge.net/projects/win32svn/files/1.7.4/svn-win32-1.7.4.zip/download
$ unzip svn-win32-1.7.4.zip
$ cd svn-win32-1.7.4
$ mv bin/* /mingw/bin/
$ cd ..</strong></pre>
<p>Faire un <i>checkout</i> Subversion du code source de la dernière version de nginx. En ligne de commande, la commande correspondante est (pour la version 1.1.18, qui n'est déjà plus la dernière version à la date de rédaction !) :</p>
<pre><strong>$ svn co svn://svn.nginx.org/nginx/tags/release-1.1.18</strong></pre>
<p>Télécharger le code source de pcre<span class="fn">http://www.pcre.org/</span>, de zlib<span class="fn">http://zlib.net/</span> et d'OpenSSL<span class="fn">http://www.openssl.org</span>. Il sera supposé ci-après que les archives zip et tar.gz correspondantes ont été téléchargées dans le même répertoire que celui d'où a été téléchargé le code source de nginx.</p>
<p class="note">Si à la date de lecture la version en cours de zlib est toujours la version 1.2.6, alors télécharger la version beta (version 1.2.6.1)<span class="fn">http://zlib.net/current/beta/zlib-1.2.6.1.tar.gz</span> (évoquée ici<span class="fn">http://mail.madler.net/pipermail/zlib-devel_madler.net/2012-February/002759.html</span>) pour éviter d'être confronté à des problèmes de compilation<span class="fn">http://mail.madler.net/pipermail/zlib-devel_madler.net/2012-January/002733.html</span> liés à la fonction <code>gzflags()</code> sous Windows.</p>
<p>Préparer le code source pour la compilation de nginx, sous MSYS (en modifiant les noms des fichiers et l'emplacement des répertoires au besoin) :</p>
<pre><strong>$ cd release-1.1.18
$ mkdir -p objs/lib
$ cd objs/lib
$ unzip ../../../pcre-8.30.zip
$ tar -xzf ../../../zlib-1.2.6.1.tar.gz
$ tar -xzf ../../../openssl-1.0.1.tar.gz</strong></pre>
<p>Pour OpenSSL version 1.0.1, deux retouches du paquetage source sont nécessaires. La première est liée à la gestion des retours chariot sous Windows dans le script <code>mk1mf.pl</code>, et est décrite dans l'annexe sur la compilation d'OpenSSL. La seconde modification a trait à l'utilisation de l'assembleur MASM (non officiellement supporté pour la compilation d'OpenSSL sous Windows, mais imposé par nginx) : le problème est décrit ici<span class="fn">http://www.mail-archive.com/openssl-dev@openssl.org/msg30681.html</span>, et la solution ici<span class="fn">http://cvs.openssl.org/chngview?cn=22302</span>.</p>
<p>Configurer nginx pour la compilation (en veillant aux numéros de version dans les noms des répertoires) :</p>
<pre><strong>$ auto/configure --with-cc=cl --builddir=objs --prefix= \
--conf-path=conf/nginx.conf --pid-path=logs/nginx.pid \
--http-log-path=logs/access.log --error-log-path=logs/error.log \
--sbin-path=nginx.exe --http-client-body-temp-path=temp/client_body_temp \
--http-proxy-temp-path=temp/proxy_temp \
--http-fastcgi-temp-path=temp/fastcgi_temp \
--with-cc-opt=-DFD_SETSIZE=1024 --with-pcre=objs/lib/pcre-8.30 \
--with-zlib=objs/lib/zlib-1.2.6 --with-openssl=objs/lib/openssl-1.0.1 \
--with-select_module --with-http_ssl_module --with-ipv6</strong></pre>
<p>Fermer MSYS, puis ouvrir l'invite de commande de Visual Studio (installée dans le menu Démarrer sous un nom tel que <em>Visual Studio Command Prompt (2010)</em>), se rendre dans le répertoire racine du code source de nginx (<code>…/release-1.1.18</code> ci-dessus), et démarrer la compilation, dont l'aboutissement devrait être la production de l'exécutable <code>objs/nginx.exe</code> :</p>
<pre><strong>> nmake -f objs/Makefile</strong></pre>
<p>Créer un répertoire d'installation, et y copier <code>objs/nginx.exe</code> du répertoire de compilation.</p>
<p>Dans le répertoire d'installation, créer les sous-répertoires <code>logs</code>, <code>conf</code>, <code>temp</code> et <code>www</code>.</p>

<h2 id="parametrage-nginx">Paramétrage du serveur web nginx</h2>
<p>Dans le sous-répertoire <code>conf</code>, créer le fichier <code>nginx.conf</code>, avec le contenu suivant (en remplaçant <code>
<i>[racine_nginx]</i>
</code> par le chemin du répertoire racine de nginx, avec le caractère séparateur de sous-répertoires « <code>/</code> »  — par exemple <code>C:/tp-ce/nginx</code> sous Windows) :</p>
<pre>events {
    worker_connections  1024;
}

http {
    server {
        listen 80 ;

        server_name localhost;
        location / {
            root   <em>[répertoire d'installation de nginx]</em>/www;
            index  index.html;
        }
    }
}</pre>
        <p>Créer le fichier <code>index.html</code> ci-dessous (avec le codage UTF-8) et le placer dans le sous-répertoire <code>www</code> de nginx.</p>
<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>nginx/TLSv1.2/EV</title>
</head>
<body>
<h1>Bonjour à tous !</h1>
</body>
</html>]]></pre>
<p>Pour valider la configuration, démarrer le serveur nginx (via la commande <code>nginx</code>, et s'assurer que la page <code>http://localhost</code> correspond bien au fichier <code>index.html</code> ci-dessus. Arrêter le serveur par la commande <code>nginx -s stop</code> pour passer à la configuration de SSL/TLS.</p>
<p>Concaténer le certificat du serveur TLS et celui de son AC émettrice (AC non racine) dans le fichier <code>tls-server-chain.pem</code>.</p>
<pre><strong>$ cat tls-server-crt.pem tls-subca-crt.pem > tls-server-chain.pem</strong></pre>
<p>Copier le fichier ainsi produit, ainsi que la clé privée du serveur <code>tls-server-key.pem</code> dans le sous-répertoire <code>conf</code> de nginx, et ajouter les lignes en gras ci-dessous au fichier de configuration <code>nginx.conf</code>.</p>
<pre>…
http {
    server {
        listen 80 ;
<strong>        listen 443 ssl ;

        ssl_certificate  tls-server-chain.pem  ;
        ssl_certificate_key    tls-server-key.pem ;</strong>

        server_name localhost;
        …</pre>
<p>Démarrer le serveur nginx et tenter d'accéder à la page <code>https://localhost</code>, ce qui devrait provoquer un avertissement du navigateur, qui ne connaît pas l'AC racine de la chaîne de certification du certificat du serveur TLS. Installer l'AC racine dans le magasin de certificats de Windows (pour Internet Explorer et Chrome) ou du navigateur (pour la plupart des autres navigateurs) et vérifier que l'accès à la page web ne provoque plus d'erreur (avec au contraire une signalétique de type cadenas indiquant que la connexion est sécurisée).</p>
<p>Si les points de distribution des LCR sont locaux (comme dans les fichiers de configuration proposés), alors déposer les fichiers des LCR dans les répertoires appropriés : avec les fichiers ci-dessus, <code>tls-rootca-crl.der</code> et <code>tls-subca-crl.der</code> sont à placer dans le sous-répertoire <code>www</code> de nginx.</p>

<h2 id="serveurs-ocsp">Mise en place des serveurs OCSP</h2>
<p>Pour démarrer localement sur des ports HTTP arbitraires (81 et 82 ci-après) les serveurs OCSP associés d'une part aux certificats délivrés l'AC racine, et d'autre part à ceux délivrés par l'AC fille, exécuter les commandes ci-dessous (dans deux invites de commande différentes, les commandes étant bloquantes) dans le répertoire dans lequel ont été générés les certificats :</p>
<pre><strong>$ openssl ocsp -sha256 -index tls-rootca-db.txt -port 0.0.0.0:81 \
  -rsigner tls-rootca-ocsp-crt.pem -rkey tls-rootca-ocsp-key.pem \
  -CA tls-rootca-crt.pem -text</strong></pre>
<p>pour l'AC racine, et</p>
<pre><strong>$ openssl ocsp -index tls-subca-db.txt -port 0.0.0.0:82 \
   -rsigner tls-subca-ocsp-crt.pem -rkey tls-subca-ocsp-key.pem \
   -CA tls-subca-crt.pem -text</strong></pre>
<p>pour l'AC intermédiaire.</p>
<p class="note">Sous les systèmes d'exploitation supportant IPv6, le serveur OCSP écoute par défaut uniquement sur les adresses IPv6 de la machine (constaté par l'auteur sous Windows 7, le problème ayant été rencontré par d'autres<span class="fn">http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=632833</span> sous Linux), d'où l'utilisation de la syntaxe non documentée <code>-port 0.0.0.0:<i>port</i>
</code>, qui force le serveur à écouter sur les adresses IPv4 uniquement (cf. aussi ici<span class="fn">http://comments.gmane.org/gmane.comp.encryption.openssl.user/40849</span> pour d'autres cas d'utilisation non documentés de <code>-port</code> en rapport avec ce sujet).</p>
<p class="note">L'option <code>-text</code> permet d'afficher les requêtes reçues et les réponses envoyées dans la fenêtre du serveur, et peut être omise si par exemple le serveur OCSP est exécuté en tant que démon.</p>
<p>Tester le serveur OCSP depuis le répertoire des certificats à l'aide de la commande suivante :</p>
<pre><strong>$ openssl ocsp -sha256 -issuer tls-rootca-crt.pem -cert tls-subca-crt.pem \
  -CAfile tls-rootca-crt.pem -host localhost:81</strong>
Response verify OK
tls-subca-crt.pem: good
        This Update: Apr 19 13:05:58 2012 GMT

<strong>$ cat tls-subca-crt.pem tls-rootca-crt.pem > tls-subca.cafile
$ openssl ocsp -sha256 -issuer tls-subca-crt.pem -cert tls-server-crt.pem \
  -CAfile tls-subca.cafile -host localhost:82</strong>
Response verify OK
tls-server-crt.pem: good
        This Update: Apr 19 13:14:57 2012 GMT</pre>
<p>La fenêtre des serveurs OCSP respectifs affiche les requêtes et réponses OCSP, par exemple la requête portant sur le statut du certificat de l'AC fille :</p>
<pre>OCSP Request Data:
    Version: 1 (0x0)
    Requestor List:
        Certificate ID:
          Hash Algorithm: sha256
          Issuer Name Hash: EB98C924CC18F1235F2F900AE21016CB57EB3AF3F1BCABBB02E3
3A4C9B999E7C
          Issuer Key Hash: 9FA4C24D06DB661D043B914527650BA763D9EB0A4181FC5BCE467
E6F72E939EF
          Serial Number: E6572284531C7987
    Request Extensions:
        OCSP Nonce:
            04100B44A571D0453E8B235701C1A511FE97</pre>
<p>suivie de la réponse indiquant que le certificat est valide :</p>
<pre>OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
    Version: 1 (0x0)
    Responder Id: C = FR, O = Mon Organisme, OU = 0002 147258369, CN = OpenSSL T
LS Root CA OCSP Responder
    Produced At: Apr 19 13:06:46 2012 GMT
    Responses:
    Certificate ID:
      Hash Algorithm: sha256
      Issuer Name Hash: EB98C924CC18F1235F2F900AE21016CB57EB3AF3F1BCABBB02E33A4C
9B999E7C
      Issuer Key Hash: 9FA4C24D06DB661D043B914527650BA763D9EB0A4181FC5BCE467E6F7
2E939EF
      Serial Number: E6572284531C7987
    Cert Status: good
    This Update: Apr 19 13:06:46 2012 GMT

    Response Extensions:
        OCSP Nonce:
            04100B44A571D0453E8B235701C1A511FE97
    Signature Algorithm: sha1WithRSAEncryption
         8d:2c:75:32:3e:2b:44:84:4f:fd:d7:f9:2d:d2:99:48:4a:7e:
         …
         c8:ea:b7:92
Certificate:
    … <em>certificat du répondeur OCSP</em>…</pre>
<p class="note">Le lecteur attentif remarquera que la signature de la réponse OCSP utilise SHA-1, malgré le démarrage du serveur OCSP avec l'option <code>-sha256</code>. Il se trouve que préciser l'algorithme de hachage lorsque la commande <code>openssl ocsp</code> est utilisée en mode serveur OCSP ne sert à rien : SHA-1, algorithme de hachage par défaut d'OpenSSL dans le cas d'une signature à l'aide d'une clé RSA, est utilisé systématiquement. Pour signer avec RSA et un autre algorithme de hachage, il faut modifier le code source d'OpenSSL et le recompiler, ou créer une nouvelle commande de serveur OCSP, ce qui fait l'objet de l'annexe <a href="#ocsp-sigalg" class="appendix_section"/>.</p>
<p>Pour faire le lien entre les URL référencées dans l'extension <code>authorityInfoAccess</code> des certificats et les serveurs OCSP qui ont été démarrés, deux nouveaux serveurs virtuels (servant les hôtes <code>ocsp-rootca</code> et <code>ocsp-subca</code>) doivent être créés et configurés en tant que <i>reverse proxy</i> : toutes les requêtes adressées à ces hôtes sont redirigées vers une autre adresse, en l'occurrence celle des serveurs OCSP.</p>
<p>Tout d'abord, ajouter dans <code>C:\Windows\System32\drivers\etc\hosts</code> (Windows) ou <code>/etc/hosts</code> (Linux/UNIX) les lignes suivantes, définissant deux alias de l'adresse IP 127.0.0.1 (appelée adresse de rebouclage ou <i>loopback</i>, et qui désigne la machine locale, dont le nom de domaine est <code>localhost</code>) :</p>
<pre>127.0.0.1  ocsp-rootca
127.0.0.1  ocsp-subca</pre>
<p>Ajouter dans <code>nginx.conf</code> les blocs de configuration pour les serveurs virtuels associés à ces alias :</p>
<pre>…
http {
    server {
        …
    }
    
<strong>    server {
        listen   80;

        server_name ocsp-rootca;
        location / {
            proxy_pass http://localhost:81/ ;
            proxy_set_header Host ocsp-rootca; 
        }

    }

    server {
        listen   80;

        server_name ocsp-subca;
        location / {
            proxy_pass http://localhost:82/ ;
        }</strong>

    }
}</pre>
<p>Démarrer nginx, mais ne pas tenter d'utiliser <code>openssl ocsp</code> avec <code>-host ocsp-rootca</code> ou <code>-host ocsp-subca</code> au risque d'être déçu : en effet, cette commande génère une requête POST HTTP extrêmement basique, ne renseignant pas le nom de l'hôte dans l'en-tête HTTP <code>Host</code> (ce qui est assez peu représentatif du comportement normal d'un client HTTP), si bien que nginx ne sait pas qu'il doit rediriger la requête vers l'hôte virtuel <code>ocsp-rootca</code> ou <code>ocsp-subca</code>, et renverra une erreur HTTP (typiquement une erreur 405, <i>method not allowed</i> ou méthode non autorisée, pour avoir tenté d'adresser une requête POST à un fichier statique). Une solution simple est d'utiliser un client HTTP plus standard, qui génère une en-tête HTTP <code>Host</code>, pour envoyer la requête : l'exemple ci-après s'appuie sur curl<span class="fn">http://curl.haxx.se/</span> (le site web propose de télécharger l'outil en version binaire ou source).</p>
<p>Générer une requête OCSP dans le fichier <code>tls-subca-ocspreq.der</code> (elle est toujours créée au format DER) :</p>
<pre><strong>$ openssl ocsp -sha256 -issuer tls-rootca-crt.pem -cert tls-subca-crt.pem \
  -reqout tls-subca-ocspreq.der</strong></pre>
<p>Constituer une requête POST HTTP avec pour en-tête <code>Content-Type</code> la valeur <code>application/ocsp-request</code> (optionnel, mais attendu par la RFC 2560), l'envoyer au serveur, et écrire la réponse dans le fichier <code>tls-subca-ocspresp.der</code> :</p>
<pre><strong>$ curl -o tls-subca-ocspresp.der --data-binary @tls-subca-ocspreq.der \
  -H "Content-Type:application/ocsp-request" http://ocsp-rootca</strong></pre>
<p>Afficher la réponse dans un format lisible :</p>
<pre><strong>$ openssl ocsp -respin tls-subca-ocspresp.der -CAfile tls-rootca-crt.pem \
  -resp_text</strong></pre>
<p>Vérifier que le serveur OCSP de l'AC fille fonctionne aussi comme prévu :</p>
<pre><strong>$ openssl ocsp -sha256 -issuer tls-rootca-crt.pem -cert tls-subca-crt.pem \
  -reqout tls-subca-ocspreq.der
$ curl -o tls-subca-ocspresp.der --data-binary @tls-subca-ocspreq.der \
  -H "Content-Type:application/ocsp-request" http://ocsp-rootca
$ openssl ocsp -respin tls-subca-ocspresp.der -CAfile tls-rootca-crt.pem \
  -resp_text</strong></pre>

<h2 id="parametrage-tls-1-2">Paramétrage de TLSv1.2</h2>
<p class="note">Les instructions de cette section ne doivent pas être suivies si le navigateur utilisé ne supporte pas TLSv1.2.</p>
<p>Les algorithmes cryptographiques SSL/TLS implémentés par OpenSSL peuvent être recensés par la commande suivante :</p>
<pre><strong>$ openssl ciphers -v</strong>
ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD

ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(256) Mac=A
EAD
…
EXP-RC2-CBC-MD5         SSLv3 Kx=RSA(512) Au=RSA  Enc=RC2(40)   Mac=MD5  export
EXP-RC4-MD5             SSLv3 Kx=RSA(512) Au=RSA  Enc=RC4(40)   Mac=MD5  export</pre>
<p>Restreindre cette liste aux algorithmes utilisant des clés RSA pour le chiffrement de la clé de session et pour l'authentification (<code>RSA</code>) et l'algorithme de hachage SHA-256 (<code>SHA256</code>), et imposer le chiffrement symétrique du canal (excluant l'absence de chiffrement : <code>!NULL</code>) :</p>
<pre><strong>$ openssl ciphers -v SHA256+RSA!NULL</strong>
AES256-SHA256           SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
AES128-SHA256           SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256</pre>
<p>Dans la liste obtenue, les algorithmes de chiffrement symétrique sont AES128 ou AES256, tous deux conformes au RGS. La chaîne consolidée définissant les algorithmes autorisés est ainsi <code>SHA256+RSA+AES</code>.</p>
<p class="note">Il est possible de s'assurer à l'aide de l'option <code>-tlsv1</code> que les algorithmes ci-dessus sont bien supportés par TLSv1.</p>
<p>Ajouter les lignes en gras ci-dessous au fichier de configuration <code>nginx.conf</code> pour forcer l'utilisation du protocole TLSv1.2, et imposer l'utilisation des algorithmes conformes au RGS :</p>
<pre>…
http {
    server {
        listen 80 ;
        listen 443 ssl ;

        ssl_certificate  tls-server-chain.pem  ;
        ssl_certificate_key    tls-server-key.pem ;
<strong>        ssl_protocols TLSv1.2 ;
        ssl_ciphers SHA256+RSA+AES ;</strong>

        server_name localhost;
        …</pre>
        <p>Le fichier de configuration final est le suivant :</p>
<pre>events {
    worker_connections  1024;
}

http {
    server {
        listen 80 ;
        listen 443 ssl ;

        ssl_certificate  tls-server-chain.pem  ;
        ssl_certificate_key    tls-server-key.pem ;
        ssl_protocols TLSv1.2 ;
        ssl_ciphers SHA256+RSA+AES ;

        server_name localhost;
        location / {
            root   <em>[répertoire d'installation de nginx]</em>/www;
            index  index.html;
        }
    }
    
    server {
        listen   80;

        server_name ocsp-rootca;
        location / {
            proxy_pass http://localhost:81/ ;
            proxy_set_header Host ocsp-rootca; 
        }

    }

    server {
        listen   80;

        server_name ocsp-subca;
        location / {
            proxy_pass http://localhost:82/ ;
        }

    }
}</pre>
<p class="note">L'agrafage OCSP évoqué ci-dessus devrait être supporté<span class="fn">http://mailman.nginx.org/pipermail/nginx-devel/2011-June/000956.html</span> dans la version 2.0 de nginx. Le lecteur intéressé par cette fonctionnalité peut mettre en place un serveur web IIS 7 ou supérieur, ou Apache (cf. instructions ici<span class="fn">http://www.imperialviolet.org/2009/12/20/setting-up-ocsp.html</span> ou ce patch<span class="fn">https://issues.apache.org/bugzilla/show_bug.cgi?id=43822</span> pour la version 2.2.6).</p>

<h2 id="ie-tls-1-2">Internet Explorer</h2>
<p>Installer le certificat de l'AC racine dans le magasin de certificats de Windows.</p>
<p>Pour qu'un certificat serveur dont la chaîne de certification mène à l'AC racine soit reconnu comme étant un certificat EV, sous Windows 7 (et Windows 2008), afficher les propriétés du certificat de l'AC racine depuis le magasin de certificats, accéder à l'onglet Validation étendue, saisir l'OID de la PC associée aux certificats EV, c'est-à-dire l'OID de la PC tel qu'inscrit dans l'extension <code>certificatePolicies</code> du certificat serveur TLS, et valider.</p>

<p>Accéder à l'adresse <code>https://localhost</code>, et observer que l'URL et le nom de l'entité certifiée (telle que renseignée dans le champ <code>O</code> du certificat serveur, pour rappel le champ <code>CN</code> identifie l'application) sont affichées sur fond vert, représentant l'utilisation de certificats EV.</p>

<img alt="EV SSL sous Internet Explorer 9" src="img/EVSSL_IE9.png" />

<p>Dans la configuration mise en place ici, IE9 vérifie le statut de révocation en consultant les LCR.</p>

<div class="note">
<p>Pour s'assurer que le statut de révocation est bien pris en compte, une LCR contenant le numéro de série du certificat peut être émise et déposée dans le répertoire servant les LCR. Il est alors nécessaire de purger les caches des LCR de Windows pour forcer le chargement de la nouvelle LCR, à l'aide des commandes suivantes (la première vide le cache disque, la seconde invalide le cache mémoire) :</p>

<pre>>certutil -urlcache CRL delete
> certutil -setreg chain\ChainCacheResyncFiletime @now</pre>

<p>La commande <code>certutil -v urlcache -CRL</code> affiche le contenu du cache disque des LCR. Pour plus d'informations sur la gestion du statut de révocation des certificats sous Windows et la commande <code>certutil</code>, se reporter à la documentation officielle<span class="fn">http://technet.microsoft.com/en-us/library/ee619754%28v=ws.10%29.aspx</span>.</p>
</div>


<p>Le serveur OCSP n'est pas utilisable en l'état par IE9, celui-ci générant des requêtes OCSP au format RFC 5019 (section 5) via HTTP GET, qui n'est pas supporté par le serveur OCSP en ligne de commande d'OpenSSL<span class="fn">http://comments.gmane.org/gmane.comp.encryption.openssl.user/42191</span>. Un script CGI pourrait par exemple être développé pour convertir la requête d'IE9 en requête POST « classique » avant de la passer à OpenSSL.</p>

<p>À titre d'illustration, voici le journal des requêtes HTTP du serveur, mettant en évidence l'interrogation (en échec) du serveur OCSP et le téléchargement des LCR.</p>

<pre>127.0.0.1 - - [15/Apr/2012:10:11:32 +0200] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5
.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"
127.0.0.1 - - [15/Apr/2012:10:11:34 +0200] "-" 400 0 "-" "-"
127.0.0.1 - - [15/Apr/2012:10:11:55 +0200] "GET /MEowSDBGMEQwQjAJBgUrDgMCGgUABBT
npomF%2FJkCIe62ShdoLJJBGBfQOAQU9DQZRK0Uy4OEscKbCj6oDJB5aXwCCQDmVyKEUxx5hw%3D%3D 
HTTP/1.1" 200 5 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:11:55 +0200] "GET /MEowSDBGMEQwQjAJBgUrDgMCGgUABBT
npomF%2FJkCIe62ShdoLJJBGBfQOAQU9DQZRK0Uy4OEscKbCj6oDJB5aXwCCQDmVyKEUxx5hw%3D%3D 
HTTP/1.1" 502 173 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:00 +0200] "GET /tls-rootca-crl.der HTTP/1.1" 20
0 474 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:05 +0200] "GET /MEkwRzBFMEMwQTAJBgUrDgMCGgUABBT
2IXg%2BD7s0Dwo6NZoErGbC4LF2ZwQUMmQEAQYr2Zgp2wEl0YO26synN4QCCDaoL4MkMnHI HTTP/1.1
" 200 5 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:07 +0200] "-" 400 0 "-" "-"
127.0.0.1 - - [15/Apr/2012:10:12:07 +0200] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5
.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"
127.0.0.1 - - [15/Apr/2012:10:12:08 +0200] "-" 400 0 "-" "-"
127.0.0.1 - - [15/Apr/2012:10:12:10 +0200] "GET /tls-rootca-crl.der HTTP/1.1" 30
4 0 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:10 +0200] "GET /tls-subca-crl.der HTTP/1.1" 200
 481 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:12 +0200] "GET /tls-subca-crl.der HTTP/1.1" 200
 481 "-" "Microsoft-CryptoAPI/6.1"
127.0.0.1 - - [15/Apr/2012:10:12:20 +0200] "POST / HTTP/1.1" 499 0 "-" "Microsof
t-CryptoAPI/6.1"</pre>

<h2 id="ff-tls-1-2">Firefox</h2>

<p>L'acceptation d'une AC de test EV sous Firefox nécessite une version de débogage de Firefox, soit compilée soi-même (une opération relativement laborieuse décrite sur le site de Mozilla<span class="fn">https://developer.mozilla.org/en-US/docs/Developer_Guide/Build_Instructions</span>), soit pré-compilée (à récupérer dans le dépôt FTP de Mozilla <span class="fn">ftp://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/</span>, dans le sous-répertoire <code>mozilla-release-<em>plate-forme</em>-debug</code>, en notant que la stabilité de ces versions intermédiaires est variable).</p>

<p>L'AC racine EV de test doit être déclarée dans un fichier de configuration <em>ad hoc</em>, nommé <code>test_ev_roots.txt</code>. Ce fichier a la structure suivante :</p>

<pre>1_fingerprint <em>empreinte SHA1 au format hexadécimal xx:xx:…:xx</em>
2_readable_oid <em>OID de la politique de certification du certificat EV</em>
3_issuer <em>codage Base64 du DER du champ Issuer du certificat</em> 
4_serial <em>codage Base64 de la représentation DER du numéro de série du certificat</em></pre>

<p>Pour la ligne <code>1_fingerprint</code>, utiliser l'option <code>-fingerprint</code> d'<code>openssl x509</code> :</p>

<pre><strong>$ openssl x509 -in tls-rootca-crt.pem -fingerprint -noout</strong>
SHA1 Fingerprint=BC:1F:00:D2:05:57:9F:9F:64:6F:FB:40:AE:AC:DE:46:F7:57:49:A1</pre>

<p>Pour obtenir la ligne 3, déterminer d'abord où démarre le champ <code>Issuer</code> :</p>

<pre><strong>$ openssl x509 -in tls-rootca-crt.pem -outform DER | openssl asn1parse \
  -inform DER -i</strong>
    0:d=0  hl=4 l= 987 cons: SEQUENCE
    4:d=1  hl=4 l= 707 cons:  SEQUENCE
    8:d=2  hl=2 l=   3 cons:   cont [ 0 ]
   10:d=3  hl=2 l=   1 prim:    INTEGER           :02
   13:d=2  hl=2 l=   9 prim:   INTEGER           :BE6D461CD887515D
   24:d=2  hl=2 l=  13 cons:   SEQUENCE
   26:d=3  hl=2 l=   9 prim:    OBJECT            :sha256WithRSAEncryption
   37:d=3  hl=2 l=   0 prim:    NULL
   39:d=2  hl=2 l=  92 cons:   SEQUENCE
   41:d=3  hl=2 l=  11 cons:    SET
   43:d=4  hl=2 l=   9 cons:     SEQUENCE
   45:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
   50:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :FR
   54:d=3  hl=2 l=  22 cons:    SET
   …
</pre>

<p>Ici la <code>SEQUENCE</code> définissant le champ <code>Issuer</code> démarre à l'octet 39. Extraire ce champ puis coder sa représentation DER en Base64 :</p>

<pre><strong>$ openssl x509 -in tls-rootca-crt.pem -outform DER | openssl asn1parse \
  -inform DER -strparse 39 -out issuer.der</strong>
    0:d=0  hl=2 l=  92 cons: SEQUENCE
    2:d=1  hl=2 l=  11 cons: SET
    4:d=2  hl=2 l=   9 cons: SEQUENCE
    6:d=3  hl=2 l=   3 prim: OBJECT            :countryName
   11:d=3  hl=2 l=   2 prim: PRINTABLESTRING   :FR
   15:d=1  hl=2 l=  22 cons: SET
   17:d=2  hl=2 l=  20 cons: SEQUENCE
   19:d=3  hl=2 l=   3 prim: OBJECT            :organizationName
   24:d=3  hl=2 l=  13 prim: PRINTABLESTRING   :Mon Organisme
   39:d=1  hl=2 l=  23 cons: SET
   41:d=2  hl=2 l=  21 cons: SEQUENCE
   43:d=3  hl=2 l=   3 prim: OBJECT            :organizationalUnitName
   48:d=3  hl=2 l=  14 prim: PRINTABLESTRING   :0002 147258369
   64:d=1  hl=2 l=  28 cons: SET
   66:d=2  hl=2 l=  26 cons: SEQUENCE
   68:d=3  hl=2 l=   3 prim: OBJECT            :organizationalUnitName
   73:d=3  hl=2 l=  19 prim: PRINTABLESTRING   :OpenSSL TLS Root CA  
 
<strong>$ openssl base64 -in issuer.der</strong>
MFwxCzAJBgNVBAYTAkZSMRYwFAYDVQQKEw1Nb24gT3JnYW5pc21lMRcwFQYDVQQL
Ew4wMDAyIDE0NzI1ODM2OTEcMBoGA1UECxMTT3BlblNTTCBUTFMgUm9vdCBDQQ==</pre>

<p>La ligne <code>4_serial</code> nécessite un peu plus de précaution, car il s'agit ici d'obtenir le codage Base64 de la représentation DER du numéro de série du certificat sans les en-têtes DER (lesquelles en-têtes identifient le type <code>INTEGER</code> et précisent la longueur du contenu).</p>

<p>Repérer l'emplacement du numéro de série :</p>

<pre><strong>$ openssl x509 -in tls-rootca-crt.pem -outform DER | openssl asn1parse \
  -inform DER -i</strong>
    0:d=0  hl=4 l= 979 cons: SEQUENCE
    4:d=1  hl=4 l= 699 cons:  SEQUENCE
    8:d=2  hl=2 l=   3 cons:   cont [ 0 ]
   10:d=3  hl=2 l=   1 prim:    INTEGER           :02
   <em>13:d=2  hl=2 l=   9 prim:   INTEGER           :AD49132769D200C5</em></pre>

<p>Le contenu du numéro de série démarre à l'octet 15 (la structure complète est à l'octet 13, dont les <code>hl=2</code> premiers octets sont à ignorer) et a une longueur de <code>l=9</code> octets. Extraire ce contenu, en ignorant les erreurs (ce contenu n'étant pas une structure DER valide), puis le coder en Base64.</p>

<pre><strong>$ openssl x509 -in tls-rootca-crt.pem -outform DER | openssl asn1parse \
  -inform DER -i -offset 15 -length 9 -out serialnum.bin</strong>
Error in encoding
6360:error:0D07207B:asn1 encoding routines:ASN1_get_object:header too long:.\cry
pto\asn1\asn1_lib.c:150:

<strong>$ openssl base64 -in serialnum.bin</strong>
AL5tRhzYh1Fd</pre>

<p>À partir des données ci-dessus créer le fichier <code>test_ev_roots.txt</code>.</p>

<pre>1_fingerprint BC:1F:00:D2:05:57:9F:9F:64:6F:FB:40:AE:AC:DE:46:F7:57:49:A1
2_readable_oid 1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.
2493436.1.3
3_issuer MFwxCzAJBgNVBAYTAkZSMRYwFAYDVQQKEw1Nb24gT3JnYW5pc21lMRcwFQYDVQQLEw4wMDA
yIDE0NzI1ODM2OTEcMBoGA1UECxMTT3BlblNTTCBUTFMgUm9vdCBDQQ==
4_serial AL5tRhzYh1Fd</pre>

<p class="note">L'annexe <a href="#testevroots" class="appendix_section"/> propose un outil de génération du fichier <code>test_ev_roots.txt</code> à partir d'un certificat et de l'OID de la politique de certification EV.</p>

<p>Déplacer ce fichier dans le répertoire du profil utilisateur de Firefox<span class="fn">http://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data</span>.</p>

<p>Donner à la variable d'environnement <code>ENABLE_TEST_EV_ROOTS_FILE</code> la valeur 1, démarrer Firefox et se rendre à l'URL <code>https://localhost</code>.</p>

<p>Les captures d'écran ci-dessous représentent deux rendus, le premier sous une version de Firefox 4.0 beta 8 <em>debug</em> précompilée.</p>

<img alt="EV SSL sous Firefox 4.0 Minefield (debug)" src="img/EVSSL_firefox-4.0b8pre.en-US.win32.png" />

<p>Voici le rendu sous une version Firefox 11 <em>nightly</em> compilée à partir du code source.</p>

<img alt="EV SSL sous Firefox 11.0 Nightly (debug)" src="img/EVSSL_firefox-11.0-nightly.en-US.win32.png" />

<p>Le nom de l'organisation « Ma Boutique » sur fond vert dans la barre l'URL indique que le serveur est authentifié à l'aide d'un certificat EV.</p>

<p>En mode EV, Firefox ne consulte pas les CRL<span class="fn">https://wiki.mozilla.org/CA:EV_Revocation_Checking</span>, l'accès aux serveurs OCSP est donc indispensable.</p>

<p class="note">Pour plus d'informations sur le comportement des navigateurs en matière de vérification du statut des certificats, se reporter à cet article<span class="fn">http://blog.spiderlabs.com/2011/04/certificate-revocation-behavior-in-modern-browsers.html</span>.</p>

<h1 id="horodatage">Horodatage</h1>

<p>Dans ce chapitre, les profils retenus pour l'unité d'horodatage et les jetons d'horodatage sont ceux définis dans l'annexe 2 de l'annexe A12 du [RGS].</p>

<h2 id="horodatage-donnees">Horodatage de données</h2>

<h3 id="generation-certificat-horodatage">Génération du certificat de l'unité d'horodatage</h3>

<p>Générer un bi-clé RSA de 2048 bits pour l’unité d'horodatage.</p>

<pre><strong>$ openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048</strong>
..............................+++
......+++
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDIkMQ/ueoN/rag
2BHfa6SwKUtof2FgaTLyGJwzzBPbd0ITcSRZLw/otceBR1B9r18zLIF7dvG2IDgQ
e1Zwe1TmYAlgxRrZzyZz9zQtEfk/rxVkiZP6W4R/GL0igy+5+ob+NAn+UC2PZ6ff
2XVBogNpAbIUhNqhIj34YtcLMdyEH+h76rczwBNPFGVpKUsf/dHE/3+eAnbpJILz
IhJC5elY4winp01tNl2RGRfjZ77qoKFXf4Wf0Y/hZ+gOlQULGm0UMApp+34wHgFA
rTy3+80NeR1n/kdxq0+MsfO/5N2wK9KFnZPMy+AaTmahPTwo7K1KRWW5F6kV/aYa
WROoNXwVAgMBAAECggEBAL7TDgVby9b466XpLkgWUKDTCU4pM+rY7IHu7F9T4ejD
dPiug1jfMBHHMkRMJ8cNXlSAGcnwh1UzHmSAFOP8U/DEmueZYUyujPV01A21tiHj
YUVAqKxg+pU6Ymk9y+D0/g9KT9/JRS/V/aE7cxa5IOl9lYN0S9dXjwKOd+/MxvRk
/cxJIUt42ynbaO8ahFf53LOLW1YMkWj+ZwZRktyOFVZOEhSYOuVUd6fWYLLpSq58
O8Ud6cE7dv/lF8zqRDf2y29btzojZcj5XWoBN2hMGntdFSxPbAXjfZlqXGhXC4kA
jbTPu9oZQcKEq2mxWDsgCkJrGGeEn/pp488HFREwZsECgYEA/FdIPCY6janCDwr/
qQDbb2m8NofRfyrgKgIa4hzYfBHEcwZIuQ2aA6ZZmpRPZl2U8LEyoEsdxFXV8Q4N
8Sc6625lnmPIeoVD4GNuh02ZHb2i6VWKF0wnBbJj2tueegJl/Behqioidl5LdpLW
jwKWNoyXCdbNx8pVT+4TnXA4wMkCgYEAy3lJxM+3I72ujcyldc3JCRp32ZCanXJY
4BQDcnhGfJ93S+halTRhqXDm80Hd7uglHF3Why9aVVTZuT7oYCNh5O2qqrvNrBf3
Oipcnb6mkD4xVDJcLV2kZXR8kKYeWidUrSmvi8H1Tz7+lgkcJulT2u6QnVljNrAD
4dVJYM2F8u0CgYBXtRKzbWousRF1XxJLsLOUvwCfR4fmloWBtGeZrgME5LwOauG+
CF8+44QDeYc7gk1xd3WsR0+aXWdWONdZuZP+HsoNSot1InrcNFNHjg4pSy+jwIqV
3G83yLBycqFbsRe3jpMvbSO7Vr0OAq222WRSo30f+1xdFBOhC5QfxdDEGQKBgDSM
6K557xS+An0A46LfORKu0VFRdX1AcQ++W32O7rV1AfyK0ApE8wwt6pfc5RK0xhDj
c2qKokvzlB+xzZY2zSuw7ikWQ/I0ZleRZUYgXShXx6m1L/VPgAvr39gD70bdbZMj
dwEjYNXMsTfStoCeNlgO0S6yTVtsbjQ/P6pOqk+pAoGAF0WAMF9qvqefgy8X1yOr
UVQLY/vMT04wGQ8TxlWSdQ5+W5lTdfTp2itz4kZy0YQNOV5FmrQsdy+vzOCWKb88
gZcI0+y5YVVxdqgC2rr8Ss5i49lH8XivQoISMtES8ZSDhhxhru+SsTZiG8cUY63q
eUQ/xPQVKac394yeY8kcfs0=
-----END PRIVATE KEY-----</pre>

<p>Copier la clé ci-dessus dans un fichier nommé <code>tsa-key.pem</code> (<code>ts</code> pour <i>timestamp</i>
ou horodatage), ou utiliser la commande ci-dessus avec l’option <code>-out tsa-key.pem</code>
pour poursuivre avec une autre clé.</p>

<p>Générer la CSR, dans le fichier <code>tsa-req.pem</code>.</p>

<pre><strong>$ openssl req -new -key tsa-key.pem \
  -subj "/C=FR/O=Mon Entreprise/OU=0002 123456789/CN=OpenSSL TSA" -sha256 \
  -config req-empty.cnf -out tsa-req.pem</strong></pre>

<p>Créer le fichier de configuration <code>tsa-crt.cnf</code> suivant, définissant le profil du certificat de l'unité d'horodatage.</p>

<pre>[ts_ext]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid
keyUsage = critical,digitalSignature
certificatePolicies = \
  1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.4
crlDistributionPoints = URI:http://tiny.cc/LatestCRL
basicConstraints = critical,CA:FALSE
extendedKeyUsage = critical,timeStamping</pre>

<p>Générer aléatoirement le numéro de série du certificat de l'unité d'horodatage.</p>

<pre><strong>$ openssl rand -hex 8 -out ca-crt.srl</strong></pre>

<p>Déclencher la génération du certificat.</p>

<pre><strong>$ openssl x509 -req -in tsa-req.pem -extfile tsa-crt.cnf -extensions tsa_ext \
-CA ca-crt.pem -CAkey ca-key.pem -CAserial ca-crt.srl -sha256 -days 730 \
-out tsa-crt.pem</strong>
Signature ok
subject=/C=FR/O=Mon Entreprise/OU=0002 123456789/CN=OpenSSL TSA
Getting CA Private Key</pre>

<p>Afficher le contenu du certificat.</p>

<pre><strong>$ openssl x509 -in tsa-crt.pem -noout -text</strong>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            d3:b9:4f:04:dd:d1:a0:40
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=FR, O=Mon Entreprise, OU=0002 123456789, OU=OpenSSL Root CA
        Validity
            Not Before: Jun 16 20:34:01 2012 GMT
            Not After : Jun 16 20:34:01 2014 GMT
        Subject: C=FR, O=Mon Entreprise, OU=0002 123456789, CN=OpenSSL TSA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c8:90:c4:3f:b9:ea:0d:fe:b6:a0:d8:11:df:6b:
                    …
                    7c:15
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier:
                BA:0B:BB:AF:E3:25:46:56:FC:13:86:92:D2:15:40:62:DB:16:6A:4A
            X509v3 Authority Key Identifier:
                keyid:4C:6D:87:93:82:F7:2D:2C:07:23:A2:0F:E0:71:2D:17:3F:39:F3:8
F

            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Certificate Policies:
                Policy: 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224
.8393003.10972002.1.4

            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://tiny.cc/LatestCRL

            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: critical
                Time Stamping
    Signature Algorithm: sha256WithRSAEncryption
         0f:9a:d3:af:e4:56:65:ba:7c:3b:92:ca:a0:fe:2d:49:37:8d:
         …
         ed:c8:c9:9a</pre>

<h3 id="emission-jeton-horodatage">Émission d'un jeton d'horodatage</h3>

<p>Générer une requête d'horodatage portant sur le fichier <code>data.txt</code>.</p>

<pre><strong>$ openssl ts -query -data data.txt -sha256 -out data.tsq</strong></pre>

<p>Afficher le contenu de la requête, en notant que l'empreinte référencée est bien l'empreinte SHA-256 du fichier <code>data.txt</code>.</p>

<pre><strong>$ openssl ts -query -in data.tsq -text</strong>
Version: 1
Hash Algorithm: sha256
Message data:
    0000 - 89 bd 92 28 6d 6c 80 14-c0 60 30 b2 5f 8b 40 cc   ...(ml...`0._.@.
    0010 - 1d 56 56 d4 b3 b7 b4 83-18 74 f5 0d 6f 55 57 f3   .VV......t..oUW.
Policy OID: unspecified
Nonce: 0x4C815608C816687B
Certificate required: no
Extensions:</pre>

<p>Cette requête correspond au type <code>TimeStampReq</code> défini dans la RFC 3161, qui spécifie TSP (<i>Time-Stamp Protocol</i>, ou protocole d'horodatage).</p>

<p>Créer le fichier de configuration <code>tsa-ts.cnf</code> avec le contenu suivant, pour définir les caractéristiques du jeton d'horodatage.</p>

<pre>[tsa]
serial = tsa-ts.srl
certs = ca-crt.pem
crypto_device = builtin
default_policy = \
  1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.5
other_policies = \
  1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.5
digests = sha256</pre>

<p class="note">Contrairement à ce que laisse entendre la documentation de la commande <code>openssl ts</code>, tous les champs définis ci-dessus sont obligatoires si leur éventuelle option en ligne de commande équivalente n'a pas été utilisée.</p>

<p>Générer une réponse à partir de la requête.</p>

<pre><strong>$ openssl ts -reply -config tsa-ts.cnf -section tsa -queryfile data.tsq \
  -inkey tsa-key.pem -signer tsa-crt.pem -out data.tsr</strong>
Using configuration from tsa-ts.cnf
Warning: could not open file tsa-ts.srl for reading, using serial number: 1
Response has been generated.</pre>

<p>Afficher le contenu de la réponse.</p>

<pre><strong>$ openssl ts -reply -in data.tsr -text</strong>
Status info:
Status: Granted.
Status description: unspecified
Failure info: unspecified

TST info:
Version: 1
Policy OID: 1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.109
72002.1.5
Hash Algorithm: sha256
Message data:
    0000 - 89 bd 92 28 6d 6c 80 14-c0 60 30 b2 5f 8b 40 cc   ...(ml...`0._.@.
    0010 - 1d 56 56 d4 b3 b7 b4 83-18 74 f5 0d 6f 55 57 f3   .VV......t..oUW.
Serial number: 0x01
Time stamp: Jun 16 21:13:09 2012 GMT
Accuracy: unspecified
Ordering: no
Nonce: 0x4C815608C816687B
TSA: unspecified
Extensions:</pre>

<div class="note"><p><a name="hachage-horodatage"/>L'algorithme de hachage utilisé par <code>openssl ts</code> dans les jetons d'horodatage est codé en dur, et est SHA-1. La section de code concernée se situe dans le fichier source <code>crypto/ts/ts_rsp_sign.c</code>, dans la fonction <code>TS_RESP_sign()</code> :</p>
<pre>if (!(si = PKCS7_add_signature(p7, ctx->signer_cert, 
        ctx->signer_key, EVP_sha1())))</pre>
<p>Il n'est pas possible de modifier cet algorithme sans modifier et recompiler l'ensemble du code source d'OpenSSL. Une autre solution est de passer par la construction manuelle du jeton d'horodatage.</p></div>

<p>Valider la réponse par rapport à la requête d'horodatage.</p>

<pre><strong>$ openssl ts -verify -queryfile data.tsq -in data.tsr -CAfile ca-crt.pem \
  -untrusted tsa-crt.pem</strong>
Verification: OK</pre>

<p>La réponse correspond à la structure <code>TimeStampResp</code> de la RFC 3161, dont la syntaxe est la suivante :</p>

<pre>TimeStampResp ::= SEQUENCE {
   status                  PKIStatusInfo,
   timeStampToken          TimeStampToken     OPTIONAL
}</pre>

<p>Le jeton d'horodatage correspond au champ <code>timeStampToken</code> de cette structure. L'extraire à l'aide de la commande suivante.</p>

<pre><strong>$ openssl ts -reply -in data.tsr -token_out -out data.tst</strong></pre>

<p>Valider le jeton d'horodatage par rapport aux données faisant l'objet de l'horodatage.</p>

<pre><strong>$ openssl ts -verify -data data.txt -in data.tst -CAfile ca-crt.pem \
  -untrusted tsa-crt.pem -token_in</strong>
Verification: OK</pre>

<h2 id="serveur-horodatage">Serveur d'horodatage</h2>

<p>Certaines applications de signature électronique permettent d'interroger un serveur d'horodatage pour obtenir une réponse à une requête d'horodatage en ligne. Cette section propose un script Perl implémentant un serveur d'horodatage minimaliste capable de produire une réponse <code>TimeStampResp</code> à une requête <code>TimeStampReq</code>.</p>

<p>En pré-requis à l'utilisation de ce script, Perl doit être installé, ainsi que le module Perl <code>HTTP::Daemon</code><span class="fn">http://search.cpan.org/~gaas/HTTP-Daemon-6.01/</span>, qui inclus avec les distributions usuelles de Perl (y compris ActivePerl<span class="fn">http://www.activestate.com/activeperl</span> et Strawberry Perl<span class="fn">http://strawberryperl.com/</span> sous Windows).</p>

<p>Créer le fichier <code>tsadaemon.pl</code> suivant :</p>

<pre>use strict ;
use warnings ;

use HTTP::Daemon;

# Change values below as required
my $port = 80 ;

my $tsa_cnf_file = 'tsa-ts.cnf' ;
my $tsa_section = 'tsa' ;
my $tsa_key_file = 'tsa-key.pem' ;
my $tsa_crt_file = 'tsa-crt.pem' ;
# Change values above as required

my $tmp_infile = 'temp.tsq' ;
my $tmp_outfile = 'temp.tsr' ;

my $daemon = HTTP::Daemon->new(LocalPort => $port) || die;

print 'Timestamp server running at URL ' . $daemon->url . "\n";

while (my $conn = $daemon->accept) {
  while (my $req = $conn->get_request) {
    if ($req->method eq 'POST') {
      # Write binary TimeStampReq from incoming HTTP POST request
      # to a temporary file
      open REQ, '>'.$tmp_infile ;
      binmode REQ ;
      print REQ $req->content ;
      close REQ ;
      
      # Generate TimeStampResp from TimeStampReq by invoking openssl
      unlink $tmp_outfile if -e $tmp_outfile ;
      system ('openssl', 'ts', '-reply', '-config', $tsa_cnf_file,
        '-section', $tsa_section, '-queryfile', $tmp_infile,
        '-inkey', $tsa_key_file, '-signer', $tsa_crt_file,
        '-out', $tmp_outfile) ;
      
      # If a file was generated by the previous command, then send it back to
      # the client...
      if (-e $tmp_outfile) {
        $conn->send_status_line ;
        $conn->send_header('Content-Type', 'application/timestamp-reply') ;
        $conn->send_header('Content-Length', -s $tmp_outfile) ;
        $conn->send_crlf ;
        $conn->send_file($tmp_outfile) ;
        $conn->close ;
      }
      # ... otherwise send an HTTP error
      else {
          $conn->send_error() ;
      }
    }
    else {
        $conn->send_error()
    }
  }
  $conn->close;
  undef($conn);
}</pre>

<p>Le serveur d'horodatage peut être interrogé à l'aide d'une requête POST HTTP sur le port 80 (par défaut, modifier la variable <code>$port</code> au besoin), et produit — si tout se passe correctement — une réponse HTTP avec pour en-tête <code>Content-Type: application/timestamp-reply</code>, comme prévu par la section 3.4 de la RFC 3161.</p>

<p>Placer le script dans le même répertoire que le fichier de configuration (<code>tsa-ts.cnf</code> par défaut, dans la variable <code>$tsa_cnf_file</code>), le fichier de la clé privée (<code>tsa-key.pem</code>, défini par la variable <code>$tsa_key_file</code>) et le fichier PEM du certificat de l'unité d'horodatage (<code>tsa-crt.pem</code>, variable <code>$tsa_crt_file</code>). Au besoin modifier la variable <code>$tsa_section</code> si la section du fichier de configuration pour l'unité d'horodatage est différente de <code>tsa</code>. Placer dans le même répertoire les fichiers référencés par cette section du fichier de configuration (en particulier : numéro de série et certificats supplémentaires).</p>

<p>Démarrer le serveur d'horodatage :</p>

<pre><strong>$ perl tsadaemon.pl</strong>
Timestamp server running at URL http://monserveur/</pre>

<p>Tester le serveur d'horodatage en lui soumettant une requête d'horodatage à l'aide du client en ligne de commande <code>curl</code> (cf. section <a href="#serveurs-ocsp" class="section"/>) :</p>

<pre><strong>$ curl -v -H "Content-Type: application/timestamp-query" \
  --data-binary @data.tsq -o data.tsadaemon.tsr http://localhost/</strong>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   802  100   736  100    66   1004     90 --:--:-- --:--:-- --:--:--  1004</pre>

<p>Afficher la réponse contenue dans le fichier <code>data.tsadaemon.tsr</code> et vérifier qu'il est valide, en utilisant les commandes proposées précédemment.</p>

<p class="note">Le serveur d'horodatage proposé est volontairement extrêmement basique. Parmi ses limites, il ne supporte pas les connexions simultanées, ne vérifie pas que l'en-tête HTTP <code>Content-Type: application/timestamp-query</code> est présente, ne contrôle pas les données reçues avant de les écrire et de les envoyer à la commande <code>openssl</code>, et ne verrouille pas ni ne supprime les fichiers temporaires qu'il utilise.</p>

<h2 id="construction-jeton-horodatage">Construction d'un jeton d'horodatage</h2>

<p>Un jeton d'horodatage conforme à la RFC 3161 est une signature électronique au format CMS, enveloppant notamment les informations contenues dans la requête à laquelle fait suite le jeton ainsi que la data et l'heure. Les méthodes utilisées dans la section <a href="#construction-signature-pkcs7-cms" class="section"/> sont donc réutilisables pour constituer le jeton d'horodatage. La structure <code>TimeStampToken</code> à générer pour reconstruire le jeton d'horodatage est la suivante (les champs optionnels non utilisés ont été omis) :</p>

<pre>TimeStampToken ::= SEQUENCE {
  contentType ContentType,
  content [0] EXPLICIT SEQUENCE {
    version CMSVersion,
    digestAlgorithms SET OF DigestAlgorithmIdentifier,
    encapContentInfo SEQUENCE {
      eContentType ContentType,
      eContent [0] EXPLICIT OCTET STRING OPTIONAL
    },
    signerInfos SET OF SEQUENCE {
      version CMSVersion,
      sid SignerIdentifier,
      digestAlgorithm DigestAlgorithmIdentifier,
      signedAttrs [0] IMPLICIT SET OF Attribute OPTIONAL,
      signatureAlgorithm SignatureAlgorithmIdentifier,
      signature SignatureValue,
    }
  }
}</pre>

<p>Les données enveloppées par la signature électronique, ou plus exactement les données dont l'empreinte est référencée dans les attributs signés de la signature, est porté par le champ <code>eContent</code>, qui est le codage DER de la structure <code>TSTInfo</code> suivante :</p>

<pre>TSTInfo ::= SEQUENCE {
  version INTEGER  { v1(1) },
  policy TSAPolicyId,
  messageImprint SEQUENCE {
    hashAlgorithm AlgorithmIdentifier,
    hashedMessage OCTET STRING
  },
  serialNumber INTEGER,
  genTime GeneralizedTime,
  nonce INTEGER OPTIONAL,
}</pre>

<h3 id="constitution-tstinfo">Constitution de la structure <code>TSTInfo</code></h3>

<p>Créer le fichier <code>tst-TSTInfo.asn.cnf</code> ci-dessous, représentant la structure <code>TSTInfo</code>.</p>

<pre>asn1 = SEQUENCE:tstInfo

[tstInfo]
version = INTEGER:1
policy = OID:\
1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.5
messageImprint = SEQUENCE:tsq_messageImprint
serialNumber = INTEGER:1
genTime = GENERALIZEDTIME:20120616211309Z
nonce = INTEGER:0x4C815608C816687B

[tsq_messageImprint]
hashAlgorithm = SEQUENCE:tsq_hashAlgorithm
hashedMessage = FORMAT:HEX,OCTETSTRING:\
89bd92286d6c8014c06030b25f8b40cc1d5656d4b3b7b4831874f50d6f5557f3

[tsq_hashAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Dans ce fichier, les champs <code>messageImprint</code> et <code>nonce</code> reprennent les valeurs présentes dans la requête d'horodatage. En particulier, le champ <code>hashedMessage</code> contient l'empreinte SHA-256 des données faisant l'objet de l'horodatage.</p>

<p>Générer le codage DER de la structure <code>TSTInfo</code>.</p>

<pre><strong>$ openssl asn1parse -genconf tst-TSTInfo.asn.cnf -i -out tst-TSTInfo.der</strong>
    0:d=0  hl=2 l= 122 cons: SEQUENCE
    2:d=1  hl=2 l=   1 prim:  INTEGER           :01
    5:d=1  hl=2 l=  36 prim:  OBJECT            :1.2.840.113556.1.8000.2554.4731
1.54169.61548.20478.40224.8393003.10972002.1.5
   43:d=1  hl=2 l=  49 cons:  SEQUENCE
   45:d=2  hl=2 l=  13 cons:   SEQUENCE
   47:d=3  hl=2 l=   9 prim:    OBJECT            :sha256
   58:d=3  hl=2 l=   0 prim:    NULL
   60:d=2  hl=2 l=  32 prim:   OCTET STRING      [HEX DUMP]:89BD92286D6C8014C060
30B25F8B40CC1D5656D4B3B7B4831874F50D6F5557F3
   94:d=1  hl=2 l=   1 prim:  INTEGER           :01
   97:d=1  hl=2 l=  15 prim:  GENERALIZEDTIME   :20120616211309Z
  114:d=1  hl=2 l=   8 prim:  INTEGER           :4C815608C816687B</pre>

<p>Calculer l'empreinte SHA-1 du fichier résultant.</p>

<pre><strong>$ openssl sha1 tst-TSTInfo.der</strong>
SHA1(tst-TSTInfo.der)= 0f6d6f384c1cba1e97921fff3d192920af7feae8</pre>

<p class="note">Comme indiqué dans la note page <a href="#hachage-horodatage" class="page"/>, OpenSSL utilise l'algorithme de hachage SHA-1 dans les jetons d'horodatage. Le lecteur peut remplacer cet algorithme par SHA-256 (et toutes les références à <code>sha1</code> par <code>sha256</code>) s'il souhaite générer un jeton d'horodatage conforme au RGS.</p>

<h3 id="constitution-signature-attributs-signes">Constitution et signature des attributs signés</h3>

<p>Créer le fichier <code>tst-signedAttrs.asn.cnf</code> suivant, qui décrit le <code>SET OF Attribute</code> constituant les attributs signés du jeton d'horodatage.</p>

<pre>asn1 = SET:tst_signedAttrs

[tst_signedAttrs]
attr_contentType = SEQUENCE:tst_attr_contentType
attr_signingTime = SEQUENCE:tst_attr_signingTime
attr_messageDigest = SEQUENCE:tst_attr_messageDigest
attr_signingCertificate = SEQUENCE:tst_attr_signingCertificate

[tst_attr_contentType]
attrType = OID:contentType
attrValues = SET:tst_attr_contentType_values

[tst_attr_contentType_values]
contentType = OID:id-smime-ct-TSTInfo

[tst_attr_signingTime]
attrType = OID:signingTime
attrValues = SET:tst_attr_signingTime_values

[tst_attr_signingTime_values]
attr_signingTime_value = UTCTIME:120616211309Z

[tst_attr_messageDigest]
attrType = OID:messageDigest
attrValues = SET:tst_attr_messageDigest_values

[tst_attr_messageDigest_values]
messageDigest = FORMAT:HEX,OCTETSTRING:\
0f6d6f384c1cba1e97921fff3d192920af7feae8

[tst_attr_signingCertificate]
attrType = OID:id-smime-aa-signingCertificate
attrValues = SET:tst_attr_signingCertificate_values</pre>

<p>Les trois premiers attributs ont été vus dans la section <a href="#construction-signature-pkcs7-cms" class="section"/>. Une petite mention toutefois pour l'attribut <code>messageDigest</code>, qui contient l'empreinte de la structure <code>TSTInfo</code> générée précédemment, c'est-à-dire l'empreinte de la valeur de l'<code>OCTET STRING</code> constituant le champ <code>eContent</code>.</p>

<p>L'attribut <code>signingCertificate</code> référence le certificat de signature de l'unité d'horodatage, et est de type <code>SigningCertificate</code>, défini par la RFC 2634, avec la structure ASN.1 suivante :</p>

<pre>SigningCertificate ::=  SEQUENCE {
  certs SEQUENCE OF ESSCertID,
  policies SEQUENCE OF PolicyInformation OPTIONAL
}

ESSCertID ::=  SEQUENCE {
  certHash Hash,
  issuerSerial IssuerSerial OPTIONAL
}

Hash ::= OCTET STRING</pre>

<p>La valeur du champ <code>certHash</code> est l'empreinte SHA-1 du codage DER du certificat considéré. Calculer cette empreinte.</p>

<pre><strong>$ openssl x509 -in tsa-crt.pem -outform DER | openssl sha1</strong>
(stdin)= 4328a6e719c924d2c414c24ae71950939561c509</pre>

<p>Compléter le fichier de configuration <code>tst-signedAttrs.asn.cnf</code> avec les sections suivantes :</p>

<pre>[tst_attr_signingCertificate_values]
signingCertificate = SEQUENCE:tst_signingCertificate_certs

[tst_signingCertificate_certs]
certs = SEQUENCE:tst_signingCertificate_essCertIDs

[tst_signingCertificate_essCertIDs]
essCertID = SEQUENCE:tst_signingCertificate_essCertID

[tst_signingCertificate_essCertID]
certHash = FORMAT:HEX,OCTETSTRING:4328a6e719c924d2c414c24ae71950939561c509</pre>

<p>Générer à présent le codage DER des attributs signés.</p>

<pre><strong>$ openssl asn1parse -genconf tst-signedAttrs.asn.cnf -i -out tst-signedAttrs.der</strong>
    0:d=0  hl=3 l= 140 cons: SET
    3:d=1  hl=2 l=  26 cons:  SEQUENCE
    5:d=2  hl=2 l=   9 prim:   OBJECT            :contentType
   16:d=2  hl=2 l=  13 cons:   SET
   18:d=3  hl=2 l=  11 prim:    OBJECT            :id-smime-ct-TSTInfo
   31:d=1  hl=2 l=  28 cons:  SEQUENCE
   33:d=2  hl=2 l=   9 prim:   OBJECT            :signingTime
   44:d=2  hl=2 l=  15 cons:   SET
   46:d=3  hl=2 l=  13 prim:    UTCTIME           :120616211309Z
   61:d=1  hl=2 l=  35 cons:  SEQUENCE
   63:d=2  hl=2 l=   9 prim:   OBJECT            :messageDigest
   74:d=2  hl=2 l=  22 cons:   SET
   76:d=3  hl=2 l=  20 prim:    OCTET STRING      [HEX DUMP]:0F6D6F384C1CBA1E979
21FFF3D192920AF7FEAE8
   98:d=1  hl=2 l=  43 cons:  SEQUENCE
  100:d=2  hl=2 l=  11 prim:   OBJECT            :id-smime-aa-signingCertificate

  113:d=2  hl=2 l=  28 cons:   SET
  115:d=3  hl=2 l=  26 cons:    SEQUENCE
  117:d=4  hl=2 l=  24 cons:     SEQUENCE
  119:d=5  hl=2 l=  22 cons:      SEQUENCE
  121:d=6  hl=2 l=  20 prim:       OCTET STRING      [HEX DUMP]:4328A6E719C924D2
C414C24AE71950939561C509</pre>

<p>En préparation de la signature des attributs signés, calculer l'empreinte SHA-1 du fichier DER obtenu.</p>

<pre><strong>$ openssl sha1 tst-signedAttrs.der</strong>
SHA1(tst-signedAttrs.der)= efa58d98e76914770500fb223052bb0b5b94915b</pre>

<p>Créer le fichier <code>tst-DigestInfo.asn.cnf</code> suivant, représentant la structure <code>DigestInfo</code> associée à cette empreinte :</p>

<pre>asn1 = SEQUENCE:digestInfo

[digestInfo]
digestAlgorithm = SEQUENCE:digestAlgorithm
digest = FORMAT:HEX,OCTETSTRING:\
efa58d98e76914770500fb223052bb0b5b94915b

[digestAlgorithm]
algorithm = OID:sha1
parameters = NULL</pre>

<p>Générer le codage DER de cette structure <code>DigestInfo</code> :</p>

<pre><strong>$ openssl asn1parse -genconf tst-DigestInfo.asn.cnf -i -out tst-DigestInfo.der</strong>
    0:d=0  hl=2 l=  33 cons: SEQUENCE
    2:d=1  hl=2 l=   9 cons:  SEQUENCE
    4:d=2  hl=2 l=   5 prim:   OBJECT            :sha1
   11:d=2  hl=2 l=   0 prim:   NULL
   13:d=1  hl=2 l=  20 prim:  OCTET STRING      [HEX DUMP]:EFA58D98E76914770500F
B223052BB0B5B94915B</pre>

<p>Signer ce fichier à l'aide de la clé privée de l'unité d'horodatage, et produire la représentation hexadécimale de cette signature.</p>

<pre><strong>$ openssl pkeyutl -sign -in tst-DigestInfo.der -inkey tsa-key.pem \
  | od -tx1 -An -w | tr -d " " | sed 's/$/\\/'</strong>
222f835b63d35010e14941c4700ca3f1c07808051760e33820c9538e63a327f2\
19a1683e57ca75d2e79f67e1a730ca1ffc2c257c6a939405abdfde4e4aa24961\
9057a161e9ddf6ebc8f4f503c2f401fe47b8e21fcf70e96316646a026602bd74\
998905b6b9cf9d3a5cc00fa91ce90d30d90dc8820695b4782b7a0888cc06a948\
1707de349c1dfb2518e5dce1a2613e70627ee723dfa98fabe03e0cf64a812018\
5eda49ad4251cdccc3aa9d9beb31a79f13987562c02f4de179a2b967a9db0a0d\
6502d0baf2f4f9a1fb118244f47e0371453181f1ba5994f9bfac4ee2970a0e2f\
6d758a07b92bad329538dfc77ded7e594276f5410594c167c4b3de928c53b1b3\</pre>

<h3 id="consolidation-timestamptoken">Consolidation de la structure <code>TimeStampToken</code></h3>

<p>Créer le fichier <code>tst-TimeStampToken.asn.cnf</code>, avec le contenu suivant.</p>

<pre>asn1 = SEQUENCE:tst_timeStampToken

[tst_timeStampToken]
contentType = OID:pkcs7-signedData
content = EXPLICIT:0,SEQUENCE:tst_content

[tst_content]
version = INTEGER:3
digestAlgorithms = SET:tst_digestAlgorithms
encapContentInfo = SEQUENCE:tst_encapContentInfo
signerInfos = SET:tst_signerInfos

[tst_digestAlgorithms]
digestAlgorithm = SEQUENCE:tst_digestAlgorithm

[tst_digestAlgorithm]
algorithm = OID:sha1
parameters = NULL

[tst_encapContentInfo]
eContentType = OID:id-smime-ct-TSTInfo
eContent = EXPLICIT:0,OCTWRAP,SEQUENCE:tstInfo</pre>

<p>Ajouter ensuite les sections du fichier <code>tst-TSTInfo.asn.cnf</code>.</p>

<p>Poursuivre avec les sections suivantes :</p>

<pre>[tst_signerInfos]
signerInfo = SEQUENCE:tst_signerInfo

[tst_signerInfo]
version = INTEGER:1
sid = SEQUENCE:tst_sid
digestAlgorithm = SEQUENCE:tst_signerInfo_digestAlgorithm
signedAttrs = IMPLICIT:0,SET:tst_signedAttrs
signatureAlgorithm = SEQUENCE:tst_signerInfo_signatureAlgorithm
signature = FORMAT:HEX,OCTETSTRING:\
222f835b63d35010e14941c4700ca3f1c07808051760e33820c9538e63a327f2\
19a1683e57ca75d2e79f67e1a730ca1ffc2c257c6a939405abdfde4e4aa24961\
9057a161e9ddf6ebc8f4f503c2f401fe47b8e21fcf70e96316646a026602bd74\
998905b6b9cf9d3a5cc00fa91ce90d30d90dc8820695b4782b7a0888cc06a948\
1707de349c1dfb2518e5dce1a2613e70627ee723dfa98fabe03e0cf64a812018\
5eda49ad4251cdccc3aa9d9beb31a79f13987562c02f4de179a2b967a9db0a0d\
6502d0baf2f4f9a1fb118244f47e0371453181f1ba5994f9bfac4ee2970a0e2f\
6d758a07b92bad329538dfc77ded7e594276f5410594c167c4b3de928c53b1b3

[tst_sid]
issuer = SEQUENCE:tst_signerInfo_issuer
serial = INTEGER:0xd3b94f04ddd1a040

[tst_signerInfo_issuer]
issuer_C_RDN = SET:issuer_C_RDN
issuer_O_RDN = SET:issuer_O_RDN
issuer_OU1_RDN = SET:issuer_OU1_RDN
issuer_OU2_RDN = SET:issuer_OU2_RDN

[tst_signerInfo_digestAlgorithm]
algorithm = OID:sha1
parameters = NULL

[tst_signerInfo_signatureAlgorithm]
algorithm = OID:rsaEncryption
parameters = NULL</pre>

<p>Ci-dessus, le champ <code>signature</code> contient la représentation hexadécimale de la signature des attributs signés, telle qu'obtenue précédemment. Le champ <code>serial</code> contient le numéro de série du certificat de l'unité d'horodatage (qui peut extrait à l'aide de la commande <code>openssl x509 -in tsa-crt.pem -noout -serial</code>).</p>

<p>Les sections ci-dessous sont reprises des fichiers de configuration des chapitres précédents.</p>

<pre>[issuer_C_RDN]
issuer_C_ATV = SEQUENCE:issuer_C_ATV

[issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[issuer_O_RDN]
issuer_O_ATV = SEQUENCE:issuer_O_ATV

[issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[issuer_OU1_RDN]
issuer_OU1_ATV = SEQUENCE:issuer_OU1_ATV

[issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[issuer_OU2_RDN]
issuer_OU2_ATV = SEQUENCE:issuer_OU2_ATV

[issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA</pre>

<p>Ajouter enfin les sections du fichier <code>tst-signedAttrs.asn.cnf</code>.</p>

<p>Générer le jeton d'horodatage.</p>

<pre><strong>$ openssl asn1parse -genconf tst-TimeStampToken.asn.cnf -i \
  -out tst-TimeStampToken.der</strong></pre>
  
<p>Vérifier que le fichier généré est un jeton d'horodatage valide pour le fichier de données <code>data.txt</code>.</p>

<pre><strong>$ openssl ts -verify -data data.txt -in tst-TimeStampToken.der \
  -CAfile ca-crt.pem -untrusted tsa-crt.pem</strong>
Verification: OK</pre>

<p class="note">Si les valeurs n'ont pas été modifiées par rapport au jeton d'horodatage de référence <code>data.tst</code>, vérifier, par exemple en comparant les empreintes, que le jeton d'horodatage initial et celui généré sont identiques.</p>

<h1 id="cades">Signature électronique avancée — CAdES</h1>

<p>La série des normes AdES (<i>Advanced Electronic Signature</i> ou signature électronique avancée) — XAdES, CAdES et PAdES — a été définie par l'ETSI pour permettre la production de signatures électroniques avancées, au sens défini par la directive 1999/93/EC du Parlement européen et du conseil de l'Union européenne<span class="fn">http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2000:013:0012:0020:FR:PDF</span>, dont l'objectif est de favoriser et d'encourager la reconnaissance légale de la signature électronique en Europe, en particulier en permettant de prolonger la validité des signatures électroniques au-delà de leur durée de vie « naturelle » (par défaut, tant que le certificat du signataire est valide).</p>

<div class="longnote">
<div class="notetitle">PAdES</div>
<p>Héritant à la fois de CAdES et de PDF<span class="fn">http://www.adobe.com/devnet/pdf/pdf_reference.html</span>, la norme PAdES<span class="fn">http://www.padesfaq.net/ (non officiel)</span> (<i>PDF Advanced Electronic Signature</i>) n'a pas été abordée dans ce document, la constitution de ces signatures n'étant pas possible à l'aide exclusive d'outils en ligne de commande librement disponibles.</p>

<p>Depuis la version 9, Adobe Reader est en mesure de produire des signature PAdES<span class="fn">http://blogs.adobe.com/security/ConfigurationofAdobeAcrobat9forPAdES.pdf</span> sur des documents possédant le droit Reader étendu (<i>extended Reader right</i>) de signature, lequel peut être accordé<span class="fn">http://blog.tallcomponents.com/2011/02/reader-extensions-under-hood.html</span> par Adobe Acrobat Professional ou AdobeAdobe LiveCycle Reader Extensions.</p>

<p>Sans ces logiciels, la piste recommandée est d'utiliser la bibliothèque iText<span class="fn">http://itextpdf.com</span>, nominalement en Java, et portée en C# sous le nom d'iTextSharp : la documentation de référence d'iText est le livre <i>iText in Action</i>, dont la section 12.4 de la deuxième édition concerne la signature électronique de fichiers PDF et évoque brièvement PAdES. Le lecteur intéressé peut se reporter au code source Java associé<span class="fn">http://itextpdf.com/book/chapter.php?id=12</span> (des exemples de signature avec inclusion de jetons d'horodatage et de jetons OCSP sont proposés), ainsi qu'aux exemples de code source Java et C# proposés par Paulo Soares<span class="fn">http://itextpdf.sourceforge.net/howtosign.html</span>.</p>
</div>

<p>La norme CAdES (spécifiée dans le document ETSI portant la référence TS 101 733) définit un ensemble de propriétés, dites qualifiantes, qui peuvent être incluses dans une signature électronique CMS, et dont certaines sont signées avec les données.</p>

<p>Plusieurs versions de CAdES coexistent : la version 1.7.4 est la plus facilement récupérable, ayant été reprise par l'IETF dans la RFC 5126 (elle-même une mise à jour de la RFC 3126 qui correspond à la version 1.2.2 de CAdES), la version 1.8.1 est identifiée comme étant la version en cours sur le portail de la signature électronique de l'ETSI <span class="fn">http://www.etsi.org/WebSite/Technologies/ElectronicSignature.aspx</span>, la version 1.8.4 est la dernière version de la branche 1.x de la norme, et la version 2.1.1 de mars 2012 est la dernière version à la date de rédaction. Ci-après, la version 2.1.1 est utilisée (récupérer la spécification à l'aide d'une recherche sur le mot clé « CAdES » dans le moteur de recherche proposé par l'ETSI<span class="fn">http://webapp.etsi.org/WorkProgram/expert/queryform.asp</span>).</p>

<p>La version 2.1.1 de la norme CAdES définit plusieurs formats de signature électronique :</p>

<ul>
<li>CAdES-BES (<i>Basic Electronic Signature</i>, ou signature électronique de base) inclut le certificat du signataire dans les attributs signés de CMS, et permet d'intégrer une contresignature en tant que propriété non signée.</li>
<li>CAdES-EPES (<i>Explicit Policy based Electronic Signature</i>, ou signature électronique avec politique explicite) inclut dans les propriétés signées l'identifiant d'une politique de signature, qui doit être utilisée pour valider la signature électronique.</li>
<li>CAdES-T (T pour <i>time</i>, ou heure) intègre une heure de signature fiable dans les propriétés non signées.</li>
<li>CAdES-C (C pour <i>complete validation data references</i>, ou références complètes aux données de validation) complète le format CAdES-T en référençant, au sein de propriétés non signées, les certificats (hors certificat de signature) et informations de révocation (listes de certificats révoqués et jetons OCSP) permettant de valider la signature électronique.</li>
<li>CAdES-X Long (<i>extended long</i>, ou format long étendu) complète une structure CAdES-C avec les données de validation référencées.</li>
<li>CAdES-X (<i>extended with time</i>, ou étendu avec heure) ajoute à une structure CAdES-C un jeton d'horodatage portant soit sur la structure CAdES-C complète (CAdES-X de type 1), soit sur les références aux données de validation uniquement (CAdES-X de type 2).</li>
<li>CAdES-X Long Type 1 et CAdES-X Long Type 2 (<i>extended long with time</i>, ou format long étendu avec heure) ajoutent à une structure CAdES-C les informations introduites par les formats CAdES-X Long et CAdES-X de type 1 ou de type 2.</li>
<li>CAdES-A (<i>archival form</i>, ou format d'archivage) ajoute aux propriétés non signées d'une structure CAdES-X Long (de base, de type 1 ou de type 2) ou CAdES-A un ou plusieurs jetons d'horodatage de manière à sceller la signature électronique dans la durée.</li>
<li>CAdES-LT (<i>long-term form</i>, ou format long terme), introduit dans la version 2.1.1, a le même objectif que CAdES-A, mais permet d'enrichir une signature CAdES-T (ou plus) au lieu d'une signature CAdES-X Long (ou plus), et est donc bien plus simple à mettre en œuvre.</li>
</ul>

<p class="note">La conformité à la norme CAdES n'impose pas l'implémentation des formats CAdES-X et supérieurs.</p>

<p>La suite de ce chapitre s'intéresse à la construction d'une signature CAdES-LT. Pour cela, le fichier de configuration ASN.1 utilisé pour construire une signature CMS dans la section <a href="#construction-signature-pkcs7-cms" class="section"/> est adapté et complété avec les éléments nécessaires à la constitution d'une structure CAdES-BES, puis celle-ci est successivement enrichie avec les données permettant d'obtenir une signature avancée au format CAdES-T, puis CAdES-LT.</p>

<h2 id="cades-bes">Constitution de la structure CAdES-BES</h2>

<p>La démarche de constitution de la structure CAdES-BES est analogue à la construction d'une signature électronique PKCS#7/CMS, tel que décrit dans la section <a href="#construction-signature-pkcs7-cms" class="section"/> : constituer et signer les attributs signés, puis créer la structure <code>SignerInfo</code>, et enfin consolider la structure CAdES-BES.</p>

<h3 id="cades-bes-constitution-attributs-signes">Constitution des attributs signés</h3>

<p>CAdES-BES enrichit une structure CMS avec les attributs signés <code>contentType</code>, <code>messageDigest</code>, et <code>signingCertificate</code> ou <code>SigningCertificateV2</code>. Les deux premiers sont déjà inclus dans la structure CMS constituée dans la section <a href="#construction-signature-pkcs7-cms" class="section"/>. Les attributs <code>signingCertificate</code> et <code>SigningCertificateV2</code> permettent d'identifier le certificat du signataire à l'aide de son empreinte (ce mécanisme a été utilisé précédemment, dans la section <a href="#constitution-signature-attributs-signes" class="section"/>, pour référencer le certificat de l'unité d'horodatage dans un jeton d'horodatage) : dans le cas où l'algorithme de hachage choisi est SHA-1, l'attribut <code>signingCertificate</code> doit être utilisé, sinon c'est l'attribut <code>SigningCertificateV2</code> qui doit être utilisé. Dans le cas présent, l'algorithme de hachage choisi est SHA-256, il reste simplement à ajouter à la structure CMS initiale l'attribut signé <code>signingCertificateV2</code> contenant le certificat du signataire pour obtenir une signature CAdES-BES.</p>

<p>L'attribut <code>signingCertificateV2</code> est défini dans la RFC 5035. Sa structure est la suivante :</p>

<pre>SigningCertificateV2 ::= SEQUENCE {
  certs SEQUENCE OF
    SEQUENCE {
      hashAlgorithm AlgorithmIdentifier
        DEFAULT {algorithm id-sha256},
      certHash OCTET STRING,
      issuerSerial SEQUENCE {
        issuer GeneralNames,
        serialNumber CertificateSerialNumber
      } OPTIONAL
    },
  policies SEQUENCE OF PolicyInformation OPTIONAL
}</pre>

<p>Il est choisi d'omettre les éléments optionnels ainsi que le champ <code>hashAlgorithm</code> (l'algorithme par défaut, SHA-256, est utilisé). La structure à générer pour l'attribut signé <code>SigningCertificateV2</code> est donc la suivante :</p>

<pre>SigningCertificateV2 ::= SEQUENCE {
  certs SEQUENCE OF
    SEQUENCE {
      certHash OCTET STRING,
    },
}
</pre>

<p>La valeur du champ <code>certHash</code> est l'empreinte SHA-256 du codage DER du certificat du signataire.</p>

<p>Calculer cette empreinte.</p>

<pre><strong>$ openssl sha256 ee-crt-authsig.pem</strong>
SHA256(ee-crt-authsig.pem)= d2df6647707afb2911a96e3d619aeebe79e2141db177fcd127f3
295075e3e39d</pre>

<p>Copier le fichier <code>sig-p7.explicit-signedAttrs.asn.cnf</code> créé dans la section <a href="#verification-manuelle-signature" class="section"/> sous le nom <code>data.cades-bes.signedAttrs.asn.cnf</code>, et ajouter à ce dernier les sections suivantes, en reportant la valeur obtenue ci-dessus dans le champ <code>certHash</code> de la section <code>signingCertificateV2_ESSCertIDv2</code> :</p>

<pre>[attr_signingCertificateV2]
attrType = OID:SigningCertificateV2
attrValues = SET:attr_signingCertificateV2_values

[attr_signingCertificateV2_values]
attr_signingCertificateV2_value = SEQUENCE:signingCertificateV2

[signingCertificateV2]
certs = SEQUENCE:signingCertificateV2_ESSCertIDv2s

[signingCertificateV2_ESSCertIDv2s]
signingCertificateV2_ESSCertIDv2 = SEQUENCE:signingCertificateV2_ESSCertIDv2

[signingCertificateV2_ESSCertIDv2]
certHash = FORMAT:HEX,OCTETSTRING:\
d2df6647707afb2911a96e3d619aeebe79e2141db177fcd127f3295075e3e39d</pre>

<p>Ajouter ensuite la ligne en gras ci-dessous dans la section <code>signedAttrs</code> :</p>

<pre>[signedAttrs]
attr_contentType = SEQUENCE:attr_contentType
attr_signingTime = SEQUENCE:attr_signingTime
attr_messageDigest = SEQUENCE:attr_messageDigest
<strong>attr_signingCertificateV2 = SEQUENCE:attr_signingCertificateV2</strong></pre>

<p class="note">L'attribut contenant la date et heure de signature (champ <code>attr_signingTime</code>) pourrait être supprimé, n'étant pas requis par CAdES-BES.</p>

<p>L'OID correspondant à l'attribut <code>SigningCertificateV2</code> n'est pas connu d'OpenSSL. Créer le fichier <code>cades-oid.tsv</code> suivant pour le définir :</p>

<pre>1.2.840.113549.1.9.16.2.47  id-aa-signingCertificateV2  SigningCertificateV2</pre>

<p class="note">La commande <code>openssl asn1parse -genconf</code> semble imposer un retour chariot simple de type UNIX (<code>\n</code>) ou Mac (<code>\r</code>) en fin de ligne, le retour chariot double de Windows (<code>\n\r</code>) provoquant une erreur. Sous Windows, si l'éditeur de texte ne permet pas de convertir les caractères de fin de ligne, alors utiliser la commande <code>tr -d "\r"</code> pour remplacer les retours chariot par des <code>\n</code> simples.</p>

<p>Générer la représentation DER de la structure <code>SET of Attributes</code>, en n'oubliant pas de référencer le fichier d'OID supplémentaires créé ci-dessus :</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-bes.signedAttrs.asn.cnf -i \
  -oid cades-oid.tsv -out data.cades-bes.signedAttrs.der</strong>
    0:d=0  hl=3 l= 162 cons: SET
    3:d=1  hl=2 l=  24 cons:  SEQUENCE
    5:d=2  hl=2 l=   9 prim:   OBJECT            :contentType
   16:d=2  hl=2 l=  11 cons:   SET
   18:d=3  hl=2 l=   9 prim:    OBJECT            :pkcs7-data
   29:d=1  hl=2 l=  28 cons:  SEQUENCE
   31:d=2  hl=2 l=   9 prim:   OBJECT            :signingTime
   42:d=2  hl=2 l=  15 cons:   SET
   44:d=3  hl=2 l=  13 prim:    UTCTIME           :120427191932Z
   59:d=1  hl=2 l=  47 cons:  SEQUENCE
   61:d=2  hl=2 l=   9 prim:   OBJECT            :messageDigest
   72:d=2  hl=2 l=  34 cons:   SET
   74:d=3  hl=2 l=  32 prim:    OCTET STRING      [HEX DUMP]:89BD92286D6C8014C06
030B25F8B40CC1D5656D4B3B7B4831874F50D6F5557F3
  108:d=1  hl=2 l=  55 cons:  SEQUENCE
  110:d=2  hl=2 l=  11 prim:   OBJECT            :SigningCertificateV2
  123:d=2  hl=2 l=  40 cons:   SET
  125:d=3  hl=2 l=  38 cons:    SEQUENCE
  127:d=4  hl=2 l=  36 cons:     SEQUENCE
  129:d=5  hl=2 l=  34 cons:      SEQUENCE
  131:d=6  hl=2 l=  32 prim:       OCTET STRING      [HEX DUMP]:D2DF6647707AFB29
11A96E3D619AEEBE79E2141DB177FCD127F3295075E3E39D</pre>

<h3 id="cades-bes-signature-attributs-signes">Signature des attributs signés</h3>

<p>Le fichier généré doit désormais être signé pour être inclus dans le champ <code>signature</code> de la structure <code>SignerInfo</code>.</p>

<p>Calculer l'empreinte SHA-256 de ce fichier.</p>

<pre><strong>$ openssl sha256 data.cades-bes.signedAttrs.der</strong>
SHA256(data.cades-bes.signedAttrs.der)= 91c0d3903a337db5bc75644952d82845cf2c8766
73d5aafd81e0ab2c7163d04b</pre>

<p>Encapsuler cette valeur dans une structure <code>DigestInfo</code>, en créant tout d'abord le fichier <code>data.cades-bes.DigestInfo.asn.cnf</code> suivant :</p>

<pre>asn1 = SEQUENCE:digestInfo

[digestInfo]
digestAlgorithm = SEQUENCE:digestAlgorithm
digest = FORMAT:HEX,OCTETSTRING:\
91c0d3903a337db5bc75644952d82845cf2c876673d5aafd81e0ab2c7163d04b

[digestAlgorithm]
algorithm = OID:sha256
parameters = NULL</pre>

<p>Générer ensuite le codage DER correspondant.</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-bes.DigestInfo.asn.cnf -i \
  -out data.cades-bes.DigestInfo.der</strong>
    0:d=0  hl=2 l=  49 cons: SEQUENCE
    2:d=1  hl=2 l=  13 cons:  SEQUENCE
    4:d=2  hl=2 l=   9 prim:   OBJECT            :sha256
   15:d=2  hl=2 l=   0 prim:   NULL
   17:d=1  hl=2 l=  32 prim:  OCTET STRING      [HEX DUMP]:91C0D3903A337DB5BC756
44952D82845CF2C876673D5AAFD81E0AB2C7163D04B</pre>

<p>Signer le fichier généré à l’aide de la clé publique du signataire.</p>

<pre><strong>$ openssl pkeyutl -sign -in data.cades-bes.DigestInfo.der -inkey ee-key.pem \
  -out data.cades-bes.signature.bin</strong></pre>

<p>Produire enfin la représentation hexadécimale de cette signature :</p>

<pre><strong>$ od -tx1 -An -w data.cades-bes.signature.bin | tr -d " " | sed 's/$/\\/'</strong>
a28aff00ebade94eb7e3e3e29909b23ad4e85a53f216c1a7bfd48145e7c7a279\
8327eda577f831ac90c29ed12d4729afd7846a715f7ce5343139563bd391fce4\
8511523d00f077cc1cd1921673f6f2dd273bf256531c860eb021fb18e1fc8347\
9688a5bc934015fd6cbb9a5dd4c872d87c0fb0a946462e3c59aef16c7b1f2a3a\
b9d388a9cb84ce37edf3ffb7c4c189e9d47ded1d89c82c577928afaa283b9709\
48a9ab4ac5cdbc4a846947746e252c8d7262416a1286c6a44ec9d48ded51cf14\
7e74719191b1f5ce2e21af4a8a2af938d98767ee1dde29b04798c8e0d1c6d07d\
b8d2b960e0e443da61248b4189fd62de224866dbfa02d2b7f9ca1cb4d9e5e7b6\</pre>

<h3 id="cades-bes-finalisation">Finalisation de la structure CAdES-BES</h3>

<p>Copier le fichier <code>sig-p7.asn.cnf</code> généré dans la section <a href="#construction-signature-pkcs7-cms" class="section"/> sous le nom <code>data.cades-bes.asn.cnf</code>. Dans ce nouveau fichier, remplacer la section <code>signedAttrs</code> et ses dépendances par les sections du fichier <code>data.cades-bes.signedAttrs.asn.cnf</code>, et remplacer la valeur du champ <code>signature</code> de la section <code>signerInfo</code> par la signature des attributs signés obtenue ci-dessus :</p>

<pre>[signerInfo]
version = INTEGER:1
sid = SEQUENCE:sid
digestAlgorithm  = SEQUENCE:signerInfo_digestAlgorithm
signedAttrs = IMPLICIT:0,SET:signedAttrs
signatureAlgorithm = SEQUENCE:signatureAlgorithm 
signature = FORMAT:HEX,OCTETSTRING:\
a28aff00ebade94eb7e3e3e29909b23ad4e85a53f216c1a7bfd48145e7c7a279\
…
b8d2b960e0e443da61248b4189fd62de224866dbfa02d2b7f9ca1cb4d9e5e7b6</pre>

<p>Générer le codage DER de la signature CAdES-BES.</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-bes.asn.cnf -oid cades-oid.tsv -i \
  -out data.cades-bes.der</strong></pre>

<p>Vérifier que le fichier généré est une signature électronique CMS valide.</p>

<pre><strong>$ openssl cms -verify -inform DER -in data.cades-bes.der -content data.txt \
  -CAfile ca-crt.pem</strong>
texte en clairVerification successful</pre>

<h2 id="cades-t">Constitution de la structure CAdES-T</h2>

<p>Pour produire la structure CAdES-T, la structure CAdES-BES est enrichie d'un jeton d'horodatage portant sur la valeur de la signature.</p>

<p>Générer une requête d'horodatage portant sur la valeur binaire de la signature :</p>

<pre><strong>$ openssl ts -query -data data.cades-bes.signature.bin -sha256 \
  -out signatureTimeStamp.tsq</strong></pre>

<p>Générer la réponse à cette requête.</p>

<pre><strong>$ openssl ts -reply -config tsa-ts.cnf -section tsa \
  -queryfile signatureTimeStamp.tsq -inkey tsa-key.pem -signer tsa-crt.pem \
  -out signatureTimeStamp.tsr</strong>
Using configuration from tsa-ts.cnf
Response has been generated.</pre>

<p class="note">Il est également possible de solliciter le serveur d'horodatage proposé dans la section <a href="#serveur-horodatage" class="section"/> pour générer ce jeton.</p>

<pre><strong>$ openssl ts -reply -in signatureTimeStamp.tsr -token_out \
  -out signatureTimeStamp.tst</strong></pre>

<p>En utilisant le processus exposé notamment dans la section <a href="#construction-signature-pkcs7-cms" class="section"/> et/ou en utilisant la méthode proposée en annexe <a href="#unber2asnconf" class="appendix_section"/>, générer la description du jeton d'horodatage au format consommable par la commande <code>openssl asn1parse -genconf</code>. Pour le jeton généré ci-dessus, le résultat obtenu est le suivant :</p>

<pre>[signatureTST]
contentType = OID:pkcs7-signedData
content = EXPLICIT:0,SEQUENCE:signatureTST_content

[signatureTST_content]
version = INTEGER:3
digestAlgorithms = SET:signatureTST_digestAlgorithms
encapContentInfo = SEQUENCE:signatureTST_encapContentInfo
signerInfos = SET:signatureTST_signerInfos

[signatureTST_digestAlgorithms]
digestAlgorithm = SEQUENCE:signatureTST_digestAlgorithm

[signatureTST_digestAlgorithm]
algorithm = OID:sha1
parameters = NULL

[signatureTST_encapContentInfo]
eContentType = OID:id-smime-ct-TSTInfo
eContent = EXPLICIT:0,OCTWRAP,SEQUENCE:signatureTST_TSTInfo

[signatureTST_TSTInfo]
version = INTEGER:1
policy = OID:\
1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.5
messageImprint = SEQUENCE:signatureTST_messageImprint
serialNumber = INTEGER:11
genTime = GENERALIZEDTIME:20120626201609Z
nonce = INTEGER:0x00e1e79be83f82b8af

[signatureTST_messageImprint]
hashAlgorithm = SEQUENCE:signatureTST_TSTInfo_hashAlgorithm
hashedMessage = FORMAT:HEX,OCTETSTRING:\
3da761db17a08fdb46d95cdcecf234c461dac887b4bf0a2d65d8c288621bc235

[signatureTST_TSTInfo_hashAlgorithm]
algorithm = OID:sha256
parameters = NULL

[signatureTST_signerInfos]
signerInfo = SEQUENCE:signatureTST_signerInfo

[signatureTST_signerInfo]
version = INTEGER:1
sid = SEQUENCE:signatureTST_sid
digestAlgorithm = SEQUENCE:signatureTST_digestAlgorithm
signedAttrs = IMPLICIT:0,SEQUENCE:signatureTST_signedAttrs
signatureAlgorithm = SEQUENCE:signatureTST_signatureAlgorithm
signature = FORMAT:HEX,OCTETSTRING:\
1fa03c62cc5648513e8972b049841b32ea753b3763643edb1b2bf196a4b91b7d\
b91c6a3bfc154e866bda19ab3da4d178dd8c454ded0fb808a5a23f2d80b6d81d\
c04afc47bb6eff2edb000a7b195146a7d6c9b97ba1e6cf9ac472ec79ca7c387f\
939de7dbfdd5011cc4f94dc207fb346f0ff4c039941a88f930c4ccc30989e9ba\
08309699e5ac72270e3dab04683b54965da4c349106b1153fe1c64e393ded157\
cdfc6aea6eebd2ffe3ef4dbf0c5d3ea6bf0f3ed2066b4cc23df95ba55921fa66\
87ed16ffe87bfa0c58397cc9bed01f47905af2a2db48395004205edbfb8f06d3\
6ceb384859c85cdee276672d25137c396def80cbd5b2317fc63aef3d8b47c659

[signatureTST_sid]
issuer = SEQUENCE:tsa_issuer
serial = INTEGER:0xd3b94f04ddd1a040

[tsa_issuer]
C = SET:tsa_issuer_C_RDN
O = SET:tsa_issuer_O_RDN
OU1 = SET:tsa_issuer_OU1_RDN
OU2 = SET:tsa_issuer_OU2_RDN

[tsa_issuer_C_RDN]
rdn = SEQUENCE:tsa_issuer_C_ATV

[tsa_issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[tsa_issuer_O_RDN]
rdn = SEQUENCE:tsa_issuer_O_ATV

[tsa_issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[tsa_issuer_OU1_RDN]
rdn = SEQUENCE:tsa_issuer_OU1_ATV

[tsa_issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[tsa_issuer_OU2_RDN]
rdn = SEQUENCE:tsa_issuer_OU2_ATV

[tsa_issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA

[signatureTST_digestAlgorithm]
algorithm = OID:sha1
parameters = NULL

[signatureTST_signedAttrs]
attr_contentType = SEQUENCE:signatureTST_attr_contentType
attr_signingTime = SEQUENCE:signatureTST_attr_signingTime
attr_messageDigest = SEQUENCE:signatureTST_attr_messageDigest
attr_signingCertificate = SEQUENCE:signatureTST_attr_signingCertificate

[signatureTST_attr_contentType]
attrType = OID:contentType
attrValues = SET:signatureTST_attr_contentType_values

[signatureTST_attr_contentType_values]
contentType = OID:id-smime-ct-TSTInfo

[signatureTST_attr_signingTime]
attrType = OID:signingTime
attrValues = SET:signatureTST_attr_signingTime_values

[signatureTST_attr_signingTime_values]
attr_signingTime_value = UTCTIME:120626201609Z

[signatureTST_attr_messageDigest]
attrType = OID:messageDigest
attrValues = SET:signatureTST_attr_messageDigest_values

[signatureTST_attr_messageDigest_values]
messageDigest = FORMAT:HEX,OCTETSTRING:\
18fe06c583bd2a1226648ee7b09d25902d8c089c

[signatureTST_attr_signingCertificate]
attrType = OID:id-smime-aa-signingCertificate
attrValues = SET:signatureTST_attr_signingCertificate_values

[signatureTST_attr_signingCertificate_values]
signingCertificate = SEQUENCE:signatureTST_signingCertificate_certs

[signatureTST_signingCertificate_certs]
certs = SEQUENCE:signatureTST_signingCertificate_essCertIDs

[signatureTST_signingCertificate_essCertIDs]
essCertID = SEQUENCE:signatureTST_signingCertificate_essCertID

[signatureTST_signingCertificate_essCertID]
certHash = FORMAT:HEX,OCTETSTRING:4328a6e719c924d2c414c24ae71950939561c509

[signatureTST_signatureAlgorithm]
algorithm = OID:rsaEncryption
parameters = NULL</pre>

<p class="note">Les sections <code>tsa_issuer*</code> sont identiques aux sections <code>ee_issuer*</code> du fichier <code>data.cades-bes.asn.cnf</code>, puisque l'autorité de certification émettrice du certificat du signataire est également émettrice du certificat de l'unité d'horodatage.</p>

<p>Copier le fichier <code>data.cades-bes.asn.cnf</code> sous le nom <code>data.cades-t.asn.cnf</code>, et y ajouter les sections ci-dessus.</p>

<p>Ajouter ensuite le champ <code>unsignedAttrs</code> dans la section <code>signerInfo</code>, ainsi que les sections correspondant aux attributs non signés, comme ci-dessous :</p>

<pre>[signerInfo]
…
unsignedAttrs = IMPLICIT:1,SET:unsignedAttrs

[unsignedAttrs]
attr_signatureTimeStamp = SEQUENCE:attr_signatureTimeStamp

[attr_signatureTimeStamp]
attrType = OID:SignatureTimeStampToken
attrValues = SET:attr_signatureTimeStamp_values

[attr_signatureTimeStamp_values]
attr_contentType_value = SEQUENCE:signatureTST</pre>

<p>Enfin, ajouter la ligne suivante dans le fichier <code>cades-oid.tsv</code> pour définir l'OID correspondant à l'attribut <code>SignatureTimeStampToken</code> :</p>

<pre>1.2.840.113549.1.9.16.2.14 id-aa-signatureTimeStampToken SignatureTimeStampToken</pre>

<p>Générer la représentation DER de la structure CAdES-T :</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-t.asn.cnf -i -oid cades-oid.tsv \
  -out data.cades-t.der</strong></pre>

<p>Vérifier que la signature reste valide.</p>

<pre><strong>$ openssl smime -verify -inform DER -in data.cades-t.der -content data.txt \
-CAfile ca-crt.pem</strong>
texte en clairVerification successful</pre>

<h2 id="cades-lt">Constitution de la structure CAdES-LT</h2>

<p class="note">Attention, la structure produite n'a pas été validée par un outil tiers, l'auteur n'ayant connaissance d'aucune application gratuite permettant de valider totalement une structure CAdES-LT en version 2.1.1. Si le lecteur souhaite produire commercialement des signatures électroniques avancées aux formats CAdES, alors il lui est recommandé de s'intéresser aux <i>Plugtests</i><span class="fn">http://www.etsi.org/Website/OurServices/Plugtests/home.aspx</span>, événements organisés par l'ETSI pour permettre aux fournisseurs de produits implémentant certaines normes de l'ETSI, dont CAdES, d'effectuer des tests d'interopérabilité et ainsi de déterminer le niveau de conformité de leurs produits par rapport à ces normes.</p>

<p>Le format CAdES-LT enrichit une structure de type CAdES-T (ou plus) d'un attribut non signé, <code>LongTermValidation</code>, contenant un jeton d'horodatage ou un enregistrement de preuve (ou <i>evidence record</i>) ERS (<i>Evidence Record Syntax</i>, tel que défini dans la RFC 4998) portant sur la plupart des informations contenues dans la signature (y compris des attributs non signés), et d'éventuelles données de validation (certificats, listes de révocation etc.) permettant à la signature de contenir les éléments nécessaires à sa propre validation.</p>

<p class="note">L'objectif des enregistrements de preuve ERS est de maintenir la valeur probante de données arbitraires sur le long terme par ré-horodatages successifs, avant que les algorithmes cryptographiques ne soient cassés et que les certificats associés aux données ou aux enregistrements de preuve ne deviennent invalides. Le principe mis en œuvre est semblable à celui utilisé pour ré-horodater des structures *AdES-A, et le mécanisme de constitution s'apparente à celui mis en jeu pour construire un attribut <code>LongTermValidation</code> de CAdES-LT. Un enregistrement de preuve ERS est un objet ASN.1, <code>EvidenceRecord</code>, qu'il serait aisé de constituer et d'inclure dans la signature CAdES-LT, mais en pratique l'implémentation et l'utilisation de cette structure sont marginales, donc cette option est écartée au profit d'un jeton d'horodatage classique.</p>

<p>La structure de l'attribut <code>LongTermValidation</code> est la suivante.</p>

<pre>LongTermValidation ::= SEQUENCE {
  poeDate GeneralizedTime,
  poeValue CHOICE {
    timeStamp [0] EXPLICIT TimeStampToken,
    evidenceRecord [1] EXPLICIT EvidenceRecord
  } OPTIONAL,
  extraCertificates [0] IMPLICIT CertificateSet OPTIONAL,
  extraRevocation [1] IMPLICIT RevocationInfoChoices OPTIONAL
}</pre>

<p>Le champ <code>poeDate</code> (<code>poe</code> pour <i>proof of existence</i> ou preuve d'existence) contient la date et l'heure (de préférence identique, à défaut le plus proche possible) du jeton d'horodatage (ou enregistrement de preuve) inclus dans le champ <code>poeValue</code>. Le champ <code>extraCertificates</code> contiendra le certificat de l'autorité de certification racine, qui a émis le certificat de l'unité d'horodatage et du signataire, ainsi que le certificat de l'unité d'horodatage. Le champ <code>extraRevocation</code> contiendra la dernière liste de certificats révoqués émise par l'autorité de certification racine avant la constitution de l'attribut.</p>

<p>La norme CAdES 2.1.1 introduit, dans le cadre du format CAdES-LT, la notion d'<em>empreinte-arbre</em> (ou <i>tree-hash</i>), qui permet d'obtenir une empreinte unique à partir d'éléments dont l'ordre est arbitraire, à l'exemple de certificats ou de listes de certificats révoqués. Cette empreinte-arbre s'obtient en calculant les empreintes des éléments, en concaténant ces empreintes par ordre croissant, et en calculant l'empreinte de la donnée binaire ainsi générée.</p>

<p class="note">Plus formellement, le classement des empreintes par ordre croissant est le classement par ordre lexicographique de leur représentation binaire, où par exemple <code>000</code> &lt; <code>001</code> &lt; <code>100</code> &lt; <code>111</code>.</p>

<p>Les données à horodater sont la concaténation des empreintes suivantes :</p>

<ul>
    <li>L'empreinte du type du contenu signé (champ <code>eContentType</code>).</li>
    <li>L'empreinte des données faisant l'objet de la signature (ici, le fichier <code>data.txt</code> ; le champ <code>eContent</code> quand la signature est enveloppante).</li>
    <li>L'empreinte-arbre des certificats contenus dans la signature, c'est-à-dire les éléments <code>CertificateChoices</code> du champ <code>certificates</code> de la structure de plus haut niveau, et de ceux du champ <code>extraCertificates</code> de l'attribut <code>LongTermValidation</code> en cours de constitution.</li>
    <li>L'empreinte-arbre des données de révocation contenues dans la signature dans le champ <code>crls</code>, ainsi que de celles contenues dans le champ <code>extraRevocation</code> de l'attribut <code>LongTermValidation</code> en cours de constitution.</li>
    <li>L'empreinte de la concaténation des champs <code>version</code>, <code>sid</code> et <code>digestAlgorithm</code> de la structure <code>SignerInfo</code>.</li>
    <li>L'empreinte des attributs signés de la structure <code>SignerInfo</code>.</li>
    <li>L'empreinte de la concaténation des champs <code>signatureAlgorithm</code> et <code>signature</code> de la structure <code>SignerInfo</code>.</li>
    <li>L'empreinte-arbre des attributs non signés.</li>
</ul>

<p>L'algorithme de hachage utilisé dans ce processus doit être un algorithme référencé dans le champ <code>digestAlgorithms</code> de la signature. Dans le cas présent, il s'agit de l'algorithme SHA-256.</p>

<h3 id="cades-lt-empreinte-contenu-signe">Calcul de l'empreinte du type du contenu signé</h3>

<p>L'empreinte du champ <code>eContentType</code> est calculée sur l'ensemble de sa représentation DER, incluant les octets de type et de longueur.</p>

<p>Deux méthodes de calcul sont proposées. La première s'appuie sur la structure CAdES-T générée précédemment, et consiste à extraire les octets à hacher à l'aide des options <code>-offset</code> et <code>-length</code> de la commande <code>openssl asn1parse</code>. Afficher le début de l'analyse ASN.1 de cette structure.</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i | head -n15</strong>
    0:d=0  hl=4 l=2389 cons: SEQUENCE
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-signedData
   15:d=1  hl=4 l=2374 cons:  cont [ 0 ]
   19:d=2  hl=4 l=2370 cons:   SEQUENCE
   23:d=3  hl=2 l=   1 prim:    INTEGER           :01
   26:d=3  hl=2 l=  15 cons:    SET
   28:d=4  hl=2 l=  13 cons:     SEQUENCE
   30:d=5  hl=2 l=   9 prim:      OBJECT            :sha256
   41:d=5  hl=2 l=   0 prim:      NULL
   43:d=3  hl=2 l=  11 cons:    SEQUENCE
   45:d=4  hl=2 l=   9 prim:     OBJECT            :pkcs7-data
   56:d=3  hl=4 l=1010 cons:    cont [ 0 ]
   60:d=4  hl=4 l=1006 cons:     SEQUENCE
   64:d=5  hl=4 l= 726 cons:      SEQUENCE
   68:d=6  hl=2 l=   3 cons:       cont [ 0 ]</pre>

<p>Le début de la syntaxe ASN.1 d'une structure CMS/CAdES est la suivante :</p>

<pre>ContentInfo ::= SEQUENCE {
  contentType ContentType,
  content [0] EXPLICIT SEQUENCE {
    version CMSVersion,
    digestAlgorithms DigestAlgorithmIdentifiers,
    encapContentInfo SEQUENCE {
      eContentType ContentType,
      eContent [0] EXPLICIT OCTET STRING OPTIONAL },
    certificates [0] IMPLICIT CertificateSet OPTIONAL,
    …
    }
  }
}</pre>

<p>En mettant en correspondance l'analyse et la syntaxe, il apparaît que le champ <code>eContentType</code> commence à l'octet 45, pour une longueur de 11 octets : 2 octets d'en-tête (<code>hl</code>) et 9 de contenu. Extraire le champ.</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i -offset 45 -length 11 \
  -out data.cades-lt.eContentType.bin</strong>
    0:d=0  hl=2 l=   9 prim: OBJECT            :pkcs7-data</pre>

<p>La deuxième méthode proposée pour obtenir le champ <code>eContentType</code> consiste à générer celui-ci à partir d'un fichier de configuration ASN.1 interprétable par la commande <code>openssl asn1parse -genconf</code>, ou d'une ligne de commande simple <code>openssl asn1parse -genstr</code> dans le cas d'un type ASN.1 primitif (ce qui est le cas du champ <code>eContentType</code>, qui est de type primitif <code>OBJECT IDENTIFIER</code>). Le champ <code>eContentType</code> est défini ainsi dans le fichier <code>data.cades-t.asn.cnf</code> :</p>

<pre>…
[encapContentInfo]
eContentType = OID:pkcs7-data
…</pre>

<p>Générer le codage DER du champ <code>eContentType</code> :</p>

<pre><strong>$ openssl asn1parse -genstr OID:pkcs7-data -i -out data.cades-lt.eContentType.bin</strong>
    0:d=0  hl=2 l=   9 prim: OBJECT            :pkcs7-data</pre>

<div class="note"><p>De manière équivalente, il est possible de créer le fichier <code>data.cades-lt.eContentType.asn.cnf</code> suivant :</p>
<pre>asn1 = OID:pkcs7-data</pre>
<p>Générer ensuite le codage DER correspondant :</p>
<pre><strong>$ openssl asn1parse -genconf data.cades-lt.eContentType.asn.cnf -i \
  -out data.cades-lt.eContentType.bin</strong>
    0:d=0  hl=2 l=   9 prim: OBJECT            :pkcs7-data</pre></div>

<p>Une fois le fichier <code>data.cades-lt.eContentType.bin</code> produit à l'aide de l'une de ces méthodes, en générer l'empreinte SHA-256 :</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.eContentType.bin \
  > data.cades-lt.eContentType.sha256</strong></pre>

<h3 id="cades-lt-empreinte-donnees-signees">Calcul de l'empreinte des données signées</h3>

<p>La signature étant détachée (et ne contenant donc pas de champ <code>eContent</code>), générer le fichier contenant l'empreinte binaire des données signées :</p>

<pre><strong>$ openssl sha256 -binary data.txt > data.cades-lt.content.sha256</strong></pre>

<h3 id="cades-lt-empreinte-arbre-certificats">Calcul de l'empreinte-arbre des certificats</h3>

<p>L'empreinte-arbre à générer ensuite porte sur les certificats contenus dans la signature et dans l'attribut <code>LongTermValidation</code> en cours de constitution. Il s'agit des certificats suivants : le certificat du signataire, le certificat de l'autorité de certification racine, et le certificat de l'unité d'horodatage. Calculer les empreintes de ces certificats, préalablement codés en DER.</p>

<pre><strong>$ openssl x509 -in ee-crt-authsig.pem -outform DER | openssl sha256 -binary \
  > data.cades-lt.certificate.ee.sha256

$ openssl x509 -in ca-crt.pem -outform DER | openssl sha256 -binary \
  > data.cades-lt.certificate.ca.sha256

$ openssl x509 -in tsa-crt.pem -outform DER | openssl sha256 -binary \
  > data.cades-lt.certificate.tsa.sha256</strong></pre>

<p>Il faut à présent classer les empreintes par ordre croissant et les concaténer. La manière la plus immédiate de procéder est d'utiliser une commande de type <code>od -tx1 -An</code> sur chacun des fichiers pour obtenir les valeurs hexadécimales de chaque empreinte, les classer, puis de concaténer les fichiers d'empreintes dans l'ordre obtenu. Un script shell (pour systèmes UNIX/Linux) et un fichier batch (pour Windows) sont proposés ci-après pour automatiser la procédure.</p>

<p>Pour les systèmes UNIX/Linux, créer le script <code>genhashlist</code> suivant (lui attribuer le droit d'exécution via par exemple <code>chmod +x genhashlist</code>) :</p>

<pre>#!/bin/bash
for i in $* ; do \
  echo `od -tx1 -An "$i" | tr -d "\r\n "`:$i ; \
done</pre>

<p>Pour les systèmes Windows, créer le fichier batch <code>genhashlist.bat</code> suivant :</p>

<pre>@echo off
for %%a in (%a) do (
od -tx1 -An "%%a" | tr -d "\n\r "
echo.|set /P=:%%a
echo.)</pre>

<p>Ces scripts fonctionnent de manière identique : ils prennent en argument une liste de fichiers, comprenant éventuellement des métacaractères (typiquement, <code>*</code>) et retournent pour chaque fichier le contenu du fichier codé en hexadécimal, suivi d'un caractère <code>:</code>, suivi du nom du fichier. À titre illustratif, sous UNIX/Linux :</p>

<pre><strong>$ ./genhashlist data.cades-lt.certificate.*.sha256</strong>
8f6bc593235515f87869afbab31199543ab779688f2b21ea19da28606c456e39:data.cades-lt.c
ertificate.ca.sha256
1797d10a26237bd5b7ddff81e1848a17d07168646b47b9a083fafa6f713e1957:data.cades-lt.c
ertificate.ee.sha256
68b22f49939e398872086e8e36c83b34a4e45ff521ae86c99d165817322c87cb:data.cades-lt.c
ertificate.tsa.sha256</pre>

<p>La commande équivalente sous Windows est :</p>

<pre><strong>> genhashlist data.cades-lt.certificate.*.sha256</strong></pre>

<p class="note">Attention, ces scripts ne gèrent pas les noms de fichiers passés en argument contenant des espaces. Par ailleurs, sous UNIX/Linux, si un argument contenant un métacaractère est susceptible de retourner un nom de fichier contenant un espace, alors elle doit être entourée de guillemets. Pour pouvoir automatiser le traitement du résultat des scripts comme décrit ci-après, les noms de fichiers ne doivent pas contenir d'espace.</p>

<p>Le résultat des script peut désormais être trié par ordre lexicographique croissant, en chaînant la commande ci-dessus dans la commande <code>sort</code> :</p>

<pre><strong>… | sort</strong>
1797d10a26237bd5b7ddff81e1848a17d07168646b47b9a083fafa6f713e1957:data.cades-lt.c
ertificate.ee.sha256
68b22f49939e398872086e8e36c83b34a4e45ff521ae86c99d165817322c87cb:data.cades-lt.c
ertificate.tsa.sha256
8f6bc593235515f87869afbab31199543ab779688f2b21ea19da28606c456e39:data.cades-lt.c
ertificate.ca.sha256</pre>

<p>Une commande <code>cut</code> sur le résultat de ce tri permet d'obtenir le nom du fichier (le deuxième champ et suivants en considérant que le séparateur de champs est un espace) :</p>

<pre><strong>… | cut -d ":" -f 2-</strong>
data.cades-lt.certificate.ee.sha256
data.cades-lt.certificate.tsa.sha256
data.cades-lt.certificate.ca.sha256</pre>

<p>Chacun de ces fichiers peut alors être concaténé, via <code>xargs</code> (qui boucle par défaut sur chaque ligne passée en entrée, et exécute la commande passée en paramètre) et <code>cat</code> (cf. note ci-après concernant la concaténation de fichiers binaires sous Windows), puis le résultat peut être haché, produisant ainsi l'empreinte-arbre attendue :</p>

<pre><strong>… | xargs cat | openssl sha256 -binary > data.cades-lt.certificates.sha256</strong></pre>

<p class="note">L'ensemble de ce processus peut bien entendu être automatisé pour produire une empreinte-arbre à partir des fichiers empreintes individuels, en enrobant la commande ci-dessus dans un script <i>ad hoc</i>.</p>

<div class="note"><p>Sous Windows, la commande <code>cat</code> employée dans la commande ci-dessus est supposée être celle de la suite GnuWin, qui est capable de gérer indifféremment des fichiers textes ou binaires, contrairement à la commande <code>CAT</code> native de Windows. Si pour une raison ou une autre la commande <code>cat</code> de GnuWin n'était pas disponible, il faudrait utiliser la commande <code>COPY /b</code> de manière manuelle, avec la syntaxe suivante :</p>
<pre><strong>> copy /b data.cades-lt.certificate.ee.sha256 \
  + data.cades-lt.certificate.tsa.sha256 \
  + data.cades-lt.certificate.ca.sha256 \
  data.cades-lt.certificates.bin</strong></pre>
<p>Le fichier obtenu doit ensuite être haché :</p>
<pre><strong>> openssl sha256 -binary data.cades-lt.certificates.bin \
  > data.cades-lt.certificates.sha256</strong></pre></div>

<h3 id="cades-lt-empreinte-arbre-lcr">Calcul de l'empreinte-arbre des listes de certificats révoqués</h3>

<p>Émettre une nouvelle liste de certificats révoqués (LCR), à inclure en tant qu'élément du champ <code>extraRevocation</code> de l'attribut <code>LongTermValidation</code>.</p>

<pre><strong>$ openssl ca -gencrl -cert ca-crt.pem -keyfile ca-key.pem -crlhours 48 \
  -md sha256 -config ca-crl.cnf -name ca_crl -crlexts ca_crl_ext \
  -out data.cades-lt.crl.ltv.pem</strong></pre>

<div class="note"><p>Le lecteur souhaitant utiliser les mêmes valeurs que celles obtenues par l'auteur peut créer le fichier <code>data.cades-lt.crl.ltv.pem</code> avec le contenu suivant :</p>
<pre>-----BEGIN X509 CRL-----
MIIB0zCBvAIBATANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJGUjEXMBUGA1UE
ChMOTW9uIEVudHJlcHJpc2UxFzAVBgNVBAsTDjAwMDIgMTIzNDU2Nzg5MRgwFgYD
VQQLEw9PcGVuU1NMIFJvb3QgQ0EXDTEyMDYyNzE5NDUxOFoXDTEyMDYyOTE5NDUx
OFqgLzAtMB8GA1UdIwQYMBaAFExth5OC9y0sByOiD+BxLRc/OfOPMAoGA1UdFAQD
AgEJMA0GCSqGSIb3DQEBCwUAA4IBAQA+f2f3r47BlMhJYDlL1kcfTzBFinO0QYY2
RWYFFufa/vStxhu50zW7qk9t92NRMiytz6wowU6dPu+dpm/2bxh4CEgmDN72LXKW
VBWkqOKiFJjKl+ky/pJ3Wm3lqQfqwqv+K34+ciEMG+sSAJnwzNO4loKW5fylkvb6
LTaSmJg3fxJk74cbMob9uZTZkW+olyVero5fIC/CMwU3Tgrv9VELkjFca3CF61Mq
KD6yMUDk+Sl8rTvbsma1zgotiLflx7Nm1dG24WsDNdfnFZqst9mZUtYodXll9oZx
F+EOstj7yuESB0trRMhnqDOGQBDLVeXyyd0oActCrNdxBsJC3aCN
-----END X509 CRL-----</pre></div>

<p>Convertir le codage en DER.</p>

<pre><strong>$ openssl crl -in data.cades-lt.crl.ltv.pem -outform DER \
  -out data.cades-lt.crl.ltv.der</strong></pre>

<p>Une seule LCR figurant dans la structure CAdES-LT, l'empreinte-arbre des LCR est simplement l'empreinte de l'empreinte de la LCR : la générer.</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.crl.ltv.der | openssl sha256 -binary \
  > data.cades-lt.crls.sha256</strong></pre>

<h3 id="cades-lt-empreinte-v-sid-dig">Calcul de l'empreinte des champs <code>version</code>, <code>sid</code> et <code>digestAlgorithm</code></h3>

<p>L'empreinte suivante à produire est celle de la concaténation du codage DER des champs <code>version</code>, <code>sid</code> et <code>digestAlgorithm</code> de la structure <code>SignerInfo</code> à laquelle sera ajouté l'attribut <code>LongTermValidation</code>. La méthode proposée ici est de retrouver les octets correspondant à ces champs dans l'analyse ASN.1 de la signature CAdES-T, de les extraire et de les hacher (ci-dessous, les principaux champs et structures de la signature ont été ajoutés en gras).</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i</strong>
    0:d=0  hl=4 l=2389 cons: SEQUENCE <strong>-- ContentInfo</strong>
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-signedData
   15:d=1  hl=4 l=2374 cons:  cont [ 0 ]  <strong>-- content</strong>
   19:d=2  hl=4 l=2370 cons:   SEQUENCE
   …
 1070:d=3  hl=4 l=1319 cons:    SET <strong>-- signerInfos</strong>
 1074:d=4  hl=4 l=1315 cons:     SEQUENCE <strong>-- SignerInfo</strong>
 1078:d=5  hl=2 l=   1 prim:      INTEGER           :01 <strong>-- version</strong>
 1081:d=5  hl=2 l= 102 cons:      SEQUENCE <strong>-- sid</strong>
 1083:d=6  hl=2 l=  89 cons:       SEQUENCE
 1085:d=7  hl=2 l=  11 cons:        SET
 1087:d=8  hl=2 l=   9 cons:         SEQUENCE
 1089:d=9  hl=2 l=   3 prim:          OBJECT            :countryName
 1094:d=9  hl=2 l=   2 prim:          PRINTABLESTRING   :FR
 1098:d=7  hl=2 l=  23 cons:        SET
 1100:d=8  hl=2 l=  21 cons:         SEQUENCE
 1102:d=9  hl=2 l=   3 prim:          OBJECT            :organizationName
 1107:d=9  hl=2 l=  14 prim:          PRINTABLESTRING   :Mon Entreprise
 1123:d=7  hl=2 l=  23 cons:        SET
 1125:d=8  hl=2 l=  21 cons:         SEQUENCE
 1127:d=9  hl=2 l=   3 prim:          OBJECT            :organizationalUnitName
 1132:d=9  hl=2 l=  14 prim:          PRINTABLESTRING   :0002 123456789
 1148:d=7  hl=2 l=  24 cons:        SET
 1150:d=8  hl=2 l=  22 cons:         SEQUENCE
 1152:d=9  hl=2 l=   3 prim:          OBJECT            :organizationalUnitName
 1157:d=9  hl=2 l=  15 prim:          PRINTABLESTRING   :OpenSSL Root CA
 1174:d=6  hl=2 l=   9 prim:       INTEGER           :DCD21EE5A2B7DFC7
 1185:d=5  hl=2 l=  13 cons:      SEQUENCE <strong>-- digestAlgorithm</strong>
 1187:d=6  hl=2 l=   9 prim:       OBJECT            :sha256
 1198:d=6  hl=2 l=   0 prim:       NULL
 1200:d=5  hl=3 l= 162 cons:      cont [ 0 ] <strong>-- signedAttrs</strong>
…</pre>

<p>Les données à hacher commencent à l'octet 1078 et terminent à l'octet précédant l'octet 1200, soit une longueur de 122 octets. Extraire ces données.</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i -offset 1078 \
  -length 122 -out data.cades-lt.v-sid-dig.bin</strong></pre>

<p class="note">Le fait que cette opération ne produise aucune erreur suggère que les champs ont été extraits intégralement et sans déborder sur les champs suivants (tenter la même commande avec <code>-length 121</code> ou <code>-length 123</code> pour s'en convaincre).</p>

<p>Calculer l'empreinte du fichier obtenu.</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.v-sid-dig.bin \
  > data.cades-lt.v-sid-dig.sha256</strong></pre>

<h3 id="cades-lt-empreinte-attributs-signes">Calcul de l'empreinte des attributs signés</h3>

<p>Cette opération a déjà été vue page <a href="#cades-lt-empreinte-donnees-signees" class="page"/>. Exécuter la commande suivante.</p>

<pre><strong>$ openssl sha256 -binary data.cades-bes.signedAttrs.der \
  > data.cades-lt.signedAttrs.sha256</strong></pre>

<h3 id="cades-lt-empreinte-sigalg-sig">Calcul de l'empreinte des champs <code>signatureAlgorithm</code> et <code>signature</code></h3>

<p>L'empreinte des champs <code>signatureAlgorithm</code> et <code>signature</code> s'obtient à l'aide de la même méthode que celle proposée pour calculer l'empreinte des champs <code>version</code>, <code>sid</code> et <code>digestAlgorithm</code> (cf. page <a href="#cades-lt-empreinte-v-sid-dig" class="page"/>). Afficher l'analyse ASN.1 de la signature CAdES-T (les principaux champs et structures de la signature ont été ajoutés en gras).</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i</strong>
    0:d=0  hl=4 l=2389 cons: SEQUENCE <strong>-- ContentInfo</strong>
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-signedData
   15:d=1  hl=4 l=2374 cons:  cont [ 0 ] <strong>-- content</strong>
   19:d=2  hl=4 l=2370 cons:   SEQUENCE
…
 1070:d=3  hl=4 l=1319 cons:    SET <strong>-- signerInfos</strong>
 1074:d=4  hl=4 l=1315 cons:     SEQUENCE <strong>-- SignerInfo</strong>
…
 1365:d=5  hl=2 l=  13 cons:      SEQUENCE <strong>-- signatureAlgorithm</strong>
 1367:d=6  hl=2 l=   9 prim:       OBJECT            :rsaEncryption
 1378:d=6  hl=2 l=   0 prim:       NULL
 1380:d=5  hl=4 l= 256 prim:      OCTET STRING      [HEX DUMP]:A28AFF00EBADE94EB
7E3E3E29909B23AD4E85A53F216C1A7BFD48145E7C7A2798327EDA577F831AC90C29ED12D4729AFD
7846A715F7CE5343139563BD391FCE48511523D00F077CC1CD1921673F6F2DD273BF256531C860EB
021FB18E1FC83479688A5BC934015FD6CBB9A5DD4C872D87C0FB0A946462E3C59AEF16C7B1F2A3AB
9D388A9CB84CE37EDF3FFB7C4C189E9D47DED1D89C82C577928AFAA283B970948A9AB4AC5CDBC4A8
46947746E252C8D7262416A1286C6A44EC9D48DED51CF147E74719191B1F5CE2E21AF4A8A2AF938D
98767EE1DDE29B04798C8E0D1C6D07DB8D2B960E0E443DA61248B4189FD62DE224866DBFA02D2B7F
9CA1CB4D9E5E7B6 <strong>-- signature</strong>
 1640:d=5  hl=4 l= 749 cons:      cont [ 1 ] <strong>-- unsignedAttrs</strong>
…</pre>

<p>Les données à hacher commencent à l’octet 1365 et terminent à l’octet précédant l’octet 1640, soit
une longueur de 275 octets. Extraire ces données.</p>

<pre><strong>$ openssl asn1parse -in data.cades-t.der -inform DER -i -offset 1365 \
  -length 275 -out data.cades-lt.sigalg-sig.bin</strong></pre>

<p>Calculer l’empreinte du fichier obtenu.</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.sigalg-sig.bin \
  > data.cades-lt.sigalg-sig.sha256</strong></pre>

<h3 id="cades-lt-empreinte-arbre-attributs-non-signes">Calcul de l'empreinte-arbre des attributs non signés</h3>

<p>Chacun des attributs non signés doit être soit extrait de la structure CAdES-T en utilisant par exemple la méthode employée pour calculer les empreintes des champs <code>version</code>, <code>sid</code>, etc., soit construit à partir d'un fichier de configuration ASN.1 interprétable par la commande <code>openssl asn1parse -genconf</code>. Cette seconde méthode est utilisée ci-après.</p>

<p>Copier le fichier <code>data.cades-t.asn.cnf</code> sous le nom <code>data.cades-lt.unsignedAttrs.sigts.asn.cnf</code>, correspondant à <code>SignatureTimeStamp</code>, jeton d'horodatage spécifique à CAdES-T et unique attribut non signé.</p>

<p>Remplacer la première ligne du nouveau fichier par la ligne suivante :</p>

<pre>asn1 = SEQUENCE:attr_signatureTimeStamp</pre>

<p>Générer le codage DER de l'attribut.</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-lt.unsignedAttrs.sigts.asn.cnf -i \
  -oid cades-oid.tsv -out data.cades-lt.unsignedAttrs.sigts.bin</strong>
    0:d=0  hl=4 l= 745 cons: SEQUENCE
    4:d=1  hl=2 l=  11 prim:  OBJECT            :SignatureTimeStampToken
   17:d=1  hl=4 l= 728 cons:  SET
   21:d=2  hl=4 l= 724 cons:   SEQUENCE
…</pre>

<p>Générer l'empreinte SHA-256 du fichier obtenu.</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.unsignedAttrs.sigts.bin \
  > data.cades-lt.unsignedAttrs.sigts.sha256</strong></pre>

<p class="note">Dans le cas d'une structure CAdES-T contenant plusieurs attributs non signés, reproduire cette opération pour chacun des attributs.</p>

<p>L'empreinte-arbre des attributs non signés est simplement l'empreinte de cette empreinte. La générer.</p>

<pre><strong>$ openssl sha256 -binary data.cades-lt.unsignedAttrs.sigts.sha256 \
  > data.cades-lt.unsignedAttrs.sha256</strong></pre>

<p class="note">Dans le cas d'une structure contenant plusieurs attributs non signés, employer la méthode décrite pour calculer l'empreinte-arbre des certificats (cf. page <a href="#cades-lt-empreinte-arbre-certificats" class="page"/>).</p>

<h3 id="cades-lt-jeton-horodatage">Émission du jeton d'horodatage</h3>

<p>Les données à horodater sont la concaténation des huit empreintes et empreintes-arbres calculées précédemment.</p>

<div class="note"><p>À titre de contrôle, les valeurs calculées sont les suivantes :</p>
<pre><strong>$ genhashlist *.sha256</strong>
fa40fd248fc05fdf1e3951569df7c460652183083adada7f90e92648dc5f0cc8:data.cades-lt.c
ertficates.sha256
…
89bd92286d6c8014c06030b25f8b40cc1d5656d4b3b7b4831874f50d6f5557f3:data.cades-lt.c
ontent.sha256
a19ca72ee6d8f8dbd0c8c63ff515efa1aeb1a60975dca0d27db74a897c49046f:data.cades-lt.c
rls.sha256
68eaa891b4a70436878676f07513f96b4f39aceeb54beee6d9d1a9ef62409991:data.cades-lt.e
ContentType.sha256
0edfd0615a3a38b89c5b808bd71d47dbe8ee36cc162d08ea73e541dccda870a0:data.cades-lt.s
igalg-sig.sha256
91c0d3903a337db5bc75644952d82845cf2c876673d5aafd81e0ab2c7163d04b:data.cades-lt.s
ignedAttrs.sha256
a25e214c81673e4ed1d70b477a7b7e5867e82df632f449adbd774a8b14893033:data.cades-lt.u
nsignedAttrs.sha256
…
bb261bf6901764e741da00eab09536b5e789329e4e2dd45dbe3499eaf6ec84d6:data.cades-lt.v
-sid-dig.sha256</pre></div>

<p>Concaténer les empreintes dans l'ordre prévu par la norme CAdES.</p>

<pre><strong>$ cat \
  data.cades-lt.eContentType.sha256 \
  data.cades-lt.content.sha256 \
  data.cades-lt.certificates.sha256 \
  data.cades-lt.crls.sha256 \
  data.cades-lt.v-sid-dig.sha256 \
  data.cades-lt.signedAttrs.sha256 \
  data.cades-lt.sigalg-sig.sha256 \
  data.cades-lt.unsignedAttrs.sha256 \
  > data.cades-lt.LongTermValidation.data_to_hash</strong></pre>

<div class="note"><p>L'empreinte de ce fichier est la suivante.</p>
<pre><strong>$ openssl sha256 data.cades-lt.LongTermValidation.data_to_hash</strong>
SHA256(data.cades-lt.LongTermValidation.data_to_hash)= 1296cc40e45a61c64f60229ee
835ed15193e2b162927fd1f287ae49754b2a9c6</pre></div>

<p>Générer la requête d’horodatage associée à ce fichier.</p>

<pre><strong>$ openssl ts -query -data data.cades-lt.LongTermValidation.data_to_hash \
  -sha256 -out LongTermValidation.TimeStamp.tsq</strong></pre>

<p>Générer la réponse d’horodatage.</p>

<pre><strong>$ openssl ts -reply -config tsa-ts.cnf -section tsa \
  -queryfile LongTermValidation.TimeStamp.tsq -inkey tsa-key.pem \
  -signer tsa-crt.pem -out LongTermValidation.TimeStamp.tsr</strong></pre>

<p>Extraire le jeton d’horodatage de cette réponse.</p>

<pre><strong>$ openssl ts -reply -in LongTermValidation.TimeStamp.tsr -token_out \
  -out LongTermValidation.TimeStamp.tst</strong></pre>

<h3 id="cades-lt-timestamp">Constitution du champ <code>timeStamp</code> de l'attribut <code>LongTermValidation</code></h3>

<p>À l'aide d'une méthode au choix, créer le fichier de configuration ASN.1 <code>LongTermValidation.TimeStampToken.asn.cnf</code> à partir du jeton d'horodatage. La méthode la plus rapide consiste à effectuer une copie du fichier <code>signatureTimeStampToken.asn.cnf</code>, à remplacer toutes les occurrences de la chaîne de caractères <code>signatureTST</code> par la chaîne <code>LTV_TST</code>, et à effectuer les modifications en gras ci-dessous :</p>

<pre>asn1 = SEQUENCE:LTV_TST

[LTV_TST]
…

[LTV_TST_TSTInfo]
version = INTEGER:1
policy = OID:\
1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.5
messageImprint = SEQUENCE:LTV_TST_messageImprint
<strong>serialNumber = INTEGER:12
genTime = GENERALIZEDTIME:20120628204038Z
nonce = INTEGER:0x0090a7870811e427e7</strong>

[LTV_TST_messageImprint]
hashAlgorithm = SEQUENCE:LTV_TST_TSTInfo_hashAlgorithm
hashedMessage = FORMAT:HEX,OCTETSTRING:\
<strong>1296cc40e45a61c64f60229ee835ed15193e2b162927fd1f287ae49754b2a9c6</strong>

[LTV_TST_TSTInfo_hashAlgorithm]
…

[LTV_TST_signerInfo]
version = INTEGER:1
sid = SEQUENCE:LTV_TST_sid
digestAlgorithm = SEQUENCE:LTV_TST_digestAlgorithm
signedAttrs = IMPLICIT:0,SEQUENCE:LTV_TST_signedAttrs
signatureAlgorithm = SEQUENCE:LTV_TST_signatureAlgorithm
signature = FORMAT:HEX,OCTETSTRING:\
<strong>68fd52c20f948eec7cde8f818d3c3ab1d0959efbebf9b796311ac4c149b6a2b0\
d48215b81e00359c38ad7f1517a10c9f3a9a57d6c0fac8d663be6aec47add59f\
d942a2b5a46a0cefa0145b73e635c172261087dd49f342d32aa5696184649734\
50eccfa833e4b9fb661a04d0b27a940115f3dc2dbefe5a63caaf7cbbde596f3f\
0e6537ffc3ce452c74f9228a78086f25317a11a7660cce638ede7340ece793ea\
6a97d646ce54932e3919b9f45cc5c0517e3134cc3cf9c87588611ee3de8b87b4\
6da78b8b9e1ca38af4f8aca82bf47bff44382e403fc353a22ed2a0648a064008\
cf56a79f122052478a75f99515acedd6d45a9c6655ab2e5e3e4fe8a65a36875c</strong>

[LTV_TST_sid]
…

[LTV_TST_attr_signingTime_values]
<strong>attr_signingTime_value = UTCTIME:120628204038Z</strong>

[LTV_TST_attr_messageDigest]
…

[LTV_TST_attr_messageDigest_values]
messageDigest = FORMAT:HEX,OCTETSTRING:\
<strong>c8330ac86400e185465f1a5856a258d0cc434c7b</strong>

…</pre>

<p>Générer le codage DER correspondant.</p>

<pre><strong>$ openssl asn1parse -genconf LongTermValidation.TimeStampToken.asn.cnf -i \
  -out LongTermValidation.TimeStampToken.der</strong></pre>

<p>S'assurer que le fichier généré est identique au jeton d'origine :</p>

<pre><strong>$ openssl sha256 LongTermValidation.TimeStamp.tst \
  LongTermValidation.TimeStampToken.der</strong>
SHA256(LongTermValidation.TimeStamp.tst)= 895ed9b7f0492a88a69519617fa55938b8ace5
6afb1a004c55d221880472d9de
SHA256(LongTermValidation.TimeStampToken.der)= 895ed9b7f0492a88a69519617fa55938b
8ace56afb1a004c55d221880472d9de</pre>

<h3 id="cades-lt-certificat-horodatage">Constitution de la structure <code>Certificate</code> pour le certficat de l'unité d'horodatage</h3>

<p>Copier le fichier <code>ee-Certificate.asn.cnf</code>, constitué dans la section <a href="#finalisation-certificat" class="section"/>, sous le nom <code>tsa-Certificate.asn.cnf</code>. Dans ce nouveau fichier, remplacer globalement la chaîne de caractères <code>ee_</code> par la chaîne <code>tsa_</code>, puis effectuer les modifications mises en évidence en gras ci-dessous.</p>

<pre>asn1 = SEQUENCE:tsa_certificate

[tsa_certificate]
tbsCertificate = SEQUENCE:tsa_tbsCertificate
signatureAlgorithm = SEQUENCE:tsa_signatureAlgorithm
signatureValue = FORMAT:HEX,BITSTRING:\
<strong>0f9ad3afe45665ba7c3b92caa0fe2d49378d53e379e618915176f5a9da8b48c5\
589e850fa297027754f87f0f3dc305e8e21bfad90f3df235712ada052ec7ac5d\
6c40f6ad73948677148aa4ea6b9fea005ef33d7fbade612505c638b787c4308e\
4dd44ec356a493fc743bb488450f53dc90ffeb3be8008c792ba99bccfd6dc3ec\
4c5de3b812681a1d57cdf8a219652a26f796b5734e2a2ce62a9dcd5461c7993a\
8f8564f16f68f054e20c0904afa3c9c79d4c92f8ae007ba6d4d768896ae21250\
a98d268d465ece52b59cba647e12b66e73138ca90a1104f49491d6c340c7ea6a\
ec613e015fed29d6efa873964a937b5cb63e134cb858d8bb1b52fd51edc8c99a</strong>

[tsa_tbsCertificate]
version = EXPLICIT:0,INTEGER:2
<strong>serialNumber = INTEGER:0xd3b94f04ddd1a040</strong>
signature = SEQUENCE:tsa_signature
issuer = SEQUENCE:tsa_issuer
validity = SEQUENCE:tsa_validity
subject = SEQUENCE:tsa_subject
subjectPublicKeyInfo = SEQUENCE:tsa_subjectPublicKeyInfo
extensions = EXPLICIT:3,SEQUENCE:tsa_extensions

[tsa_signatureAlgorithm]
…

[tsa_validity]
<strong>notBefore = UTCTIME:120616203401Z
notAfter = UTCTIME:140616203401Z</strong>

[tsa_subject]
…

[tsa_subject_O_ATV]
type = OID:organizationName
<strong>value = PRINTABLESTRING:Mon Entreprise</strong>

[tsa_subject_OU_RDN]
rdn = SEQUENCE:tsa_subject_OU_ATV

[tsa_subject_OU_ATV]
type = OID:organizationalUnitName
<strong>value = PRINTABLESTRING:0002 123456789</strong>

[tsa_subject_CN_RDN]
rdn = SEQUENCE:tsa_subject_CN_ATV

[tsa_subject_CN_ATV]
type = OID:commonName
<strong>value = PRINTABLESTRING:OpenSSL TSA</strong>

[tsa_subjectPublicKeyInfo]
…

[tsa_subjectPublicKey]
<strong>n = INTEGER:0xc890c43fb9ea0dfeb6a0d811df6ba4b0294b687f61606932f2189c33cc13db774\
2137124592f0fe8b5c78147507daf5f332c817b76f1b62038107b56707b54e6600960c51ad9cf26\
73f7342d11f93faf15648993fa5b847f18bd22832fb9fa86fe3409fe502d8f67a7dfd97541a2036\
901b21484daa1223df862d70b31dc841fe87beab733c0134f146569294b1ffdd1c4ff7f9e0276e9\
2482f3221242e5e958e308a7a74d6d365d911917e367beeaa0a1577f859fd18fe167e80e95050b1\
a6d14300a69fb7e301e0140ad3cb7fbcd0d791d67fe4771ab4f8cb1f3bfe4ddb02bd2859d93cccb\
e01a4e66a13d3c28ecad4a4565b917a915fda61a5913a8357c15</strong>
e = INTEGER:0x010001

[tsa_extensions]
subjectKeyIdentifier=SEQUENCE:tsa_subjectKeyIdentifier
authorityKeyIdentifier=SEQUENCE:tsa_authorityKeyIdentifier
keyUsage=SEQUENCE:tsa_keyUsage
certificatePolicies=SEQUENCE:tsa_certificatePolicies
crlDistributionPoints=SEQUENCE:tsa_crlDistributionPoints
basicConstraints=SEQUENCE:tsa_basicConstraints
<strong>extendedKeyUsage=SEQUENCE:tsa_extendedKeyUsage</strong>

[tsa_subjectKeyIdentifier]
extnID = OID:subjectKeyIdentifier
extnValue = OCTWRAP,FORMAT:HEX,OCTETSTRING:\
<strong>ba0bbbafe3254656fc138692d2154062db166a4a</strong>

[tsa_authorityKeyIdentifier]
…

[tsa_keyUsage]
extnID = OID:keyUsage
critical = BOOLEAN:true
<strong>extnValue = OCTWRAP,FORMAT:BITLIST,BITSTRING:0</strong>

[tsa_certificatePolicies]
…

[tsa_policyIdentifier]
policyIdentifier = OID:\
<strong>1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.4</strong>

[tsa_crlDistributionPoints]
…

<strong>[tsa_extendedKeyUsage]
extnID = OID:extendedKeyUsage
critical = BOOLEAN:true
extnValue = OCTWRAP,SEQUENCE:tsa_keyPurposeIds

[tsa_keyPurposeIds]
tsa_keyPurposeId = OID:timeStamping</strong></pre>

<p>Générer le certificat correspondant.</p>

<pre><strong>$ openssl asn1parse -genconf tsa-Certificate.asn.cnf -i \
  -out tsa-Certificate.der</strong></pre>

<p>Convertir le certificat existant de l'unité d'horodatage au format DER.</p>

<pre><strong>$ openssl x509 -in tsa-crt.pem -outform DER -out tsa-crt.der</strong></pre>

<p>Vérifier que les empreintes des deux fichiers DER obtenus sont identiques.</p>

<pre><strong>$ openssl sha256 tsa-Certificate.der tsa-crt.der</strong>
SHA256(tsa-Certificate.der)= 68b22f49939e398872086e8e36c83b34a4e45ff521ae86c99d1
65817322c87cb
SHA256(tsa-crt.der)= 68b22f49939e398872086e8e36c83b34a4e45ff521ae86c99d165817322
c87cb</pre>

<div class="note"><p>La vérification peut être effectuée sans conversion du certificat à partir du fichier <code>data.cades-lt.certificate.tsa.sha256</code> généré précédemment.</p>
<pre><strong>$ od -tx1 -An data.cades-lt.certificate.tsa.sha256 | tr -d " \n\r"</strong>
68b22f49939e398872086e8e36c83b34a4e45ff521ae86c99d165817322c87cb</pre></div>

<h3 id="cades-lt-certificat-ac">Constitution de la structure <code>Certificate</code> pour le certficat de l'autorité de certification</h3>

<p>Par analogie avec la méthode de constitution de la structure <code>Certificate</code> pour l'unité d'horodatage, copier le fichier <code>ee-Certificate.asn.cnf</code> sous le nom <code>ca-Certificate.asn.cnf</code>. Dans ce nouveau fichier, remplacer globalement la chaîne de caractères <code>ee_</code> par la chaîne <code>ca_</code>, puis effectuer les modifications mises en évidence en gras ci-dessous.</p>

<pre>asn1 = SEQUENCE:ca_certificate

[ca_certificate]
tbsCertificate = SEQUENCE:ca_tbsCertificate
signatureAlgorithm = SEQUENCE:ca_signatureAlgorithm
signatureValue = FORMAT:HEX,BITSTRING:\
<strong>96a482086e7a3aa7327cdb5413f10fa03edce80f4f608ec7720f68e6096c8636\
5e85ec659f9233d5db27f87397e96ba4f41fd557785dd3577e416730cb2e4a20\
cae0607d46a22d9102c70c56d30b32c1ded06d0b15f89b85964a57e891ad14f9\
441cdc1d794f1086a62f1f766c280e9e2f5c9a355960787379c11fc0446860e7\
9c870033e01b756e22dc101e1386b6e2459f55f820f875ed274d4e2ba669f2c8\
632dcc95d69f28a45c384ea0489427f9f05b9f49a777fd100089e722c83c0103\
048a43788babe2f5e8f2c01d177f69e92c6cb34e4a790b41e0b91a0ef32b978e\
6fad454a0f0ea6af1b5461ae4f66460a3c303954709105b391dfda6d7c32c1bb</strong>

[ca_tbsCertificate]
version = EXPLICIT:0,INTEGER:2
<strong>serialNumber = INTEGER:0xacaaff2f9de93c53</strong>
signature = SEQUENCE:ca_signature
issuer = SEQUENCE:ca_issuer
validity = SEQUENCE:ca_validity
subject = SEQUENCE:ca_subject
subjectPublicKeyInfo = SEQUENCE:ca_subjectPublicKeyInfo
extensions = EXPLICIT:3,SEQUENCE:ca_extensions

[ca_signatureAlgorithm]
…

[ca_validity]
notBefore = UTCTIME:120407141248Z
notAfter = UTCTIME:220407141248Z

[ca_subject]
C = SET:ca_subject_C_RDN
O = SET:ca_subject_O_RDN
<strong>OU1 = SET:ca_subject_OU1_RDN
OU2 = SET:ca_subject_OU2_RDN</strong>

[ca_subject_C_RDN]
…

[ca_subject_O_ATV]
type = OID:organizationName
<strong>value = PRINTABLESTRING:Mon Entreprise

[ca_subject_OU1_RDN]
rdn = SEQUENCE:ca_subject_OU1_ATV

[ca_subject_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[ca_subject_OU2_RDN]
rdn = SEQUENCE:ca_subject_OU2_ATV

[ca_subject_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA</strong>

[ca_subjectPublicKeyInfo]
algorithm = SEQUENCE:ca_rsaEncryption
subjectPublicKey = BITWRAP,SEQUENCE:ca_subjectPublicKey

[ca_rsaEncryption]
algorithm = OID:rsaEncryption
parameters = NULL

[ca_subjectPublicKey]
<strong>n = INTEGER:0x9c2dba6207f395a0b4b347310d149130744f1489e0b550f356c4e4804d76c883e\
bfd6929e9c22903ea5688fc388dd238222caefa1f42c7aa0ff7c5789a2728783d19331c63b59ae5\
63ffab84dc6e02191ea051643a735daac0c24ef06c8b84fc846e267d146cac41013e67744b920f7\
49d6d8a4569dfad9c71b425c76fdceb300fea94207dadf75a86cf19a8bc00897b9e8381ecaaaede\
388578e8ed76534da38e95c49230baf8b2fd1fb73eba1d30f392a090773d48d5f1f3de8a40cfe75\
feb8100e42e48021ddae887da0f07ae649679c2ffe00c48888ceacd7f87d85448a4fb50d36fd7b6\
8f844355b2fc5e8c2f6ecd9281cbf3b55bace0bfe3eabf3f85c1</strong>
e = INTEGER:0x010001

[ca_extensions]
subjectKeyIdentifier=SEQUENCE:ca_subjectKeyIdentifier
authorityKeyIdentifier=SEQUENCE:ca_authorityKeyIdentifier
keyUsage=SEQUENCE:ca_keyUsage
certificatePolicies=SEQUENCE:ca_certificatePolicies
<strong># Supprimer l'extension crlDistributionPoints</strong>
basicConstraints=SEQUENCE:ca_basicConstraints

[ca_subjectKeyIdentifier]
extnID = OID:subjectKeyIdentifier
extnValue = OCTWRAP,FORMAT:HEX,OCTETSTRING:\
<strong>4c6d879382f72d2c0723a20fe0712d173f39f38f</strong>

[ca_authorityKeyIdentifier]
…

[ca_keyUsage]
extnID = OID:keyUsage
critical = BOOLEAN:true
<strong>extnValue = OCTWRAP,FORMAT:BITLIST,BITSTRING:5,6</strong>

[ca_certificatePolicies]
…

[ca_policyIdentifier]
policyIdentifier = OID:\
<strong>1.2.840.113556.1.8000.2554.47311.54169.61548.20478.40224.8393003.10972002.1.1</strong>

<strong># Supprimer les sections relatives à l'extension crlDistributionPoints</strong>

[ca_basicConstraints]
extnID = OID:basicConstraints
critical = BOOLEAN:true
<strong>extnValue = OCTWRAP,SEQUENCE:ca_basicConstraints_seq

[ca_basicConstraints_seq]
cA = BOOLEAN:true</strong></pre>

<p>Générer le certificat correspondant, convertir le certificat existant de l'autorité de certification au format DER, et vérifier que les empreintes concordent.</p>

<pre><strong>$ openssl asn1parse -genconf ca-Certificate.asn.cnf -i \
  -out ca-Certificate.der

$ openssl x509 -in ca-crt.pem -outform DER -out ca-crt.der

$ openssl sha256 ca-Certificate.der ca-crt.der</strong>
SHA256(ca-Certificate.der)= 8f6bc593235515f87869afbab31199543ab779688f2b21ea19da
28606c456e39
SHA256(ca-crt.der)= 8f6bc593235515f87869afbab31199543ab779688f2b21ea19da28606c45
6e39</pre>

<h3 id="cades-lt-lcr">Constitution de la structure <code>CertificateList</code> pour la liste de certificats révoqués</h3>

<p>Créer le fichier <code>crl-LTV-CertificateList.asn.cnf</code> suivant.</p>

<pre>asn1 = SEQUENCE:ltv_certificateList

[ltv_certificateList]
tbsCertList = SEQUENCE:ltv_crl_tbsCertList
signatureAlgorithm = SEQUENCE:ltv_crl_signatureAlgorithm
signatureValue = FORMAT:HEX,BITSTRING:\
3e7f67f7af8ec194c84960394bd6471f4f30458a73b441863645660516e7dafe\
f4adc61bb9d335bbaa4f6df76351322cadcfac28c14e9d3eef9da66ff66f1878\
0848260cdef62d72965415a4a8e2a21498ca97e932fe92775a6de5a907eac2ab\
fe2b7e3e72210c1beb120099f0ccd3b8968296e5fca592f6fa2d36929898377f\
1264ef871b3286fdb994d9916fa897255eae8e5f202fc23305374e0aeff5510b\
92315c6b7085eb532a283eb23140e4f9297cad3bdbb266b5ce0a2d88b7e5c7b3\
66d5d1b6e16b0335d7e7159aacb7d99952d628757965f6867117e10eb2d8fbca\
e112074b6b44c867a833864010cb55e5f2c9dd2801cb42acd77106c242dda08d

[ltv_crl_tbsCertList]
version = INTEGER:1
signature = SEQUENCE:ltv_crl_signature
issuer = SEQUENCE:ltv_crl_issuer
thisUpdate = UTCTIME:120627194518Z
nextUpdate = UTCTIME:120629194518Z
crlExtensions = EXPLICIT:0,SEQUENCE:ltv_crl_crlExtensions

[ltv_crl_signature]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL

[ltv_crl_issuer]
C = SET:ltv_crl_issuer_C_RDN
O = SET:ltv_crl_issuer_O_RDN
OU1 = SET:ltv_crl_issuer_OU1_RDN
OU2 = SET:ltv_crl_issuer_OU2_RDN

[ltv_crl_issuer_C_RDN]
rdn = SEQUENCE:ltv_crl_issuer_C_ATV

[ltv_crl_issuer_C_ATV]
type = OID:countryName
value = PRINTABLESTRING:FR

[ltv_crl_issuer_O_RDN]
rdn = SEQUENCE:ltv_crl_issuer_O_ATV

[ltv_crl_issuer_O_ATV]
type = OID:organizationName
value = PRINTABLESTRING:Mon Entreprise

[ltv_crl_issuer_OU1_RDN]
rdn = SEQUENCE:ltv_crl_issuer_OU1_ATV

[ltv_crl_issuer_OU1_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:0002 123456789

[ltv_crl_issuer_OU2_RDN]
rdn = SEQUENCE:ltv_crl_issuer_OU2_ATV

[ltv_crl_issuer_OU2_ATV]
type = OID:organizationalUnitName
value = PRINTABLESTRING:OpenSSL Root CA

[ltv_crl_crlExtensions]
authorityKeyIdentifier = SEQUENCE:ltv_crl_authorityKeyIdentifier
crlNumber = SEQUENCE:ltv_crl_crlNumber

[ltv_crl_authorityKeyIdentifier]
extnID = OID:authorityKeyIdentifier
extnValue = OCTWRAP,SEQUENCE:ltv_crl_authorityKeyIdentifier_seq

[ltv_crl_authorityKeyIdentifier_seq]
keyIdentifier = IMPLICIT:0,FORMAT:HEX,OCTETSTRING:\
4c6d879382f72d2c0723a20fe0712d173f39f38f

[ltv_crl_crlNumber]
extnID = OID:crlNumber
extnValue = OCTWRAP,INTEGER:9

[ltv_crl_signatureAlgorithm]
algorithm = OID:sha256WithRSAEncryption
parameters = NULL</pre>

<p class="note">Il serait bien entendu possible de repartir du fichier <code>crl-CertificateList.asn.cnf</code>, en ayant pris le soin de supprimer le champ <code>revokedCertificates</code> et les sections correspondantes.</p>

<p>Générer la liste de certificats révoqués (LCR), et vérifier que son empreinte est identique à l'empreinte du fichier <code>data.cades-lt.crl.ltv.der</code>.</p>

<pre><strong>$ openssl asn1parse -genconf crl-LTV-CertificateList.asn.cnf -i \
  -out crl-LTV-CertificateList.der

$ openssl sha256 crl-LTV-CertificateList.der data.cades-lt.crl.ltv.der</strong>
SHA256(crl-LTV-CertificateList.der)= 5e46281a55a2ab7039efe80bafbf227bd945a830284
f48e72010f07b40e899ea
SHA256(data.cades-lt.crl.ltv.der)= 5e46281a55a2ab7039efe80bafbf227bd945a830284f4
8e72010f07b40e899ea</pre>

<h3 id="cades-lt-ltv">Construction de l'attribut <code>LongTermValidation</code></h3>

<p>La structure ASN.1 à spécifier pour constituer l'attribut <code>LongTermValidation</code> est la suivante, en remplaçant le choix (<code>CHOICE</code>) du champ <code>poeValue</code> par l'élément <code>timeStamp</code> retenu, de même pour <code>extraCertificates</code> qui contiendra uniquement (après résolution du <code>CHOICE</code>) des <code>Certificate</code> et pour <code>extraRevocation</code> qui contiendra uniquement des <code>CertificateList</code> :</p>

<pre>LongTermValidation ::= SEQUENCE {
  poeDate GeneralizedTime,
  timeStamp [0] EXPLICIT TimeStampToken,
  extraCertificates [0] IMPLICIT SET OF Certificate,
  extraRevocation [1] IMPLICIT SET OF CertificateList
}</pre>

<p>Créer le fichier <code>LongTermValidation.asn.cnf</code>, avec le contenu suivant (la valeur du champ <code>poeDate</code> est reprise du champ <code>genTime</code> de la structure <code>TSTInfo</code> encapsulée par le jeton d'horodatage à inclure dans l'attribut <code>LongTermValidation</code>).</p>

<pre>asn1 = SEQUENCE:LongTermValidation

[LongTermValidation]
poeDate = GENERALIZEDTIME:20120628204038Z
timeStamp = EXPLICIT:0,SEQUENCE:LTV_TST
extraCertificates = EXPLICIT:0,SET:extraCertificates
extraRevocation = EXPLICIT:1,SET:extraRevocation

[extraCertificates]
certificate_1 = SEQUENCE:tsa_certificate
certificate_2 = SEQUENCE:ca_certificate

[extraRevocation]
certificateList_1 = SEQUENCE:ltv_certificateList</pre>

<p>Copier à la suite toutes les sections des fichiers <code>LongTermValidation.TimeStampToken.asn.cnf</code>, <code>tsa-Certificate.asn.cnf</code>, <code>ca-Certificate.asn.cnf</code> et <code>crl-LTV-CertificateList.asn.cnf</code> (ne pas inclure la ligne <code>asn1 = …</code>).</p>

<p>Vérifier que l'attribut <code>LongTermValidation</code> peut être généré correctement à partir de ce fichier.</p>

<pre><strong>$ openssl asn1parse -genconf LongTermValidation.asn.cnf -i</strong></pre>

<h3 id="cades-lt-finalisation">Finalisation de la structure CAdES-LT</h3>

<p>Copier le fichier <code>data.cades-t.asn.cnf</code> sous le nom <code>data.cades-lt.asn.cnf</code>.</p>

<p>Modifier la section <code>unsignedAttrs</code> en ajoutant la ligne en gras ci-dessous.</p>

<pre>[unsignedAttrs]
attr_signatureTimeStamp = SEQUENCE:attr_signatureTimeStamp
<strong>attr_longTermValidation = SEQUENCE:attr_longTermValidation</strong></pre>

<p>Ajouter ensuite les sections suivantes, correspondant à l'attribut non signé <code>LongTermValidation</code>, à la fin du fichier.</p>

<pre>[attr_longTermValidation]
attrType = OID:LongTermValidation
attrValues = SET:attr_longTermValidation_values

[attr_longTermValidation_values]
attr_contentType_value = SEQUENCE:LongTermValidation</pre>

<p>Inclure à présent toutes les sections du fichier <code>LongTermValidation.asn.cnf</code> (la ligne <code>asn1 = …</code> ne doit pas être copiée).</p>

<p>Enfin, ajouter la ligne suivante dans le fichier <strong>cades-oid.tsv</strong>, pour déclarer l'OID de l'attribut <code>LongTermValidation</code>.</p>

<pre>0.4.0.1733.2.2 id-aa-ets-longTermValidation LongTermValidation</pre>

<p>Générer la structure CAdES-LT ainsi finalisée.</p>

<pre><strong>$ openssl asn1parse -genconf data.cades-lt.asn.cnf -i -oid cades-oid.tsv \
  -out data.cades-lt.der</strong></pre>

<p>Vérifier que la structure générée est une signature CMS valide.</p>

<pre><strong>$ openssl cms -verify -inform DER -in data.cades-t.der -content data.txt \
  -CAfile ca-crt.pem</strong>
texte en clairVerification successful</pre>

<h1 id="xades">Signature électronique avancée — XAdES</h1>


<p>À l'image de la CAdES, la norme XAdES<span class="fn">http://uri.etsi.org/01903/v1.4.1/</span> définit un ensemble de propriétés, dites qualifiantes, qui peuvent être incluses dans une signature électronique XML Signature, et dont certaines sont signées avec les données.</p>

<p>La norme XAdES définit également plusieurs formats de signature électronique, pour la plupart équivalents aux formats CAdES correspondants :</p>

<ul>
<li>XAdES-BES (<i>Basic Electronic Signature</i>, ou signature électronique de base) inclut le certificat du signataire (ou une référence à celui-ci) dans les éléments à signer, permet d'ajouter des propriétés complémentaires (telles que le lieu de signature et l'heure de signature) aux éléments à signer, et d'intégrer une contresignature en tant que propriété non signée.</li>
<li>XAdES-EPES (<i>Explicit Policy based Electronic Signature</i>, ou signature électronique avec politique explicite).</li>
<li>XAdES-T (T pour <i>time</i>, ou heure).</li>
<li>XAdES-C (C pour <i>complete validation data references</i>, ou références complètes aux données de validation) complète le format XAdES-T avec les certificats et informations de révocation permettant de valider la signature électronique.</li>
<li>XAdES-X (<i>extended signature with time indication forms</i>, ou signature étendue avec formes d'indicateur d'heure) complète une structure XAdES contenant des références aux données de validation (typiquement une structure XAdES-C) en ajoutant aux propriétés non signées un ou plusieurs jetons d'horodatage portant soit sur la signature initiale, une éventuelle heure de signature fiable, et les références aux données de validation (XAdES-X de type 1), soit sur les références aux données de validation uniquement (XAdES-X de type 2).</li>
<li>XAdES-X-L (<i>extended long signature with time</i>, ou signature longue étendue avec heure) ajoute à une structure XAdES-X les données de validation référencées.</li>
<li>XAdES-A (<i>archival signature</i>, ou signature pour archivage) ajoute aux propriétés non signées d'une structure XAdES des données de validation si elles ne sont pas déjà présentes, et un ou plusieurs jetons d'horodatage portant sur la signature et ces données. Afin de permettre la validation de la signature dans le temps, une signature enrichie au niveau XAdES-A peut être réhorodatée de manière à en prolonger la durée de validité.</li>
</ul>

<p class="note">La conformité à la norme XAdES n'impose pas d'être en capacité de produire ou de vérifier les formats XAdES-X, XAdES-X-L et XAdES-A.</p>

<p>La suite de ce chapitre s'intéresse à la construction d'une signature XAdES-A minimale. Pour cela, le fichier modèle <code>data.dsig-tmpl.xml</code>, à la base de signature enveloppée créée dans la section <a href="#signature-fichier" class="section"/>, est complété avec les éléments nécessaires à la constitution d'une structure XAdES-BES, puis celle-ci est successivement enrichie avec les données permettant d'obtenir une signature avancée au format XAdES-T, puis XAdES-A. La version 1.4.2 de XAdES est utilisée.</p>

<h2 id="xades-bes">Constitution de la structure XAdES-BES</h2>

<p>La structure XAdES-BES à constituer est dotée de l'arborescence suivante :</p>

<pre>ds:Signature (1)
  ds:SignedInfo
    ds:CanonicalizationMethod
    ds:SignatureMethod
    ds:Reference
      …
    ds:Reference (2)
      …
  ds:SignatureValue
  ds:KeyInfo
    …
  ds:Object (3)
    xades:QualifyingProperties (4)
      xades:SignedProperties (5)
        …</pre>

<p class="note">Le préfixe <code>ds:</code> représente l’espace de nommage <code>http://www.w3.org/2000/09/xmldsig#</code>, et le préfixe <code>xades:</code> représente <code>http://uri.etsi.org/01903/v1.3.2#</code>.</p>

<p class="note">L'espace de nommage représenté par <code>xades:</code> fait référence à la version 1.3.2 de XAdES. Un espace de nommage complémentaire, introduit dans la version 1.4.1 de XAdES et portant le préfixe <code>xadesv141</code>, est utilisé plus loin pour les jetons d'horodatage spécifiques à XAdES-A. La version 1.4.2 de la norme corrige simplement quelques coquilles dans le schéma XML de XAdES, mais le préfixe et le nom de l'espace de nommage maintiennent la référence à la version 1.4.1.</p>

<p>Les modifications à apporter au modèle de signature XML Signature utilisé dans la section <a href="#signature-fichier" class="section"/> pour obtenir un modèle de signature XAdES-EBES sont les suivantes :</p>

<ul>
<li>L'élément <code>ds:Signature</code>, au nœud 1 du schéma précédent, se voit enrichi d'un attribut <code>Id</code>, lequel est référencé par les propriétés qualifiant la signature (nœud 4).</li>
<li>Les propriétés signées, contenues dans l'élément <code>xades:SignedProperties</code> (nœud 5), doivent — comme leur nom l'indique — être signées : un nouvel élément <code>ds:Reference</code> est ajouté (nœud 2) sous <code>ds:SignedInfo</code>, aux côtés de l'élément <code>ds:Reference</code> référençant les données à signer (en l'occurrence l'ensemble du document XML).</li>
<li>Un élément <code>ds:Object</code> (nœud 3) est ajouté sous <code>ds:Signature</code> pour stocker les propriétés qualifiant la signature dans un élément <code>xades:QualifyingProperties</code> (nœud 4), lequel contient notamment les propriétés qualifiantes signées (nœud 5).</li>
</ul>

<p>Créer le fichier <code>data.xades-bes-tmpl.xml</code> suivant, évolution du fichier <code>data.dsig-tmpl.xml</code> intégrant ces modifications (mises en évidence en gras).</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data>Texte en clair</data>
  <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ]]><strong>Id="Id_Signature"</strong><![CDATA[>
    <ds:SignedInfo>
      <ds:CanonicalizationMethod
        Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
      <ds:SignatureMethod
        Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
      <ds:Reference URI="">
        <ds:Transforms>
          <ds:Transform
            Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          <ds:Transform
            Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        </ds:Transforms>
        <ds:DigestMethod 
          Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue/>
      </ds:Reference>]]>
<strong><![CDATA[      <ds:Reference URI="#Id_SignedProperties">
        <ds:Transforms>
          <ds:Transform 
            Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        </ds:Transforms>
        <ds:DigestMethod 
          Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue/>
      </ds:Reference>]]></strong>
<![CDATA[    </ds:SignedInfo>
    <ds:SignatureValue/>
    <ds:KeyInfo>
      <ds:X509Data>
        <ds:X509Certificate/>
      </ds:X509Data>
    </ds:KeyInfo>]]>
<strong><![CDATA[    <ds:Object>
      <xades:QualifyingProperties Target="#Id_Signature" 
        xmlns:xades="http://uri.etsi.org/01903/v1.3.2#">
        <xades:SignedProperties Id="Id_SignedProperties">
          <xades:SignedSignatureProperties>
            <xades:SigningTime>2012-06-17T15:23:00Z</xades:SigningTime>
            <xades:SignatureProductionPlace>
              <xades:CountryName>France</xades:CountryName>
            </xades:SignatureProductionPlace>
          </xades:SignedSignatureProperties>
        </xades:SignedProperties>
      </xades:QualifyingProperties>
    </ds:Object>]]></strong>
<![CDATA[  </ds:Signature>
</root>]]></pre>

<p class="note">Le choix des propriétés signées <code>xades:SigningTime</code> et <code>xades:SignatureProductionPlace</code> est arbitraire.</p>
<div class="longnote">
<p class="notetitle">Validation par rapport aux schémas XML</p>
<p>Par précaution, il est judicieux de contrôler que les fichiers XML contenant des signatures XAdES sont conformes aux schémas XML de référence de XML Signature et de XAdES.</p>
<p>Télécharger les schémas XML de XML Signature<span class="fn">http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd</span> et de XAdES<span class="fn">http://uri.etsi.org/01903/v1.3.2/XAdES.xsd</span> dans le répertoire de <code>data.xml</code>, puis valider la conformité des éléments <code>ds:Signature</code> et <code>xades:QualifyingProperties</code> par rapport à ces schémas à l'aide de l'option <code>--schema</code> de <code>xmllint</code>.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t |
  -c /root/ds:Signature data.xades-bes-tmpl.xml | xmllint \
  --schema xmldsig-core-schema.xsd --noout -</strong>
- validates

<strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t \
  -c /root/ds:Signature/ds:Object/xades:QualifyingProperties \
  data.xades-bes-tmpl.xml | xmllint --schema XAdES.xsd --noout -</strong>
- validates</pre>

<p>Ces opérations peuvent être répétées pour contrôler la validité structurelle des autres formats XAdES.</p>

<p>Dans un souci d'exhaustivité, créer le fichier XML Schema <code>data-dsig.xsd</code> associé aux versions signées du fichier <code>data.xml</code> dans le même répertoire que ci-dessus :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
    elementFormDefault="qualified" attributeFormDefault="unqualified">
    <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
        schemaLocation="xmldsig-core-schema.xsd"/>
    <xs:element name="root">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="data"/>
                <xs:element ref="ds:Signature"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>]]></pre>

<p>Valider le fichier <code>data.xml</code> par rapport à ce schéma :</p>
<pre><strong>$ xmllint --schema data-dsig.xsd --noout data.xades-bes-tmpl.xml</strong>
data.xades-bes-tmpl.xml validates</pre>
</div>

<p>Générer la signature électronique XAdES-BES.</p>

<pre><strong>$ xmlsec --sign --privkey-pem ee-key.pem,ee-crt-authsig.pem \
  --output data.xades-bes.xml data.xades-bes-tmpl.xml</strong></pre>

<p class="note">Dans le fichier généré, le premier élément <code>ds:Reference</code> est identique à l'élément <code>ds:Reference</code> du fichier <code>data.dsig.xml</code>, puisque dans les deux cas les données référencées, à savoir l'ensemble du document XML à l'exception du nœud <code>ds:Signature</code>, sont identiques.</p>

<p>Vérifier la signature :</p>

<pre><strong>$ xmlsec --verify --trusted-pem ca-crt.pem data.xades-bes.xml</strong>
OK
SignedInfo References (ok/all): 2/2
Manifests References (ok/all): 0/0</pre>

<p class="note">Ce processus valide les deux éléments <code>ds:Reference</code> contenus sous le nœud <code>ds:SignedInfo</code>.</p>

<h2 id="xades-t">Constitution de la structure XAdES-T</h2>

<p>Parmi les deux possibilités offertes par la norme XAdES, celle retenue ci-après pour construire la signature XAdES est de générer un jeton d'horodatage et de l'inclure dans un élément <code>xades:SignatureTimeStamp</code> parmi les propriétés non signées de la signature.</p>
<p>La structure <code>ds:Signature</code> ainsi générée est schématisée ci-dessous, où le nœud 1 représente un nouvel élément, <code>xades:UnsignedProperties</code>, à créer sous <code>xades:QualifyingProperties</code> pour stocker les propriétés non signées, le nœud 2 encapsule les propriétés non signées portant sur la signature, et le nœud 3 contient le jeton d'horodatage.</p>

<pre>ds:Signature
  ds:SignedInfo
    …
  ds:Object
    xades:QualifyingProperties
      xades:SignedProperties
        …
      xades:UnsignedProperties (1)
        xades:UnsignedSignatureProperties (2)
          xades:SignatureTimeStamp (3)</pre>

<p>La première étape est de générer la requête d'horodatage.</p>

<p>La donnée à horodater est l'élément XML <code>ds:SignatureValue</code> sous le nœud <code>ds:Signature</code> représentant la signature électronique considérée, après canonicalisation par l'algorithme indiqué dans l'élément <code>xades:SignatureTimeStamp</code> s'il est présent, sinon l'algorithme de canonicalisation par défaut de XML Signature. Dans le cas présent, l'algorithme de canonicalisation exclusive est utilisé.</p>

<p>Extraire l'élément <code>ds:Signature</code> de la signature XAdES-BES générée précédemment, le canonicaliser et calculer l'empreinte SHA-256 des données obtenues.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t \
  -c /root/ds:Signature/ds:SignatureValue data.xades-bes.xml \
  | xmllint --exc-c14n - | openssl sha256</strong>
(stdin)= 6ad678e8370e1eba4516e643b9f5316f7235f24d1fc5761f03d992dae754fb32</pre>

<p>Générer à présent une requête d'horodatage portant sur cette empreinte en utilisant l'option <code>-digest</code> de la commande <code>openssl ts</code>.</p>

<pre><strong>$ openssl ts -query \
  -digest 6ad678e8370e1eba4516e643b9f5316f7235f24d1fc5761f03d992dae754fb32 \
  -sha256 -out SignatureTimeStamp.tsq</strong></pre>

<p>Produire la réponse à cette requête :</p>

<pre><strong>$ openssl ts -reply -config tsa-ts.cnf -section tsa \
  -queryfile SignatureTimeStamp.tsq -inkey tsa-key.pem -signer tsa-crt.pem \
  -out SignatureTimeStamp.tsr</strong>
Using configuration from tsa-ts.cnf
Response has been generated.</pre>

<p>La version 1.4.1 de XAdES précise bien que le jeton d'horodatage à inclure dans la signature est le champ <code>timeStampToken</code> de la réponse, et non la réponse elle-même.</p>

<p>Extraire le jeton d'horodatage de cette réponse.</p>

<pre><strong>$ openssl ts -reply -in SignatureTimeStamp.tsr -token_out \
  -out SignatureTimeStamp.tst</strong></pre>

<p>Coder le jeton en Base64.</p>

<pre><strong>$ openssl base64 -in SignatureTimeStamp.tst</strong>
MIIC1AYJKoZIhvcNAQcCoIICxTCCAsECAQMxCzAJBgUrDgMCGgUAMIGOBgsqhkiG
9w0BCRABBKB/BH0wewIBAQYkKoZIhvcUAb5Ak3qC8U+DpxmD4GyBn36CuiCEgKIr
hZ3WYgEFMDEwDQYJYIZIAWUDBAIBBQAEIGrWeOg3Dh66RRbmQ7n1MW9yNfJNH8V2
HwPZktrnVPsyAgEDGA8yMDEyMDYyMjE5NDQ1OVoCCQCVo26o8wA/ZjGCAhwwggIY
AgEBMGYwWTELMAkGA1UEBhMCRlIxFzAVBgNVBAoTDk1vbiBFbnRyZXByaXNlMRcw
FQYDVQQLEw4wMDAyIDEyMzQ1Njc4OTEYMBYGA1UECxMPT3BlblNTTCBSb290IENB
AgkA07lPBN3RoEAwCQYFKw4DAhoFAKCBjDAaBgkqhkiG9w0BCQMxDQYLKoZIhvcN
AQkQAQQwHAYJKoZIhvcNAQkFMQ8XDTEyMDYyMjE5NDQ1OVowIwYJKoZIhvcNAQkE
MRYEFAhO9tLfAkFk+4leqen/ln+SYkn3MCsGCyqGSIb3DQEJEAIMMRwwGjAYMBYE
FEMopucZySTSxBTCSucZUJOVYcUJMA0GCSqGSIb3DQEBAQUABIIBAC6z7djc4yv8
v3LjJRSR+zjJs2MV1VbdRNZ6EZnnqOspZseQUS5kHgD0oT36C0GtDhDgH1W6HDSq
unSMWxIOG08Kq/ypM+6NsD4xld6iggB8JXpHPvTet638rZrNmMiE9lzFFqfPoJsn
xElYIJzf9xLKE+tmUopyXCa69Qwxh5NAMZYiFfkXtvBtxf8+feAuYStD7lH6AQQk
eamF8k0gULz5EuYslj+II8gJHQPfM3hTiocrh0p5T8c6qrrpZ9WAOROmj6/VIdYx
OUEnq4ws8YrvhVi5r+E9K63drt7WJh3rwWONcyoo81zqVwK2RMtBZQG38qOOuUA8
E1vsanzHS1g=</pre>

<p>Enfin, copier le fichier <code>data.xades-bes.xml</code> sous le nom <code>data.xades-t.xml</code>, et ajouter dans celui-ci les éléments mis en évidence en gras ci-dessous pour obtenir la structure XAdES-T (la valeur de l'élément <code>xades:EncapsulatedTimeStamp</code> est le codage en Base64 du jeton d'horodatage obtenu ci-avant) :</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data>Texte en clair</data>
  <ds:Signature …>
    …
    <ds:Object>
      <xades:QualifyingProperties …>
        <xades:SignedProperties …>
          …
        </xades:SignedProperties>]]>
<strong><![CDATA[        <xades:UnsignedProperties>
          <xades:UnsignedSignatureProperties>
            <xades:SignatureTimeStamp>
              <ds:CanonicalizationMethod
                Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
              <xades:EncapsulatedTimeStamp>
MIIC1AYJKoZIhvcNAQcCoIICxTCCAsECAQMxCzAJBgUrDgMCGgUAMIGOBgsqhkiG
…
E1vsanzHS1g=
              </xades:EncapsulatedTimeStamp>
            </xades:SignatureTimeStamp>
          </xades:UnsignedSignatureProperties>
        </xades:UnsignedProperties>]]></strong>
<![CDATA[      </xades:QualifyingProperties>
    </ds:Object>
  </ds:Signature>
</root>]]></pre>

<p class="note">L'élément <code>xades:EncapsulatedTimeStamp</code> est de type <code>xades:EncapsulatedPKIDataType</code>, et contient donc par défaut le codage en Base64 de la représentation DER du jeton d'horodatage, à moins qu'un attribut <code>Encoding</code> ne précise un autre type de codage (se reporter à la section 7.1.3 de la norme XAdES pour plus d'informations).</p>

<p>Vérifier que la signature est toujours valide, et que l'élément <code>xades:QualifyingProperties</code> reste conforme au schéma XML de XAdES.</p>

<div class="note"><p>La structure obtenue peut être visualisée à l'aide de l'un des moyens suivants.</p>
<p>Avec la commande <code>du</code> du shell de l'outil <code>xmllint</code>, en perdant les préfixes des espaces de nommage :</p>
<pre><strong>xmllint --shell data.xades-t.xml
/ > du</strong>
/
root
  data
  Signature
    SignedInfo
…
              CanonicalizationMethod
              EncapsulatedTimeStamp</pre>
<p>En combinant la commande <code>xml el</code> avec une expression régulière Perl (penser à remplacer les apostrophes par des guillemets sous Windows) :</p>
<pre><strong>$ xml el data.xades-t.xml | perl -pe 's/(.*?)\//  /g'</strong>
root
  data
  ds:Signature
    ds:SignedInfo
      ds:CanonicalizationMethod
      ds:SignatureMethod
      ds:Reference
        ds:Transforms
          ds:Transform
          ds:Transform
        ds:DigestMethod
        ds:DigestValue
      ds:Reference
        ds:Transforms
          ds:Transform
        ds:DigestMethod
        ds:DigestValue
    ds:SignatureValue
    ds:KeyInfo
      ds:X509Data
        ds:X509Certificate
    ds:Object
      xades:QualifyingProperties
        xades:SignedProperties
          xades:SignedSignatureProperties
            xades:SigningTime
            xades:SignatureProductionPlace
              xades:CountryName
        xades:UnsignedProperties
          xades:UnsignedSignatureProperties
            xades:SignatureTimeStamp
              ds:CanonicalizationMethod
              xades:EncapsulatedTimeStamp</pre>
</div>

<h2 id="xades-a">Constitution de la structure XAdES-A</h2>

<p>La structure XAdES-A doit inclure l'ensemble des données de certification et de révocation permettant de valider la signature.</p>

<p class="note">Attention, tout comme pour CAdES-LT dans <a href="#cades-lt" class="section"/>, la structure produite ci-après n'a pas été validée par un outil tiers : les <i>Plugtests</i> de l'ETSI évoqués dans cette section s'intéressent également à l'interopérabilité des formats CAdES.</p>

<p>Copier le fichier <code>data.xades-t.xml</code> sous le nom <code>data.xades-a.xml</code>.</p>

<h3 id="xades-a-certificat-horodatage">Ajout du certificat de l'unité d'horodatage</h3>

<p>L'élément <code>xadesv141:TimeStampValidationData</code> introduit dans la version 1.4.1 de XAdES permet de définir, en tant que propriété non signée, les données de certification et de révocation associées à un jeton d'horodatage.</p>

<p class="note">La norme XAdES est assez ouverte quant à ce qui peut ou doit être fait de ces données : s'attendre à des comportements différents de la part des outils de validation des signatures électroniques avancées.</p>

<p>Ajouter cet élément au fichier <code>data.xades-a.xml</code> pour inclure le certificat de l'unité d'horodatage, comme mis en évidence ci-dessous en gras. La valeur de l'élément <code>xades:EncapsulatedX509Certificate</code> est le codage en Base64 de la représentation DER du certificat de l'unité d'horodatage (contenu au format PEM dans le fichier <code>tsa-crt.pem</code>). Ajouter par ailleurs la déclaration de l'espace de nommage associé au préfixe <code>xadesv141</code> à l'élément <code>xades:QualifyingProperties</code>.</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<root>
  <data>Texte en clair</data>
  <ds:Signature …>
    …
    <ds:Object>
      <xades:QualifyingProperties 
        xmlns:xades="http://uri.etsi.org/01903/v1.3.2#" 
        ]]><strong><![CDATA[xmlns:xadesv141="http://uri.etsi.org/01903/v1.4.1#"]]></strong><![CDATA[
        Target="#Id_Signature">
        <xades:SignedProperties …>
          …
        </xades:SignedProperties>
        <xades:UnsignedProperties>
          <xades:UnsignedSignatureProperties>
            <xades:SignatureTimeStamp>
              …
            </xades:SignatureTimeStamp>]]>
<strong><![CDATA[            <xadesv141:TimeStampValidationData URI="#Id_SignatureTimeStamp">
              <xades:CertificateValues>
                <xades:EncapsulatedX509Certificate>
MIIECTCCAvGgAwIBAgIJANO5TwTd0aBAMA0GCSqGSIb3DQEBCwUAMFkxCzAJBgNV
…
AV/tKdbvqHOWSpN7XLY+E0y4WNi7G1L9Ue3IyZo=
                </xades:EncapsulatedX509Certificate>            
              </xades:CertificateValues>            
            </xadesv141:TimeStampValidationData>]]></strong>
<![CDATA[          </xades:UnsignedSignatureProperties>
        </xades:UnsignedProperties>
      </xades:QualifyingProperties>
    </ds:Object>
  </ds:Signature>
</root>]]></pre>

<p>Bien que cela ne soit pas imposé par XAdES, ajouter l'attribut <code>URI</code> à l'élément <code>xadesv141:TimeStampValidationData</code> pour faire référence à un élément représentant un jeton d'horodatage, à l'exemple de <code>xades:SignatureTimeStamp</code>, identifié par son attribut <code>Id</code>, comme illustré ci-dessous, les nouveaux attributs étant en gras.</p>
<pre><![CDATA[…
              <xades:EncapsulatedTimeStamp ]]><strong><![CDATA[Id="Id_SignatureTimeStamp"]]></strong><![CDATA[>
                …
              </xades:EncapsulatedTimeStamp>
            </xades:SignatureTimeStamp>
            <xadesv141:TimeStampValidationData ]]><strong><![CDATA[URI="#Id_SignatureTimeStamp"]]></strong><![CDATA[>
              …
            </xadesv141:TimeStampValidationData>]]>
…</pre>

<p class="note">Préciser à quel jeton d'horodatage se rapportent les données de validation et de révocation se révèle particulièment opportun lorsque plusieurs éléments <code>xadesv141:TimeStampValidationData</code> figurent dans la signature, avec par exemple des listes de révocation émises par la même autorité de certification à des dates différentes selon la date de production du jeton d'horodatage.</p>

<h3 id="xades-a-certificat-ac">Ajout du certificat de l'autorité de certification</h3>

<p>Le certificat de l'autorité de certification émettrice du certificat du signataire et de la liste de certificats de révoqués, qui ne figure pas dans la structure XAdES-T constituée précédemment, doit être ajoutés au titre des données de certification dans une propriété non signée sous l'élément <code>xades:CertificateValues</code>.</p>

<p>Ajouter à la signature électronique l'élément <code>xades:CertificateValues</code>, mis en évidence en gras ci-dessous (la valeur de l'éléments <code>xades:EncapsulatedX509Certificate</code> est le codage en Base64 de la représentation DER du certificat de l'autorité de certification) :</p>

<pre><![CDATA[…
        <xades:UnsignedProperties>
          <xades:UnsignedSignatureProperties>
            <xades:SignatureTimeStamp>
              …
            </xades:SignatureTimeStamp>
            <xadesv141:TimeStampValidationData …>
              …
            </xadesv141:TimeStampValidationData>]]>
<strong><![CDATA[            <xades:CertificateValues>
              <xades:EncapsulatedX509Certificate>
MIIDzTCCArWgAwIBAgIJAKyq/y+d6TxTMA0GCSqGSIb3DQEBCwUAMFkxCzAJBgNV
…
CjwwOVRwkQWzkd/abXwywbs=
              </xades:EncapsulatedX509Certificate>
            </xades:CertificateValues>]]></strong>
<![CDATA[          </xades:UnsignedSignatureProperties>
        </xades:UnsignedProperties>
…]]></pre>

<h3 id="xades-a-lcr">Ajout de la liste de certificats révoqués</h3>

<p>Mettre à jour la liste de certificats révoqués si elle a expiré.</p>

<pre><strong>$ openssl ca -gencrl -cert ca-crt.pem -keyfile ca-key.pem -crlhours 48 \
-md sha256 -config ca-crl.cnf -name ca_crl -crlexts ca_crl_ext \
-out ca-crl.pem</strong></pre>

<p>Ajouter le codage en Base64 de la liste de certificats révoqués (le fichier généré sans les balises PEM) au fichier <code>data.xades-a.xml</code>, dans un élément <code>xades:CRLValues/xades:EncapsulatedCRLValue</code> d'une nouvelle propriété non signée <code>xades:RevocationValues</code>, comme ci-dessous en gras :</p>

<pre><![CDATA[…
        <xades:UnsignedProperties>
          <xades:UnsignedSignatureProperties>
            <xades:SignatureTimeStamp>
              …
            </xades:SignatureTimeStamp>
            <xadesv141:TimeStampValidationData …>
              …
            </xadesv141:TimeStampValidationData>
            <xades:CertificateValues>
              …
            </xades:CertificateValues>]]>
<strong><![CDATA[            <xades:RevocationValues>
              <xades:CRLValues>
                <xades:EncapsulatedCRLValue>
MIIB0zCBvAIBATANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJGUjEXMBUGA1UE
ChMOTW9uIEVudHJlcHJpc2UxFzAVBgNVBAsTDjAwMDIgMTIzNDU2Nzg5MRgwFgYD
VQQLEw9PcGVuU1NMIFJvb3QgQ0EXDTEyMDYyMjIwMjg1NloXDTEyMDYyNDIwMjg1
NlqgLzAtMB8GA1UdIwQYMBaAFExth5OC9y0sByOiD+BxLRc/OfOPMAoGA1UdFAQD
AgEDMA0GCSqGSIb3DQEBCwUAA4IBAQB34WzWDW4Al2Za/JMZ68CVpMnSpD5mzeGm
vvT/LRHH0yR6xCCfiwdorCF2rYyYrg3lynnrfSInYVrZclfQWF5TkwBfQONebY+Q
4NEcXiKfkYJuca5W44YnIUfHDEQVVD1tTqbDECxcFmG/UukqflprXmMHra1RdI8h
4SrK7aac5yJiTxC+QJhOVDybpyz7Tco3lDpH4uobv3OCZD0+20ZBfEzy5Kce3PUV
7h+XGW/2/fRXxvBk3DVVSyPAqq069trZAPQiM6tproFGPJAXA3FgTHEqxGTIPpEf
WXqkwe2GzFTz6bxBd4qWEPEUk0ViHDB+FHdZshL5hDH8e+gEATF+
                </xades:EncapsulatedCRLValue>
              </xades:CRLValues>
            </xades:RevocationValues>
]]></strong>
<![CDATA[          </xades:UnsignedSignatureProperties>
        </xades:UnsignedProperties>
…]]></pre>

<p>Sauvegarder le fichier <code>data.xades-a.xml</code> obtenu à ce stade.</p>

<h3 id="xades-a-jeton-horodatage-archivage">Ajout d'un jeton d'horodatage d'archivage</h3>

<p>Le jeton d'horodatage d'archivage en cours de constitution aura la forme suivante :</p>

<pre><![CDATA[<xadesv141:ArchiveTimeStamp Id="Id_ArchiveTimeStamp">
  <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
  <xades:EncapsulatedTimeStamp>
…
  </xades:EncapsulatedTimeStamp>
</xadesv141:ArchiveTimeStamp>]]></pre>

<p>Les données à horodater référencées dans le jeton d'horodatage d'archivage sont constituées en suivant les étapes décrites dans la section 8.2.1 de la version 1.4.2 de la norme XAdES : l'algorithme de canonicalisation exclusive doit être utilisé lorsque la procédure indique que des données XML doivent être canonicalisées.</p>

<p class="note">Sous Windows, ne pas oublier de systématiquement faire suivre l'opération de canonicalisation de la commande <code>| tr -d "\r"</code> (cf. section <a href="#verification-manuelle-xml-signature" class="section"/>).</p>

<p>Le premier élément <code>ds:Reference</code> à traiter est le suivant :</p>

<pre><![CDATA[<ds:Reference URI="">
  <ds:Transforms>
    <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
    <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
  </ds:Transforms>
  <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
  <ds:DigestValue>o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=</ds:DigestValue>
</ds:Reference>
]]></pre>

<p>L'extraction et le traitement de la référence correspondante a été décrite dans la section <a href="#verification-manuelle-signature" class="section"/>. Les explications ne sont pas reprises, seules les commandes à effectuer sont fournies.</p>

<pre><strong>$ xsltproc enveloped-signature.xslt data.xades-a.xml | xmllint --exc-c14n - \
  > data.xades-a.Reference-1.bin</strong></pre>

<p class="note">Strictement parlant, il faudrait canonicaliser la référence extraite, mais celle-ci ayant déjà été canonicalisée dans le cadre des transformations à appliquer (élément <code>ds:Transforms</code>), une canonicalisation supplémentaire n'aurait aucun impact.</p>

<div class="note"><p>En profiter pour vérifier que l'empreinte du fichier produit correspond à la valeur de l'élément <code>ds:DigestValue</code>, comme vu dans la section <a href="#verification-manuelle-signature" class="section"/>, page <a href="#verification-digestvalue" class="page"/>.</p>
<pre><strong>$ openssl sha256 -binary data.xades-a.Reference-1.bin | openssl base64</strong>
o00jEBylngTpuEsjOe+RkjwymUf5e+wiDE151+Z7Zv0=</pre></div>

<p>Le deuxième élément <code>ds:Reference</code> à traiter, correspondant aux propriétés signées de la signature XAdES, est le suivant :</p>

<pre><![CDATA[<ds:Reference URI="#Id_SignedProperties">
  <ds:Transforms>
    <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
  </ds:Transforms>
  <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
  <ds:DigestValue>qhZevqabDRuLtLVoiPDSsryPHAkzf4EFUYFyvvcbLCk=</ds:DigestValue>
</ds:Reference>]]></pre>

<p>Extraire et canonicaliser le nœud XML référencé, identifié par l'attribut <code>Id</code> de valeur <code>Id_SignedProperties</code>, et correspondant donc à l'expression XPath <code>//*[@Id='Id_SignedProperties']</code>.</p>

<pre><strong>$ xml sel -t -c //*[@Id='Id_SignedProperties'] data.xades-a.xml \
  | xmllint --exc-c14n - > data.xades-a.Reference-2.bin</strong></pre>
  
<div class="note"><p>Vérifier que l'empreinte SHA-256 du fichier obtenu concorde avec la valeur de l'élément <code>ds:DigestValue</code>.</p>
<pre><strong>$ openssl sha256 -binary data.xades-a.Reference-2.bin | openssl base64</strong>
qhZevqabDRuLtLVoiPDSsryPHAkzf4EFUYFyvvcbLCk=</pre></div>

<p class="note">Les éléments à hacher pour constituer les données à horodater sont extraits séparément, et seront concaténés une fois tous extraits. Il est bien entendu possible de concaténer les fichiers au fur et à mesure en utilisant la redirection double<code>>> data.xades-a.ArchiveTimeStamp.data_to_hash.bin</code>… dont la contrepartie est d'être plus compliquée à démêler en cas d'erreur.</p>

<p>Ensuite, extraire et canonicaliser les éléments <code>ds:SignedInfo</code>, <code>ds:SignatureValue</code> et <code>ds:KeyInfo</code>.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -c /root/ds:Signature/ds:SignedInfo data.xades-a.xml | xmllint --exc-c14n - \
  > data.xades-a.SignedInfo.bin

$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -c /root/ds:Signature/ds:SignatureValue data.xades-a.xml \
  | xmllint --exc-c14n - > data.xades-a.SignatureValue.bin

$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# -t \
  -c /root/ds:Signature/ds:KeyInfo data.xades-a.xml | xmllint --exc-c14n - \
  > data.xades-a.KeyInfo.bin</strong></pre>

<p>Extraire et canonicaliser chacune des propriétés non signées (les chemins XPath sont à saisir sur une seule ligne).</p>

<div class="note"><p>Pour référence les propriétés non signées sont mises en évidence en gras ci-dessous :</p>
<pre>root
  data
  ds:Signature
    …
    ds:Object
      xades:QualifyingProperties
        …
        xades:UnsignedProperties
          xades:UnsignedSignatureProperties
            <strong>xades:SignatureTimeStamp</strong>
              ds:CanonicalizationMethod
              xades:EncapsulatedTimeStamp
            <strong>xadesv141:TimeStampValidationData</strong>
              xades:CertificateValues
                xades:EncapsulatedX509Certificate
            <strong>xades:CertificateValues</strong>
              xades:EncapsulatedX509Certificate
            <strong>xades:RevocationValues</strong>
              xades:CRLValues
                xades:EncapsulatedCRLValue</pre></div>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t \
  -c /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedPrope
rties/xades:UnsignedSignatureProperties/xades:SignatureTimeStamp \
  data.xades-a.xml | xmllint --exc-c14n - | tr -d "\r" \
  > data.xades-a.SignatureTimeStamp.bin</strong></pre>

<p>Avant d'extraire la propriété non signée suivante, <code>xadesv141:TimeStampValidationData</code>, une remarque s'impose : la commande <code>xml sel</code> supporte un maximum de deux options globales… or ce sont les options globales qui permettent de définir les espaces de nommage et leur préfixe, et les propriétés non signées d'une signature XAdES-A mettent en jeu trois espaces de nommage (représentés par les préfixes <code>ds</code>, <code>xades</code> et <code>xadesv141</code>).</p>

<div class="note"><p>La ligne en cause se situe dans le fichier <code>src/xml_select.c</code> du code source XMLStarlet :</p>
<pre>#define TEMPLATE_OPT_MAX_ARGS 2</pre></div>

<p>Une solution possible est de générer un fichier XSLT, inspiré par exemple de celle générée par la commande <code>xml sel -C</code>, pour chaque chemin XPath à extraire. Une méthode plus pratique serait de pouvoir passer le chemin XPath en tant que paramètre d'une transformation XSLT, mais cela n'est pas possible avec la version 1.0 de XSLT, qui est celle implémentée par <code>xsltproc</code>. Heureusement, <code>xsltproc</code> supporte des extensions EXSLT, au nombre desquelles la fonction <code>dyn:evaluate</code><span class="fn">http://www.exslt.org/dyn/functions/evaluate/index.html</span> (<code>dyn</code> est le préfixe pour l'espace de nommage <code>http://exslt.org/dynamic</code>), qui évalue une chaîne de caractères en tant qu'expression XPath.</p>

<p>Créer le fichier XSLT <code>extractxpath.xslt</code> suivant pour exploiter cette fonctionnalité.</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xades="http://uri.etsi.org/01903/v1.3.2#"
  xmlns:xadesv141="http://uri.etsi.org/01903/v1.4.1#"
  xmlns:dyn="http://exslt.org/dynamic"
  extension-element-prefixes="dyn">
  
  <xsl:output indent="no" omit-xml-declaration="yes"/>

  <xsl:param name="xpath"/>

  <xsl:template match="/">
    <xsl:call-template name="extractXPath"/>
  </xsl:template>
  
  <xsl:template name="extractXPath">
    <xsl:copy-of select="dyn:evaluate($xpath)"/>
  </xsl:template>
</xsl:stylesheet>]]></pre>

<p>Utiliser ce fichier XSLT pour extraire la propriété non signée <code>xadesv141:TimeStampValidationData</code>, puis canonicaliser le résultat.</p>

<pre><strong>$ xsltproc --stringparam xpath \
  /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedProperti
es/xades:UnsignedSignatureProperties/xadesv141:TimeStampValidationData[1] \
  extractxpath.xslt data.xades-a.xml | xmllint --exc-c14n - \
  > data.xades-a.TimeStampValidationData.bin</strong></pre>

<p class="note">Noter que l'index <code>[1]</code> de l'élément <code>xadesv141:TimeStampValidationData</code> est préciser, en prévision du fait que plusieurs de ces éléments peuvent figurer dans une signature au format XAdES-A.</p>

<p>Extraire les propriétés non signées suivantes.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t -c \
  /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedProperti
es/xades:UnsignedSignatureProperties/xades:CertificateValues data.xades-a.xml \
  | xmllint --exc-c14n - > data.xades-a.CertificateValues.bin

$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t -c \
  /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedProperti
es/xades:UnsignedSignatureProperties/xades:RevocationValues data.xades-a.xml \
  | xmllint --exc-c14n - > data.xades-a.RevocationValues.bin</strong></pre>

<div class="note"><p>La syntaxe alternative suivante peut évidemment être utilisée, avec le même résultat (comparer les empreintes pour s'en assurer) :</p>
<pre><strong>$ xsltproc --stringparam xpath \
  /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedProperti
es/xades:UnsignedSignatureProperties/xades:CertificateValues extractxpath.xslt \
  data.xades-a.xml | xmllint --exc-c14n - > data.xades-a.CertificateValues.bin

$ xsltproc --stringparam xpath \
  /root/ds:Signature/ds:Object/xades:QualifyingProperties/xades:UnsignedProperti
es/xades:UnsignedSignatureProperties/xades:RevocationValues extractxpath.xslt \
  data.xades-a.xml | xmllint --exc-c14n - > data.xades-a.RevocationValues.bin</strong></pre></div>

<div class="note"><p>Si le lecteur utilise les mêmes données que celles fournies dans le présent document, alors il pourra vérifier qu'il obtient les mêmes nœuds extraits et canonicalisés en vérifiant que les empreintes des fichiers <code>.bin</code> sont identiques aux valeurs ci-dessous.</p>
<pre><strong>$ openssl sha256 data.xades-a.*.bin</strong>
SHA256(data.xades-a.CertificateValues.bin)= fc7d08ddd1b8608a31b01fa7efc93cf384f3
13c3fa64160738ad88e57b2164fa
SHA256(data.xades-a.KeyInfo.bin)= 86cec5e8080b1c7846f40e13d9f6266f511da2ffad0613
3d3a25262c6ae03b3c
SHA256(data.xades-a.Reference-1.bin)= a34d23101ca59e04e9b84b2339ef91923c329947f9
7bec220c4d79d7e67b66fd
SHA256(data.xades-a.Reference-2.bin)= aa165ebea69b0d1b8bb4b56888f0d2b2bc8f1c0933
7f8105518172bef71b2c29
SHA256(data.xades-a.RevocationValues.bin)= 4708fc3405af5249ab7238a94e47e701357f5
eb53ffc0d4ed2f3890f60e5fe2e
SHA256(data.xades-a.SignatureTimeStamp.bin)= 3207e444d25ad1566d0bc49c0580849f04c
927758bab1824cad759aee7341da6
SHA256(data.xades-a.SignatureValue.bin)= 297fbd03f006ed8f7651834cdf5b64a28529ad7
2097ff38d3e11c628e092b7e5
SHA256(data.xades-a.SignedInfo.bin)= e1c0377e51d7e438f47bec23aad4e8427113cee0975
dc7292be99720cd2ca64e
SHA256(data.xades-a.TimeStampValidationData.bin)= 092a5627111abf37cad6680744ec6a
61a9d616fec0bf8cc35772c8731f6f199c</pre></div>

<p>Concaténer dans l'ordre les fichiers obtenus ci-dessus.</p>

<pre><strong>$ cat \
  data.xades-a.Reference-1.bin \
  data.xades-a.Reference-2.bin \
  data.xades-a.SignedInfo.bin \
  data.xades-a.SignatureValue.bin \
  data.xades-a.KeyInfo.bin \
  data.xades-a.SignatureTimeStamp.bin \
  data.xades-a.TimeStampValidationData.bin \
  data.xades-a.CertificateValues.bin \
  data.xades-a.RevocationValues.bin \
  > data.xades-a.ArchiveTimeStamp.data_to_hash</strong></pre>

<p>Le fichier <code>data.xades-a.ArchiveTimeStamp.data_to_hash</code> ainsi produit représente les données à horodater pour obtenir le jeton d'horodatage d'archivage.</p> 

<div class="note"><p>L'empreinte de ce fichier est la suivante :</p>
<pre><strong>$ openssl sha256 data.xades-a.ArchiveTimeStamp.data_to_hash</strong>
SHA256(data.xades-a.ArchiveTimeStamp.data_to_hash)= d0b28d8d2f6c68038b904f82720b
8db139a7ecdd319060e502447504e7512ac9</pre></div>

<p>Générer la requête d'horodatage associée à ce fichier.</p>

<pre><strong>$ openssl ts -query -data data.xades-a.ArchiveTimeStamp.data_to_hash \
  -sha256 -out ArchiveTimeStamp.tsq</strong></pre>

<p>Générer la réponse d'horodatage.</p>

<pre><strong>$ openssl ts -reply -config tsa-ts.cnf -section tsa \
  -queryfile ArchiveTimeStamp.tsq -inkey tsa-key.pem -signer tsa-crt.pem \
  -out ArchiveTimeStamp.tsr</strong></pre>
  
<p>Extraire le jeton d'horodatage de cette réponse.</p>

<pre><strong>$ openssl ts -reply -in ArchiveTimeStamp.tsr -token_out \
  -out ArchiveTimeStamp.tst</strong></pre>

<p>Coder le jeton en Base64.</p>

<pre><strong>$ openssl base64 -in ArchiveTimeStamp.tst</strong>
MIIC1AYJKoZIhvcNAQcCoIICxTCCAsECAQMxCzAJBgUrDgMCGgUAMIGOBgsqhkiG
9w0BCRABBKB/BH0wewIBAQYkKoZIhvcUAb5Ak3qC8U+DpxmD4GyBn36CuiCEgKIr
hZ3WYgEFMDEwDQYJYIZIAWUDBAIBBQAEINCyjY0vbGgDi5BPgnILjbE5p+zdMZBg
5QJEdQTnUSrJAgEEGA8yMDEyMDYyNDE0MTQ0MFoCCQCUr+EKI6ZSfjGCAhwwggIY
AgEBMGYwWTELMAkGA1UEBhMCRlIxFzAVBgNVBAoTDk1vbiBFbnRyZXByaXNlMRcw
FQYDVQQLEw4wMDAyIDEyMzQ1Njc4OTEYMBYGA1UECxMPT3BlblNTTCBSb290IENB
AgkA07lPBN3RoEAwCQYFKw4DAhoFAKCBjDAaBgkqhkiG9w0BCQMxDQYLKoZIhvcN
AQkQAQQwHAYJKoZIhvcNAQkFMQ8XDTEyMDYyNDE0MTQ0MFowIwYJKoZIhvcNAQkE
MRYEFM0ESu4Vi8DU46XrB799sbNVJcUcMCsGCyqGSIb3DQEJEAIMMRwwGjAYMBYE
FEMopucZySTSxBTCSucZUJOVYcUJMA0GCSqGSIb3DQEBAQUABIIBALbda1Pt/26K
RRkA1ZKzndxhjp3620N7NpSDpe9IEr6gdtiqLXhd5ktOjUKWSQnXdHaEsMaTOP08
OAc8X+YguiQSTqdkLnNLe1yKPf++zM140rvUKvM/nfCwSfk1vVk0C6h6h4JbYTka
8D/GIub3HopG/tWzCxe/UoTvcv2GhIUsHDw11gHlXYcCzIS8UILI3n89as3eWOd4
Q4PCUEKAl5RdSFoRXhP7DQ6B/cR/PjGnpqUy2BDjDqSOujj57ToAngMqmKMWV4pi
88zB56NGqvcPmKERgAIR1+iD+10vAOSJUfJl7lUMmlJMcwyNIYp78RaZx+hxC6+H
jLo+W++5i7g=</pre>

<p>Ajouter l'élément <code>xadesv141:ArchiveTimeStamp</code> suivant dans la signature en tant que propriété non signée, sous l'élément <code>xades:UnsignedProperties</code> dans le fichier <code>data.xades-a.xml</code>, en reprenant la valeur en Base64 obtenue ci-dessus.</p>

<pre><![CDATA[            <xadesv141:ArchiveTimeStamp Id="Id_ArchiveTimeStamp">
              <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
              <xades:EncapsulatedTimeStamp>
MIIC1AYJKoZIhvcNAQcCoIICxTCCAsECAQMxCzAJBgUrDgMCGgUAMIGOBgsqhkiG
…
jLo+W++5i7g=
              </xades:EncapsulatedTimeStamp>
            </xadesv141:ArchiveTimeStamp>]]></pre>

<p>Vérifier que la signature est toujours valide.</p>

<p>Afin de vérifier que l'élément <code>xades:QualifyingProperties</code> est conforme au schéma XML de la version 1.4.2 de XAdES, télécharger d'abord le fichier du schéma XML correspondant<span class="fn">http://uri.etsi.org/01903/v1.4.1/XAdESv141.xsd</span>, puis lancer la commande suivante.</p>

<pre><strong>$ xml sel -N ds=http://www.w3.org/2000/09/xmldsig# \
  -N xades=http://uri.etsi.org/01903/v1.3.2# -t \
  -c /root/ds:Signature/ds:Object/xades:QualifyingProperties data.xades-a.xml \
  | xmllint --schema XAdESv141.xsd --noout -</strong>
- validates</pre>

<h3 id="xades-a-lcr-jeton-horodatage">Ajout des données de révocation du jeton d'horodatage d'archivage</h3>

<p>Afin de permettre de vérifier que le certificat de l'unité d'horodatage est valide de manière autonome à partir de la signature, il est judicieux d'inclure la liste de certificats révoqués émise par son autorité de certification dans celle-ci.</p>

<p>Mettre à jour la liste de certificats révoqués.</p>

<pre><strong>$ openssl ca -gencrl -cert ca-crt.pem -keyfile ca-key.pem -crlhours 48 \
  -md sha256 -config ca-crl.cnf -name ca_crl -crlexts ca_crl_ext \
  -out ca-crl.pem</strong></pre>

<p>Ajouter le codage en Base64 de la liste de certificats révoqués dans une nouvelle propriété non signée <code>xadesv141:TimeStampValidationData</code>, après le jeton d'horodatage d'archivage, et référençant celui-ci à l'aide de l'attribut <code>URI</code> (dont la valeur reprend l'attribut <code>Id</code> de l'élément <code>xadesv141:ArchiveTimeStamp</code>), comme ci-dessous en gras :</p>

<pre><![CDATA[…
        <xades:UnsignedProperties>
          <xades:UnsignedSignatureProperties>
            <xades:SignatureTimeStamp>
              …
            </xades:SignatureTimeStamp>
            <xadesv141:TimeStampValidationData URI="#Id_SignatureTimeStamp">
              …
            </xadesv141:TimeStampValidationData>
            <xades:CertificateValues>
              …
            </xades:CertificateValues>
            <xades:RevocationValues>
              …
            </xades:RevocationValues>
            <xadesv141:ArchiveTimeStamp Id="Id_ArchiveTimeStamp">
              …
            </xadesv141:ArchiveTimeStamp>]]>
<strong><![CDATA[            <xadesv141:TimeStampValidationData URI="#Id_ArchiveTimeStamp">
              <xades:RevocationValues>
                <xades:CRLValues>
                  <xades:EncapsulatedCRLValue>
MIIB0zCBvAIBATANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJGUjEXMBUGA1UE
ChMOTW9uIEVudHJlcHJpc2UxFzAVBgNVBAsTDjAwMDIgMTIzNDU2Nzg5MRgwFgYD
VQQLEw9PcGVuU1NMIFJvb3QgQ0EXDTEyMDYyNDE0MzQxM1oXDTEyMDYyNjE0MzQx
M1qgLzAtMB8GA1UdIwQYMBaAFExth5OC9y0sByOiD+BxLRc/OfOPMAoGA1UdFAQD
AgEEMA0GCSqGSIb3DQEBCwUAA4IBAQCZCReBWo/EW9ItxK9A8gp4hj5YiVl1c0DI
WE8D5ubrPzUJufuSU9VgiiuLv0GWrq6SdPDJ9umq1SWjVhJ2HFKSokQJa2wHvyfC
xtqDWHoCBasbTbMmV0GB8w4dZWjlaHuBkeRJffU92Sb0K1e397cu5rH/EA9fcYfx
K1mivI3xCnO08fA8n49MfigG4dws+Nz4YveCw76AuI6CEwczQa5y6BJLBAFweul2
MpUlA75kEdqYHoJgW1KbVEjXFYVnTvH0UTPCXKIFf4e4MjyIrH2fzI9drZqZ9ypr
tdGvi51hMEnvFa0xb8yCfzdkFf6H7Sm9CtY3+Ag5cxs8mHnRfO9m
                  </xades:EncapsulatedCRLValue>
                </xades:CRLValues>
              </xades:RevocationValues>
            </xadesv141:TimeStampValidationData>]]></strong>
<![CDATA[          </xades:UnsignedSignatureProperties>
        </xades:UnsignedProperties>
…]]></pre>

<p>Sauvegarder le fichier <code>data.xades-a.xml</code>, ce qui achève la constitution de la signature électronique au format XAdES-A.</p>
</div>
<div class="appendices">

<h1 id="representation-codage-donnees">Représentation et codage des données</h1>
<h2 id="base64">Base64</h2>
<p>Un des codages fréquemment employé pour représenter des données
binaires, notamment dans le domaine de la confiance électronique, est Base64.
Le codage Base64 code des groupes de trois octets (soit 24 bits) sous la forme
de quatre caractères, chaque caractère pouvant prendre 64 valeurs (6 bits)
possibles (24 bits = 4 caractères × 6 bits). Ces caractères sont les
chiffres, les majuscules et minuscules ASCII, ainsi que les caractères
« <code>+</code> », « <code>/</code> » et (pour le <i>padding</i> dans
le cas où le dernier groupe d'octets à coder comporte moins de trois octets)
« <code>=</code> ». La commande <code>openssl base64</code> permet de coder
et (avec l'option <code>-d</code>) de décoder des données en Base64. Par
exemple, l'empreinte SHA-256 d'un fichier, codée en Base64, peut être obtenue
ainsi :</p>
<pre><strong>$ openssl sha256 -binary data.txt | openssl base64</strong>
ib2SKG1sgBTAYDCyX4tAzB1WVtSzt7SDGHT1DW9VV/M=</pre>
<p class="exercise"><strong>Exercice</strong> — Sachant qu'une empreinte SHA-256 a une taille
de 256 bits, quelle est la longueur des chaînes de caractères de ses
représentations hexadécimale et Base64 ?</p>
<h2 id="pem">PEM</h2>
<p>Le codage Base64, classiquement utilisé pour limiter les problèmes de
support des encodages lors du transport des données binaire, est parfois
complété par des balises PEM (<i>privacy enhanced mail</i>, du nom de la RFC
1421 qui les définit) : <code>-----BEGIN <i>type</i>-----</code> avant les
données et <code>-----END <i>type</i>-----</code> après, où
<code>
<i>type</i>
</code> désigne le type de données (ex. :
<code>CERTIFICATE</code>, <code>X509 CRL</code>), les noms des types étant
plutôt des conventions que des standard. Le nom de codage PEM est parfois
donné au codage Base64 (qu'il soit complété par les balises PEM, ou — par
abus de langage — non).</p>

<h2 id="dn"><i>Distinguished Name</i></h2>
<p>De manière simplifiée par rapport à la norme X.501 (mais réaliste), la
syntaxe ASN.1 d'un DN (<i>Distinguished Name</i>, ou nom distingué s'il faut
vraiment traduire ce terme, qui désigne simplement l'identifiant unique d'une
entrée d'annuaire) est la suivante (issue de la RFC 4514) :</p>
<pre>DistinguishedName ::= RDNSequence

RDNSequence ::= SEQUENCE OF RelativeDistinguishedName

RelativeDistinguishedName ::= SET SIZE (1..MAX) OF
    AttributeTypeAndValue

AttributeTypeAndValue ::= SEQUENCE {
    type  AttributeType,
    value AttributeValue }</pre>
<p>L'affichage de l'ordre des RDN (<i>Relative Distinguished Name</i> ou noms
distingués relatifs, les composants du DN) diffère selon l'outil utilisé.
Par défaut, OpenSSL affiche les RDN d'un DN dans l'ordre dans lequel ils
figurent dans la structure ASN.1, correspondant à la succession de nœuds
X.501 décrivant le nœud cible en partant du nœud racine (le séparateur
étant « <code>\</code>), soit encore une description partant du général
vers le particulier, où l'identité de l'entité est dans le dernier RDN
affiché. Ainsi, pour la CSR de l'autorité de certification, l'affichage par
défaut d'OpenSSL est :</p>
<pre><strong>$ openssl req -in ca-req.pem -noout -subject
subject=/C=FR/O=Mon Entreprise/OU=0002 123456789/OU=OpenSSL Root CA</strong></pre>
<p>Or l'affichage défini par, entre autres, les RFC 2253 puis 4514 sur la
représentation des DN de LDAP, prescrit de partir du dernier RDN et de
remonter vers le premier (avec le séparateur « <code>,</code> »), du
particulier vers le général, à l'image d'une adresse postale
« classique » (hors adresses postales est-asiatiques, s'entend). C'est
notamment l'affichage retenu par le magasin de certificats de Windows. OpenSSL
peut afficher les DN dans l'ordre prévu par les RFC en utilisant l'option
<code>-nameopt RFC2253</code> des commandes qui la supportent (<code>req</code>
et <code>x509</code>) :</p>
<pre><strong>$ openssl req -in ca-req.pem -noout -subject -nameopt RFC2253</strong>
subject=OU=OpenSSL Root CA,OU=0002 123456789,O=Mon Entreprise,C=FR</pre>

<h2 id="codage-caracteres">Codage des caractères</h2>
<p>Le problème de codage des caractères est théoriquement simple à résoudre (il « suffit » que tout le monde utilise, par exemple, le codage UTF-8 des caractères Unicode), mais est en pratique un nid de guêpes, compte tenu de la diversité des codages de caractères par défaut mis en œuvre dans les systèmes exploitation et applications. Pour faire simple, ASCII, la <i>lingua franca</i> originelle des normes de codage de caractères, supporte les minuscules et majuscules non accentuées, les chiffres et une trentaine de symboles courants, et a été étendue par des éditeurs de logiciels et autres organismes pour supporter des caractères supplémentaires. L'utilisateur francophone/francophile creusant la problématique du codage des caractères est rapidement confronté aux codages suivants :</p>
<ul>
<li>ISO-8859-1, ou Latin-1, ou encore <i>Western European</i> (européen occidental), qui supporte entre autres les caractères accentués français, et qui est particulièrement utilisé pour les pages web et systèmes d'exploitation (francophones ou non, d'ailleurs), ainsi que pour les fichiers .properties de Java.</li>
<li>ISO-8859-15, ou Latin-9, qui enrichit Latin-1 notamment du symbole « € », des ligatures « œ » et « Œ » et la lettre « Ÿ », pour une couverture exhaustive des caractères de la langue française. Il remplace progressivement ISO-8859-1 pour ceux qui ne migrent pas vers UTF-8, mais les soucis résiduels d'affichage des symboles « € » et des « œ » copiés/collés depuis les logiciels de bureautique dans certains formulaires web laissent penser que la transition est plus longue que prévu.</li>
<li>Windows-1252, ou CP1252 (parfois appelé ANSI par abus de langage), le codage par défaut en environnement Windows, qui est fonctionnellement équivalent à ISO-8859-15, mais techniquement incompatible (en particulier pour les caractères ajoutés dans ISO-8859-15).</li>
<li>OEM 850, ou <i>code page</i> 850 (page de code 850) ou encore MS-DOS Latin-1, codage par défaut sous DOS (dont l'invite de commandes Windows), qui est fonctionnellement équivalent à ISO-8859-1, mais techniquement incompatible, en particulier pour tous les caractères accentués français. </li>
<li>UTF-8, qui permet de coder, sur un (pour les caractères ASCII) ou plusieurs octets (pour tous les autres caractères), l'ensemble des caractères du jeu de caractères Unicode (plus d'un million de caractères). Malgré quelques inconvénients liés au codage des caractères non ASCII sur plusieurs octets, UTF-8 a pour vocation d'être la meilleure pratique pour le codage des caractères.</li>
</ul>
<p>Pour se faire une idée du type de problème lié au codage des caractères, sous Windows, essayer d'afficher dans une invite de commandes Windows un fichier texte français saisi dans le bloc-notes : les caractères accentués s'affichent incorrectement car leur codage est différent entre Windows-1252 (codage par défaut du bloc-notes) et OEM 850 (DOS). Une solution possible est de sauvegarder le fichier au format UTF-8, et de changer de page de code sous DOS : la page de code par défaut porte le numéro 850 (utiliser la commande <code>chcp</code> seule pour obtenir la page de code courante), et la page de code Microsoft correspondant à UTF-8 est 65001 (saisir <code>chcp 65001</code> pour passer à la page de code 65001).</p>
<p>Autre expérience sous Windows : par défaut l'accès distant (telnet ou SSH) à l'aide du client PuTTY prévoit que les données reçues sont codées en ISO-8859-1, d'où des comportements inhabituels à prévoir si l'environnement cible est en UTF-8 (utiliser la commande <code>locale</code> pour connaître le codage en cours) et s'il faut par exemple saisir le caractère « € ». L'option du PuTTY à régler dans ce cas est dans <code>Window &gt; Translation &gt; Received data assumed to be in which character set &gt; UTF-8</code>.</p>
<p>L'exigence initiale de la RFC 3280 de coder systématiquement les <code>DirectoryString</code> sous la forme d'<code>UTF8String</code> à partir de décembre 2003 a été assouplie dans la RFC 4630, qui – suite aux premières années de retour d'expérience – lève l'exigence et semble inciter à demi-mot, pour éviter les problèmes, à utiliser les <code>UTF8String</code> uniquement quand il n'est pas possible de faire autrement.</p>
<p>Malheureusement, il n'existe aucune solution miracle : sauf cas où le codage est imposé (et encore…), vérifier le codage mis en œuvre (que ce soit dans une invite de commande, un fichier texte, un formulaire web, etc.) avant d'utiliser un caractère non ASCII ne garantit pas qu'une transformation ultérieure ne corrompra pas le codage, et quand elles existent, les solutions pour y remédier sont spécifiques à chaque cas rencontré. À toutes fins utiles, pour des fichiers texte, il est recommandé de connaître l'outil iconv, qui permet de convertir du texte d'un codage à un autre. Cet outil est disponible pour les systèmes UNIX et GNU/Linux, et la version GNU d'iconv a été portée<span class="fn">http://gnuwin32.sourceforge.net/packages/libiconv.htm</span> sous Windows dans la suite GnuWin32 (elle se compile par ailleurs très facilement avec MinGW et MSYS<span class="fn">http://www.mingw.org/</span>).</p>

<h1 id="asn1">ASN.1</h1>
<h2 id="der"><i>Distinguished Encoding Rules</i></h2>
<p>DER (<i>Distinguished Encoding Rules</i>) désigne un ensemble de règles de
représentation binaire, qui est notamment utilisé pour coder la plupart des
structures de données binaires (par opposition à XML) dans le domaine de la
confiance électronique (ex. : certificats, listes de certificats révoqués,
les structures de données définies par les PKCS#). Le « schéma » (par
analogie à XML Schema dans le monde XML) de ces structures de données est
défini en ASN.1 (<i>Abstract Syntax Notation One</i>). La passion pour ASN.1
nourrit une une population à vrai dire plutôt confidentielle, y compris dans
le domaine de la confiance électronique où ASN.1 constitue pourtant un socle
technique fondamental aux côtés de XML. Le lecteur souhaitant aiguiser son
appétit pourra lire la section ci-après intitulée <code>MII…</code> avant
de se plonger dans les normes et les quelques ouvrages<span class="fn">http://www.oss.com/asn1/resources/books-whitepapers-pubs/asn1-books.html</span> sur le sujet.</p>

<h3 id="mii"><code>MII…</code></h3>
<p>Le lecteur attentif notera que le codage Base64 des petites
structures de données binaires élémentaires (ex. : certificats, listes de
certificats révoqués de test, signatures PKCS#7 détachées) commence quasi
systématiquement par les caractères <code>MII…</code>, c'est-à-dire les
valeurs décimales <code>12 08 08…</code> du tableau de correspondance
Base64, soit encore les valeurs binaires sur 6 bits <code>0b001100 0b001000
0b001000…</code>. Le décodage Base64 donne, en regroupant ces bits par
groupes de huit, <code>0b00110000 0b10000010 0b00…</code>, soit <code>0x30
0x82 <i>n</i>
</code> (où <code>
<i>n</i>
</code> est un nombre inférieur à
<code>0x40</code>). Dans le codage DER, ces octets représentent :</p>
<ul>
<li>Premier octet (<code>0x30</code>) : le type de données. Il s'agit d'une
    <code>SEQUENCE</code> ASN.1 (équivalent à une <code>sequence</code> de
    XML Schema).</li>
<li>Deuxième octet (<code>0x82</code>) : la longueur des données
    constituant le contenu de la structure (en général si elle est
    inférieure ou égale à 127 octets) ou la longueur de la longueur du
    contenu si elle est supérieure à 127 octets (bit de poids fort égal à 1
    et longueur de la longueur sur les 7 bits de poids faible). Ici, la
    longueur du contenu est supérieure à 127 octets (le bit de poids fort
    <code>0b1…</code>) et doit donc être représentée sur deux octets (les
    7 bits <code>0b0000010</code>).</li>
<li>Les deux octets suivants (<code>0b00… 0b…</code>) représentent la
    longueur du contenu, c'est-à-dire un nombre inférieur à
    <code>0x4000</code> (16 384 en décimal).</li>
</ul>
<p>En pratique, les petites structures élémentaires sont effectivement des
séquences de taille comprise entre 128 octets et 16 Ko, d'où le
<code>MII…</code> classique des fichiers PEM.</p>

<h2 id="unber2asnconf">Génération d'un fichier de configuration ASN.1 pour OpenSSL</h2>

<p>Il est envisageable d'automatiser la production des fichiers interprétables par la commande <code>openssl asn1parse -genconf</code> à partir d'un fichier DER, en utilisant un outil de décodage ASN.1 pour obtenir la structure des données puis en générant les sections de fichier attendues en parcourant cette structure.</p>
<p>Voici quelques pistes gratuites à envisager :</p>
<ul>
<li>le module Perl <code>Convert::ASN1</code><span class="fn">http://search.cpan.org/~gbarr/Convert-ASN1/</span>, dont le script d'exemple <code>x509decode</code> dans le paquetage source est un bon point de départ,</li>
<li>la bibliothèque Python pyasn1<span class="fn">http://pyasn1.sourceforge.net</span>, qui propose des modules prédéfinis<span class="fn">http://sourceforge.net/projects/pyasn1/files/pyasn1-modules/</span> pour les structures usuelles du domaine de la confiance numérique,</li>
<li>la bibliothèque C GNU libtasn1<span class="fn">http://www.gnu.org/software/libtasn1/</span>, utilisée notamment par GnuTLS<span class="fn">https://www.gnu.org/software/gnutls/</span>, l'implémentation GNU du protocole TLS,</li>
<li>le paquetage Java CODEC<span class="fn">http://codec.sourceforge.net/</span>, qui propose des paquetages correspondant aux structures définies par les normes PKCS et X.500,</li>
<li>la combinaison de asn1c<span class="fn">http://lionet.info/asn1c/blog/</span> pour convertir la structure DER en XER, et d'une transformation XSLT.</li>
<li>les versions Java et C# de la bibliothèque cryptographique BouncyCastle<span class="fn">http://www.bouncycastle.org</span> proposent des objets permettant de gérer des structures ASN.1.</li>
<li>les fonctions ASN.1 de la bibliothèque libcrypto d'OpenSSL.</li>
</ul>
<p>Les solutions permettant de compiler des modules ASN.1 sont susceptibles de produire les fichiers les plus lisibles, car elles peuvent faire correspondre une représentation DER à la structure ASN.1, et ainsi de générer des noms de sections représentatifs (tels que <code>[certificate]</code>). Malheureusement, les compilateurs ASN.1 implémentés par la plupart des outils sont imparfaits, et il faut donc adapter les modules normatifs pour qu'ils soient supportés par ces compilateurs, ce qui représente un travail fastidieux.</p>

<p>Une solution plus grossière mais plus rapide consiste à utiliser l'outil en ligne de commande <code>unber</code> d'asn1c (cf. annexe <a href="#asn1c" class="appendix_section"/>) pour produire une représentation XML générique de la structure, qui peut ensuite servir de point d'entrée pour obtenir un fichier de configuration ASN.1 (peu lisible mais utilisable).</p>

<p>Le résultat de la commande <code>unber</code> produit un fichier ressemblant à du XML à première vue, mais il présente trois caractéristiques qui l'empêchent d'être document XML valide, et qui imposent un nettoyage (l'outil <code>sed</code>) avant de pouvoir être interprété par les outils XML usuels :</p>

<ul>
<li>Les valeurs hexadécimales sont représentées par des suites d'entités XML (par exemple <code>&amp;#x02;</code> pour la valeur <code>0x02</code>). Or<span class="fn">http://www.w3.org/TR/2004/REC-xml-20040204/#NT-Char</span>, les caractères de contrôle ne sont pas autorisés dans un document XML. Il a donc été choisi d'échapper les valeurs hexadécimales des entités à l'aide du préfixe <code>\x</code> (par exemple, <code>&amp;#x02;</code> est remplacé par <code>\x02</code>), en utilisant l'expression régulière compatible <code>sed</code> suivante : <code><![CDATA[s/&#x\(..\);/\\x\1/g]]></code>… mais cette solution est incomplète, car dans le cas d'une chaîne mélangeant caractères ASCII et entités XML, le caractère <code>\</code> peut être ambigu. Il convient donc de précéder l'expression régulière précédente de l'expression régulière <code><![CDATA[s/\\/\\\\/g]]></code> pour échapper les caractères <code>\</code> et les remplacer par <code>\\</code>. Des <i>templates</i> dans le fichier XSLT gèrent les conversions inverses.</li>
<li>Certaines balises (celles « mises en forme » d'après la documentation) contiennent un attribut orphelin <code>F</code> sans valeur juste avant le caractère « <code>></code> » de fin de balise (par exemple : <code><![CDATA[<P O="10" T="[UNIVERSAL 2]" TL="2" V="1" A="INTEGER" F>2</P>]]></code>, ce qui enfreint<span class="fn">http://www.w3.org/TR/2004/REC-xml-20040204/#NT-Eq</span> les règles de la grammaire de XML. Cet attribut peut être supprimé par l'expression régulière <code><![CDATA[s/<\(.*\) F>/<\1>/g]]></code>. À noter que les quantificateurs de <code>sed</code> sont obligatoirement gourmands, mais cela ne pose pas de problème dans la présente situation car une ligne contient une seule balise, donc le <code>\(.*\)</code> ne risque pas d'englober plusieurs balises par mégarde.</li>
<li>Les balises fermantes incluent les mêmes attributs que les balises ouvrantes, ce qui est interdit dans un document XML<span class="fn">http://www.w3.org/TR/2004/REC-xml-20040204/#NT-ETag</span>. L'expression régulière <code><![CDATA[s/<\/\([^ ]\) .*>/<\/\1>/g]]></code> conserve uniquement le nom de la balise dans les balises fermantes.</li>
</ul>

<p>Créer le fichier <code>unberclean.sed</code> suivant, reprenant les expressions régulières ci-dessus :</p>

<pre><![CDATA[s/\\/\\\\/g
s/&#x\(..\);/\\x\1/g
s/<\(.*\) F>/<\1>/g
s/<\/\([^ ]\) .*>/<\/\1>/g]]></pre>

<p>Décoder le fichier d'entrée <code>ee-Certificate.der</code> généré en fin de section <a href="#finalisation-certificat" class="section"/> avec <code>unber</code> et nettoyer le résultat, à l'aide de la ligne de commande suivante :</p>

<pre><strong>$ unber ee-Certificate.der | sed -f unberclean.sed > ee-Certificate.xml</strong></pre>

<p>Créer le fichier XSLT <code>unber2asnconf.xslt</code> ci-après.</p>

<p class="note">Quelques commentaires ont été inclus pour expliquer les transformations effectuées.</p>

<pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="text" encoding="UTF-8" indent="no"/>

  <xsl:param name="prefix"/>

  <!-- Top-level template: creates the initial "asn1 = …" line, and
    then processes the C element if it exists -->
  <xsl:template match="/">
    <xsl:text>asn1 = </xsl:text>
    <xsl:apply-templates select="." mode="field_value"/>
    <xsl:text>&#x0a;</xsl:text>
    <xsl:if test="C">
        <xsl:text>&#x0a;</xsl:text>
        <xsl:apply-templates select="C" mode="section"/>
    </xsl:if>
  </xsl:template>

  <!-- 
    Templates for ASN.1 primitives
    ==============================
  -->
  
  <!-- Renders "field_name = field_value" from a P node. -->
  <xsl:template match="P">
    <xsl:apply-templates select="." mode="field_name"/>
    <xsl:text> = </xsl:text>
    <xsl:apply-templates select="." mode="field_value"/>
    <xsl:text>&#x0a;</xsl:text>
  </xsl:template>
  
  <!-- Generates a field name from a P node, using @T to determine
    the type of field and @O to give it a unique number.
    If the global $prefix parameter is defined, then it is prepended
    with an '_' to the field name. -->
  <xsl:template match="P" mode="field_name">
    <xsl:if test="$prefix">
      <xsl:value-of select="$prefix"/>
      <xsl:text>_</xsl:text>
    </xsl:if>
  
    <xsl:choose>
      <!-- INTEGER -->
      <xsl:when test="@T='[UNIVERSAL 2]'">
        <xsl:text>int</xsl:text>
      </xsl:when>

      <!-- ENUMERATED -->
      <xsl:when test="@T='[UNIVERSAL 10]'">
        <xsl:text>enum</xsl:text>
      </xsl:when>

      <!-- OBJECT IDENTIFIER -->
      <xsl:when test="@T='[UNIVERSAL 6]'">
        <xsl:text>oid</xsl:text>
      </xsl:when>

      <!-- NULL -->
      <xsl:when test="@T='[UNIVERSAL 5]'">
        <xsl:text>null</xsl:text>
      </xsl:when>

      <!-- BIT STRING -->
      <xsl:when test="@T='[UNIVERSAL 3]'">
        <xsl:text>bitstring</xsl:text>
      </xsl:when>
      
      <!-- OCTET STRING -->
      <xsl:when test="@T='[UNIVERSAL 4]'">
        <xsl:text>octstring</xsl:text>
      </xsl:when>
      
      <!-- PRINTABLE STRING -->
      <xsl:when test="@T='[UNIVERSAL 19]'">
        <xsl:text>printablestring</xsl:text>
      </xsl:when>
      
      <!-- UTF8 STRING -->
      <xsl:when test="@T='[UNIVERSAL 12]'">
        <xsl:text>utf8string</xsl:text>
      </xsl:when>

      <!-- UTCTIME -->
      <xsl:when test="@T='[UNIVERSAL 23]'">
        <xsl:text>utctime</xsl:text>
      </xsl:when>

      <!-- GENERALIZEDTIME -->
      <xsl:when test="@T='[UNIVERSAL 24]'">
        <xsl:text>gentime</xsl:text>
      </xsl:when>

      <!-- BOOLEAN -->
      <xsl:when test="@T='[UNIVERSAL 1]'">
        <xsl:text>bool</xsl:text>
      </xsl:when>

      <!-- IMPLICIT -->
      <xsl:when test
        ="string(number(substring-before(substring-after(@T, '['),']'))) != 'NaN'">
        <xsl:text>implicit</xsl:text>
      </xsl:when>
    
      <xsl:otherwise>
        <xsl:text>unknown</xsl:text>
      </xsl:otherwise>

    </xsl:choose>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="@O"/>
  </xsl:template>

  <!-- Generates a field value from a P node, using @T to determine
    the type of field. -->
  <xsl:template match="P" mode="field_value">
    <xsl:choose>
      <!-- INTEGER and ENUMERATED-->
      <xsl:when test="@T='[UNIVERSAL 2]' or @T='[UNIVERSAL 10]'">
        <xsl:choose>
          <xsl:when test="@T='[UNIVERSAL 2]'">
            <xsl:text>INTEGER:</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>ENUMERATED:</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
          <xsl:when test="starts-with(., '\x')">
            <!-- if the string begins with "\x" then it is a
              hexstring and needs to be unescaped and prefixed -->
              <xsl:text>0x</xsl:text>
              <xsl:call-template name="xstring_to_hexstring">
                <xsl:with-param name="string" select="."/>
              </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="."/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>

      <!-- OBJECT IDENTIFIER -->
      <xsl:when test="@T='[UNIVERSAL 6]'">
        <xsl:text>OID:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>

      <!-- NULL -->
      <xsl:when test="@T='[UNIVERSAL 5]'">
        <xsl:text>NULL</xsl:text>
      </xsl:when>

      <!-- BIT STRING -->
      <xsl:when test="@T='[UNIVERSAL 3]'">
        <!-- Two cases are considered depending on the first byte (unused
          bits) -->
        <xsl:choose>
          <xsl:when test="starts-with(.,'\x00')">
            <!-- 1) the number of unused bits is 0: discard first byte
              and render as hex-string -->
            <xsl:text>FORMAT:HEX,BITSTRING:</xsl:text>
            <xsl:call-template name="fold_long_line">
              <xsl:with-param name="line">
                <xsl:call-template name="xstring_to_hexstring">
                  <xsl:with-param name="string" select="substring-after(.,'\x00')"/>
                </xsl:call-template>
              </xsl:with-param>
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <!-- 2) the number of unused bits is not zero: render as
              bitlist -->
            <xsl:text>FORMAT:BITLIST,BITSTRING:</xsl:text>
            <xsl:call-template name="bitstring_to_bitlist">
              <!-- the number of unused bits is in the range 1-7
                (i.e. \x01-\x04), so extract fourth character for
                unused_bits parameter -->
              <xsl:with-param name="unused_bits" select="substring(.,4,1)"/>
              <xsl:with-param name="bits">
                <xsl:call-template name="xstring_to_binary">
                  <!-- convert all but first byte to binary -->
                  <xsl:with-param name="string" select="substring(.,5)"/>
                </xsl:call-template>
              </xsl:with-param>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      
      <!-- OCTET STRING -->
      <xsl:when test="@T='[UNIVERSAL 4]'">
        <xsl:text>FORMAT:HEX,OCTETSTRING:</xsl:text>
        <xsl:call-template name="fold_long_line">
          <xsl:with-param name="line">
            <xsl:call-template name="xstring_to_hexstring">
              <xsl:with-param name="string" select="."/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:when>
      
      <!-- PRINTABLE STRING -->
      <xsl:when test="@T='[UNIVERSAL 19]'">
        <xsl:text>PRINTABLESTRING:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>
      
      <!-- UTF8 STRING -->
      <xsl:when test="@T='[UNIVERSAL 12]'">
        <xsl:text>FORMAT:UTF8,UTF8String:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>

      <!-- IA5STRING -->
      <xsl:when test="@T='[UNIVERSAL 19]'">
        <xsl:text>IA5STRING:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>
      
      <!-- UTCTIME -->
      <xsl:when test="@T='[UNIVERSAL 23]'">
        <xsl:text>UTCTIME:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>

      <!-- GENERALIZEDTIME -->
      <xsl:when test="@T='[UNIVERSAL 24]'">
        <xsl:text>GENERALIZEDTIME:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:when>

      <!-- BOOLEAN -->
      <xsl:when test="@T='[UNIVERSAL 1]'">
        <xsl:text>BOOLEAN:</xsl:text>
        <xsl:choose>
          <xsl:when test=". = true">
            <xsl:text>true</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>false</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      
      <!-- IMPLICIT -->
      <!-- The test below checks whether the string between the
        brackets — which defines the tag type — is a number, by
        checking that it is not NaN (NaN: not a number) -->
      <xsl:when test="string(number(substring-before(substring-after(@T, '['),']'))) != 'NaN'">
        <xsl:text>IMPLICIT:</xsl:text>
        <xsl:value-of select="substring-before(substring-after(@T, '['),']')"/>
        <!-- IMPLICT-ly tagged types may be rendered by unber as
          entities only or as a hybrid (ASCII+entities) string -->
          
        <!-- get number of \x-prefixed hex values -->
        <xsl:variable name="number_of_hexvalues">
          <xsl:call-template name="count_hexvalues">
            <xsl:with-param name="string" select="."/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
          <!-- if the string only contains hexvalues then render it
            as an OCTET STRING -->
          <xsl:when test="$number_of_hexvalues * 4 = string-length(.)">
            <xsl:text>,FORMAT:HEX,OCTETSTRING:</xsl:text>
            <xsl:call-template name="fold_long_line">
              <xsl:with-param name="line">
                <xsl:call-template name="xstring_to_hexstring">
                  <xsl:with-param name="string" select="."/>
                </xsl:call-template>
              </xsl:with-param>
            </xsl:call-template>            
          </xsl:when>
          
          <xsl:otherwise>
            <!-- otherwise render it as a UTF8STRING, leaving the
              hex values escaped -->
            <xsl:text>,FORMAT:UTF8,UTF8String:</xsl:text>
            <xsl:value-of select="."/>
          </xsl:otherwise>
        </xsl:choose>
        <!-- unber always renders IMPLICIT-ly tagged primitive types as
          hexadecimal strings, so an OCTET STRING type is used -->
      </xsl:when>

      <!-- Fallback: if this happens then this XSLT document needs to
        be extended to cover the unexpected case -->
      <xsl:otherwise>
        <xsl:value-of select="@T"/>
        <xsl:text>:</xsl:text>
        <xsl:value-of select="."/>
      </xsl:otherwise>

    </xsl:choose>
  </xsl:template>  
  
  <!-- 
    Templates for ASN.1 constructed types
    =====================================
  -->
  
  <!-- Generates a section, corresponding to e.g. a SEQUENCE or a
    SET -->
  <xsl:template match="C" mode="section">
    <!-- section name -->
    <xsl:text>[</xsl:text>
    <xsl:apply-templates select="." mode="field_name"/>
    <xsl:text>]</xsl:text>
    <xsl:text>&#x0a;</xsl:text>
    
    <!-- section contents -->
    <xsl:apply-templates select="C|P"/>
    <xsl:text>&#x0a;</xsl:text>
    
    <!-- recurse to create the sections required by the fields in
      the current section -->
    <xsl:for-each select="C">
      <xsl:apply-templates select="." mode="section"/>
    </xsl:for-each>
  </xsl:template>
  
  <!-- Renders "field_name = field_value" from a C node. -->
  <xsl:template match="C">
    <xsl:apply-templates select="." mode="field_name"/>
    <xsl:text> = </xsl:text>
    <xsl:apply-templates select="." mode="field_value"/>
    <xsl:text>&#x0a;</xsl:text>
  </xsl:template>
  
    <!-- Generates a field value from a C node, using @T to determine
    the type of field. -->
  <xsl:template match="C" mode="field_value">
    <xsl:choose>
      <!-- SEQUENCE -->
      <xsl:when test="@T='[UNIVERSAL 16]'">
        <xsl:text>SEQUENCE:</xsl:text>
        <xsl:apply-templates select="." mode="field_name"/>
      </xsl:when>

      <!-- SET -->
      <xsl:when test="@T='[UNIVERSAL 17]'">
        <xsl:text>SET:</xsl:text>
        <xsl:apply-templates select="." mode="field_name"/>
      </xsl:when>
      
      <!-- [CONTEXT n] EXPLICIT/IMPLICIT -->
      <!-- The test below checks whether the string between the
        brackets — which defines the tag type — is a number, by
        checking that it is not NaN (NaN: not a number) -->
      <xsl:when 
         test="not (number(substring-before(substring-after(@T, '['),']')) = NaN)">
        
        <!-- Explicitly and implicitly tagged types are both decoded
          as [n] by unber.
          Noting that [n] IMPLICIT SEQUENCE … is equivalent (after 
          encoding) to [n] EXPLICIT …, choosing either representation
          is a matter of convenience.
          Two cases are handled here:
          1) There is only one node under the current node: in that
             case, the [n] EXPLICIT … syntax is assumed. -->
        <xsl:choose>
          <xsl:when test="count(C|P) = 1">
            <xsl:text>EXPLICIT:</xsl:text>
            <xsl:value-of select="substring-after(substring-before(@T,']'),'[')"/>
            <xsl:text>,</xsl:text>
            <xsl:apply-templates select="C|P" mode="field_value"/>
          </xsl:when>
        
        <!--
          2) There are several nodes under the current node: in that
             case, the [n] IMPLICIT SEQUENCE … syntax is used. -->
          <xsl:otherwise>
            <xsl:text>IMPLICIT:</xsl:text>
            <xsl:value-of select="substring-after(substring-before(@T,']'),'[')"/>
            <xsl:text>,SEQUENCE:</xsl:text>
            <xsl:apply-templates select="." mode="field_name"/>          
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>

      <!-- Fallback: if this happens then this XSLT document needs to
        be extended to cover the unexpected case -->
      <xsl:otherwise>
        <xsl:value-of select="@T"/>
        <xsl:text>:</xsl:text>
        <xsl:apply-templates select="." mode="field_name"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
    <!-- Generates a field name from a C node, using @T to determine
    the type of field and @O to give it a unique number.
    If the global $prefix parameter is defined, then it is prepended
    with an '_' to the field name. -->
  <xsl:template match="C" mode="field_name">
    <xsl:if test="$prefix">
      <xsl:value-of select="$prefix"/>
      <xsl:text>_</xsl:text>
    </xsl:if>

    <xsl:choose>
      <!-- SEQUENCE -->
      <xsl:when test="@T='[UNIVERSAL 16]'">
        <xsl:text>seq_</xsl:text>
      </xsl:when>

      <!-- SET -->
      <xsl:when test="@T='[UNIVERSAL 17]'">
        <xsl:text>set_</xsl:text>
      </xsl:when>

      <!-- [CONTEXT n] EXPLICIT/IMPLICIT -->
      <xsl:otherwise>
        <xsl:text>context_</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    
    <xsl:value-of select="@O"/>
  </xsl:template>

  <!-- 
    Auxiliary templates
    ===================
  -->
    
  <!-- folds a long line (in parameter $line) into '\'-appended 
    64-character lines -->
  <xsl:template name="fold_long_line">
    <xsl:param name="line"/>
    <xsl:text>\&#x0a;</xsl:text>
    <xsl:choose>
      <xsl:when test="string-length($line) &lt; 65">
        <xsl:value-of select="$line"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="substring($line, 1, 64)"/>
        <xsl:call-template name="fold_long_line">
          <xsl:with-param name="line" select="substring($line, 65)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- removes the '\x' from a string (in parameter $string) -->
  <xsl:template name="xstring_to_hexstring">
    <xsl:param name="string"/>
    <xsl:call-template name="search_and_replace">
        <xsl:with-param name="replace" select="'\x'"/>
        <xsl:with-param name="in" select="$string"/>
        <xsl:with-param name="with"/>
    </xsl:call-template>
  </xsl:template>

  <!-- converts a bitstring, specified by a number of unused bits
    (in $unused_bits) and the string itself ($bits) to a BITLIST
    e.g. $unused_bits=6, $bits=11000000 => 0,1 -->
  <xsl:template name="bitstring_to_bitlist">
    <xsl:param name="unused_bits"/>
    <xsl:param name="bits"/>
    <xsl:call-template name="indices_of_set_bits_in_bitstring">
      <xsl:with-param name="offset" select="0"/>
      <xsl:with-param name="string" 
          select="substring($bits,1,string-length($bits)-$unused_bits)"/>
    </xsl:call-template>
  </xsl:template>
  
  <!-- returns the comma-separated indices of set bits (i.e. 1's) in
    a bitstring in parameter $string, adding offset $offset
    (e.g.: 1010 would return 0,2 if $offset == 0 and 1,3 if
    $offset == 1)-->
  <xsl:template name="indices_of_set_bits_in_bitstring">
    <xsl:param name="offset"/>
    <xsl:param name="string"/>
    <xsl:if test="contains($string, '1')">
      <xsl:variable name="set_bit_position" 
          select="string-length(substring-before($string, '1')) + $offset"/>
      <xsl:variable name="bitstring_after_set_bit" 
          select="substring-after($string, '1')"/>
      <xsl:value-of select="$set_bit_position"/>
      <xsl:if test="contains($bitstring_after_set_bit, '1')">
        <xsl:text>,</xsl:text>
        <xsl:call-template name="indices_of_set_bits_in_bitstring">
          <xsl:with-param name="offset" select="$set_bit_position + 1"/>
          <xsl:with-param name="string" select="$bitstring_after_set_bit"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:if>
  </xsl:template>

  <!-- converts a \x-prefixed string (in parameter $string) to a binary
    string -->
  <xsl:template name="xstring_to_binary">
    <xsl:param name="string"/>
    <xsl:call-template name="hexstring_to_binary">
      <xsl:with-param name="string">
        <xsl:call-template name="xstring_to_hexstring">
          <xsl:with-param name="string" select="$string"/>
        </xsl:call-template>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>
  
  <!-- converts a hexstring (in parameter $string) to a binary string -->
  <xsl:template name="hexstring_to_binary">
    <xsl:param name="string"/>
    <xsl:if test="string-length($string) != 0">
      <xsl:call-template name="hexdigit_to_binary">
        <xsl:with-param name="digit" select="substring($string,1,1)"/>
      </xsl:call-template>
      <xsl:call-template name="hexstring_to_binary">
        <xsl:with-param name="string" select="substring($string,2)"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>  
  
  <!-- converts a hexadecimal digit ([0-9a-f]) in parameter $digit
    to its binary representation -->
  <xsl:template name="hexdigit_to_binary">
    <xsl:param name="digit"/>
    <xsl:choose>
      <xsl:when test="$digit = '0'">0000</xsl:when>
      <xsl:when test="$digit = '1'">0001</xsl:when>
      <xsl:when test="$digit = '2'">0010</xsl:when>
      <xsl:when test="$digit = '3'">0011</xsl:when>
      <xsl:when test="$digit = '4'">0100</xsl:when>
      <xsl:when test="$digit = '5'">0101</xsl:when>
      <xsl:when test="$digit = '6'">0110</xsl:when>
      <xsl:when test="$digit = '7'">0111</xsl:when>
      <xsl:when test="$digit = '8'">1000</xsl:when>
      <xsl:when test="$digit = '9'">1001</xsl:when>
      <xsl:when test="$digit = 'a' or $digit = 'A'">1010</xsl:when>
      <xsl:when test="$digit = 'b' or $digit = 'B'">1011</xsl:when>
      <xsl:when test="$digit = 'c' or $digit = 'C'">1100</xsl:when>
      <xsl:when test="$digit = 'd' or $digit = 'D'">1101</xsl:when>
      <xsl:when test="$digit = 'e' or $digit = 'E'">1110</xsl:when>
      <xsl:when test="$digit = 'f' or $digit = 'F'">1111</xsl:when>
    </xsl:choose>
  </xsl:template>

  <!-- global search and replace function, which replaces the content
    of $replace in $in with $with -->
  <xsl:template name="search_and_replace">
    <xsl:param name="replace"/>
    <xsl:param name="in"/>
    <xsl:param name="with"/>

    <xsl:choose>
      <xsl:when test="contains($in, $replace)">
        <xsl:value-of select="substring-before($in, $replace)"/>
        <xsl:value-of select="$with"/>
        <xsl:call-template name="search_and_replace">
          <xsl:with-param name="replace" select="$replace" />
          <xsl:with-param name="in" select="substring-after($in, $replace)"/>
          <xsl:with-param name="with" select="$with" />
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$in"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <!-- count number of \x's in a string ($string), thus counting
    hexvalues -->
  <xsl:template name="count_hexvalues">
    <xsl:param name="string"/>
    <xsl:choose>
      <xsl:when test="contains($string, '\x')">
        <xsl:variable name="count_hexvalues_after_prefix">
          <xsl:call-template name="count_hexvalues">
            <xsl:with-param name="string" 
                select="substring-after($string, '\x')"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="1+$count_hexvalues_after_prefix"/>
      </xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>]]></pre>

<p>Ce fichier comporte des limitations connues, évoquées ci-dessous.</p>
<p>Tout d'abord, la syntaxe ASN.1 n'a pas été reprise intégralement, en particulier : seules les chaînes de caractères de type <code>PrintableString</code> et <code>UTF8String</code> sont gérées, tous les types universels n'ont pas été traités (par exemple le type <code>REAL</code>, qui n'est pas utilisé dans les structures usuelles de la confiance électronique), et les types <code>PRIVATE</code> et <code>APPLICATION</code> ne sont pas pris en compte.</p>
<p class="note">Tous ces éléments peuvent être ajoutés si nécessaire en ajoutant de nouveaux cas (<code><![CDATA[<xsl:when test="…">…</xsl:when>]]></code>) dans les <i>templates</i> <code><![CDATA[<xsl:template match="P" mode="field_name">]]></code> et <code><![CDATA[<xsl:template match="P" mode="field_value">]]></code>.</p>
<p>Ensuite, dans le cas où un type <code>IMPLICIT</code> primitif contient des caractères ASCII et des caractères non ASCII, ces derniers sont représentés sous la forme <code>\x<em>hh</em></code>, où <code><em>hh</em></code> est le codage hexadécimal de l'octet considéré.</p>
<div class="note">
<p>Pour illustrer cette limitation, créer par exemple le fichier <code>accents.asn.cnf</code>suivant (à enregistrer avec le codage UTF-8 sans BOM) :</p>
<pre>asn1 = IMPLICIT:0,FORMAT:UTF8,UTF8String:voici quelques caractères accentués</pre>
<p>Générer le codage DER puis le décoder à l'aide de <code>sed</code> et du fichier XSLT :</p>
<pre><strong>$ openssl asn1parse -genconf accents.cnf -out accents.der</strong>
    0:d=0  hl=2 l=  37 prim: cont [ 0 ]

<strong>$ unber accents.der | sed -f unberclean.sed | xsltproc unber2asnconf.xslt -</strong>
asn1 = IMPLICIT:0,FORMAT:UTF8,UTF8String:\
voici quelques caract\xc3\xa8res accentu\xc3\xa9s</pre>
</div>
<p>Les codes <code>\x<em>hh</em></code> peuvent être décodés en « filtrant » le résultat de la transformation XSLT dans la commande Perl suivante (remplacer les apostrophes par des guillemets sous Windows) :</p>
<pre><strong>… | perl -pe 's/\\x(.{2})/chr(hex($1))/eg'</strong></pre>
<div class="note"><p>Pour éviter de retenir cette expression régulière, créer le fichier <code>unescape_hex.pl</code> contenant la ligne suivante :</p>
<pre>s/\\x(.{2})/chr(hex($1))/eg</pre>
<p>et utiliser la syntaxe suivante à la place de celle proposée ci-dessus :</p>
<pre><strong>… | perl -p unescape_hex.pl</strong></pre>
<p>Par exemple (avec une console shell en UTF-8) :</p>
<pre><strong>$ unber accents.der | sed -f unberclean.sed | xsltproc unber2asnconf.xslt - \
  | perl -p unescape_hex.pl</strong>
asn1 = IMPLICIT:0,FORMAT:UTF8,UTF8String:voici quelques caractères accentués</pre>
</div>
<p>Enfin, le cas des types <code>IMPLICIT</code> et <code>EXPLICIT</code> pouvant donner lieu à des décodages ambigus en l'absence d'un fichier de définition, des arbitrages (décrits dans les commentaires) ont été faits pour déterminer si une balise <code>IMPLICIT SEQUENCE</code> ou <code>EXPLICIT</code> doit être utilisée. La représentation DER est identique, mais la syntaxe obtenue pourra différer par rapport à la syntaxe originelle.</p>
<div class="note">
<p>Pour illustrer les différences possibles, soit le fichier d'origine suivant, nommé <code>taggedtypes.asn.cnf</code> :</p>
<pre>asn1 = SEQUENCE:taggedtypes_seq

[taggedtypes_seq]
expl_integer     = EXPLICIT:0,INTEGER:0
expl_seq_1_item  = EXPLICIT:0,SEQUENCE:expl_seq_1_item
expl_seq_n_items = EXPLICIT:0,SEQUENCE:expl_seq_n_items
impl_integer     = IMPLICIT:0,INTEGER:4
impl_seq_1_item  = IMPLICIT:0,SEQUENCE:impl_seq_1_item
impl_seq_n_items = IMPLICIT:0,SEQUENCE:impl_seq_n_items

[expl_seq_1_item]
a = INTEGER:1

[expl_seq_n_items]
a = INTEGER:2
b = INTEGER:3

[impl_seq_1_item]
a = INTEGER:5

[impl_seq_n_items]
a = INTEGER:6
b = INTEGER:7</pre>
<p>Le codage DER obtenu à partir de ce fichier est le suivant :</p>
<pre><strong>$ openssl asn1parse -genconf taggedtypes.asn.cnf -i -out taggedtypes.der</strong>
    0:d=0  hl=2 l=  38 cons: SEQUENCE
    2:d=1  hl=2 l=   3 cons:  cont [ 0 ]
    4:d=2  hl=2 l=   1 prim:   INTEGER           :00
    7:d=1  hl=2 l=   5 cons:  cont [ 0 ]
    9:d=2  hl=2 l=   3 cons:   SEQUENCE
   11:d=3  hl=2 l=   1 prim:    INTEGER           :01
   14:d=1  hl=2 l=   8 cons:  cont [ 0 ]
   16:d=2  hl=2 l=   6 cons:   SEQUENCE
   18:d=3  hl=2 l=   1 prim:    INTEGER           :02
   21:d=3  hl=2 l=   1 prim:    INTEGER           :03
   24:d=1  hl=2 l=   1 prim:  cont [ 0 ]
   27:d=1  hl=2 l=   3 cons:  cont [ 0 ]
   29:d=2  hl=2 l=   1 prim:   INTEGER           :05
   32:d=1  hl=2 l=   6 cons:  cont [ 0 ]
   34:d=2  hl=2 l=   1 prim:   INTEGER           :06
   37:d=2  hl=2 l=   1 prim:   INTEGER           :07</pre>

<p>Le décodage par <code>unber</code> suivi de l'application de la transformation XSLT précédente produit le résultat suivant :</p>
<pre><strong>$ unber taggedtypes.der |sed -f unberclean.sed | xsltproc unber2asnconf.xslt -</strong>
asn1 = SEQUENCE:seq_0

[seq_0]
context_2 = EXPLICIT:0,INTEGER:0
context_7 = EXPLICIT:0,SEQUENCE:seq_9
context_14 = EXPLICIT:0,SEQUENCE:seq_16
implicit_24 = IMPLICIT:0,FORMAT:HEX,OCTETSTRING:\
04
context_27 = EXPLICIT:0,INTEGER:5
context_32 = IMPLICIT:0,SEQUENCE:context_32

[context_2]
int_4 = INTEGER:0

[context_7]
seq_9 = SEQUENCE:seq_9

[seq_9]
int_11 = INTEGER:1

[context_14]
seq_16 = SEQUENCE:seq_16

[seq_16]
int_18 = INTEGER:2
int_21 = INTEGER:3

[context_27]
int_29 = INTEGER:5

[context_32]
int_34 = INTEGER:6
int_37 = INTEGER:7</pre>

<p>Noter que l'élément initialement nommé <code>impl_seq_1_item</code> admet une syntaxe finale différente, même si la représentation DER est identique. Noter également que les types <code>EXPLICIT</code> portant sur une structure à un seul élément donnent lieu à la création d'une section <code>[context_…]</code> inutilisée (<code>context_2</code>, <code>context_7</code> et <code>context_27</code> dans le résultat obtenu ci-avant) : cet artéfact sans importance évite des tests et récursions complémentaires qui auraient alourdi le code XSLT.</p>
</div>

<p>Générer le fichier de configuration ASN.1 en appliquant cette transformation XSLT au fichier XML généré précédemment :</p>

<pre><strong>$ xsltproc unber2asnconf.xslt ee-Certificate.xml \
  > ee-Certificate.asn-autogen.cnf</strong></pre>

<div class="note">
<p>Dans le fichier généré, les noms des champs ont la forme <code><em>type</em>_<em>position</em></code> (par exemple <code>int_13 = INTEGER:0x00dcd21ee5a2b7dfc7</code>), où <code><em>type</em></code> est le type ASN.1 d'origine, et <code><em>position</em></code> est la position (en octets) de la structure dans le fichier DER initial. Pour rendre les champs uniques et ainsi permettre leur coexistence dans un même fichier de configuration, le fichier XSLT admet un paramètre optionnel, <code>prefix</code>, qui sera utilisé (avec le caractère « <code>_</code> ») pour préfixer les noms des champs. Par exemple :</p>

<pre><strong>$ xsltproc --stringparam prefix crt unber2asnconf.xslt ee-crt.xml</strong>
asn1 = SEQUENCE:crt_seq_0

[crt_seq_0]
crt_seq_4 = SEQUENCE:crt_seq_4
crt_seq_734 = SEQUENCE:crt_seq_734
…</pre>
</div>

<p>Vérifier que le fichier de configuration ainsi généré produit, après injection dans la commande <code>openssl asn1parse -genconf …</code>, un fichier identique au fichier <code>ee-Certificate.der</code> d'origine, par exemple en vérifiant que leurs empreintes sont égales.</p>

<h2 id="dumpasn1">dumpasn1</h2>
<p>L'outil dumpasn1<span class="fn">http://www.cs.auckland.ac.nz/~pgut001/</span> de Peter Gutmann propose un affichage agréable et détaillé d'une structure ASN.1 codée en DER.</p>

<p class="note">Cet outil a notamment été utilisé pour représenter le contenu des certifcats et de la liste de certificats révoqués dans l'annexe C de la RFC 5280.</p>

<p>L'outil dumpasn1 n'étant pas livré sous forme d'exécutable, il doit être compilé. Télécharger le fichier source <code>dumpasn1.c</code> et le fichier de configuration <code>dumpasn1.cfg</code>. Compiler le code source avec le compilateur <code>gcc</code> en utilisant la commande <code>gcc -o dumpasn1 dumpasn1.c</code>, ou avec le compilateur <code>cl</code> de Visual C++ avec la commande <code>cl /MD dumpasn1.c</code>.</p>

<p class="note">Pour éviter de compiler dumpasn1 sous Windows, il est possible d'utiliser l'outil GUIDumpASN référencé sur la page de dumpasn1, qui propose une interface graphique à l'outil dumpasn1 et à ses options en ligne de commande.</p>

<p>L'outil d'analyse ASN.1 en ligne<span class="fn">http://lapo.it/asn1js/</span> référencé sur la page de dumpasn1 présente l'intérêt de mettre en évidence par un code couleur les composants du codage DER des éléments ASN.1 (libellé, longueur, valeur), et d'afficher la correspondance entre structure et valeur d'un élément un survolant celui-ci avec le curseur de la souris.</p>

<h2 id="asn1c">Initiation au compilateur asn1c</h2>
<p>À partir d'un module ASN.1, le compilateur ASN.1 asn1c<span class="fn">http://lionet.info/asn1c/</span> génère des structures C correspondant aux structures ASN.1, et les fonctions permettant de coder et de décoder les structures C vers ou à partir d'une représentation binaire (BER/DER) et XML (XER ou <i>XML Encoding Rules</i>). Il est ainsi possible de décrire un objet ASN.1 en XML et de le convertir en binaire, ce qui fait l'objet de cette section, qui construit la représentation BER d'une clé publique RSA à partir de sa description XML. Le compilateur C gcc est utilisé ci-après.</p>

<p>Télécharger et installer asn1c : la compilation en environnement UNIX/Linux s'effectue sans difficulté en suivant les instructions fournies dans le fichier <code>INSTALL</code> du paquetage source, et pour Windows il est fortement recommandé d'installer la version pré-compilée proposée sur le site web.</p>

<p>Créer le fichier <code>RSAPublicKey.asn1</code> suivant :</p>
<pre>RSAPublicKey DEFINITIONS ::=
BEGIN

-- From RFC2313/PKCS#1v1.5
RSAPublicKey ::= SEQUENCE {
   modulus INTEGER,
   publicExponent INTEGER
}

END</pre>
<p>Compiler le module, avec les options <code>-S</code> et <code>-fskeletons-copy</code> ci-dessous sous Windows (non nécessaires pour les environnements Linux/UNIX) :</p>
<pre>> <i>&lt;chemin_vers&gt;</i>asn1c -S<i>&lt;chemin_vers&gt;</i>skeletons \
  -fskeletons-copy RSAPublicKey.asn1</pre>

<p>La compilation du module inclut un outil nommé <code>converter-sample</code> qui permet d'effectuer des conversions de format en ligne de commande.</p>

<div class="longnote">
<div class="notetitle">Compilation sous Windows des fichiers générés par asn1c</div>
<p>Le résultat d'une compilation d'asn1c sous Windows nécessite quelques modifications pour pouvoir fonctionner, comme décrit ci-après.</p>

<p>Obtenir un fichier <code>sysexits.h</code> (provenant d'un système UNIX/Linux par exemple, ou du code source de la GNU C Library [http://sourceware.org/git/?p=glibc.git] dans le répertoire <code>include</code>) et le placer dans le répertoire de compilation du module ASN.1.</p>
<p>Le code source <code>converter-sample.c</code> doit être légèrement modifié pour éviter d'interpréter la valeur <code>0x0a</code> comme étant un retour chariot Windows/DOS à convertir en <code>0x0d 0x0a</code> : les fichiers lus et l'entrée et la sortie standard doivent être déclarés comme étant en mode binaire.</p>
<p>Changer le mode de lecture sur <code>stdin</code> et d'écriture sur <code>stdout</code>, en ajoutant cette ligne au début du fichier source :</p>
<pre>#include &lt;fcntl.h&gt;</pre>
<p>et en ajoutant les deux lignes suivantes dans la fonction <code>main()</code>, après la déclaration initiale des variables :</p>
<pre>setmode(fileno(stdout), O_BINARY);
setmode(fileno(stdin), O_BINARY);</pre>
<p>Activer le mode de lecture binaire du fichier d'entrée en remplaçant <code>"r"</code> par <code>"rb"</code> dans le second paramètre de l'appel à <code>fopen()</code> dans la fonction <code>argument_to_file()</code>. La ligne modifiée est :</p>
<pre>        : fopen(av[idx], "rb");</pre>
</div>

<p>Compiler le convertisseur :</p>
<pre><strong>$ gcc -o converter-sample.exe -I. -DPDU=RSAPublicKey *.c</strong></pre>

<p>Convertir la clé publique existante en structure <code>RSAPublicKey</code> au format DER.</p>
<pre><strong>$ openssl rsa -in ee-key.pem -inform PEM -RSAPublicKey_out -outform DER \
  -out ee-RSAPublicKey.der</strong></pre>

<p>Convertir cette structure DER au format XER :</p>
<pre><strong>$ converter-sample -iber -oxer ee-RSAPublicKey.der</strong>
<![CDATA[<RSAPublicKey>
    <modulus>00:B8:6F:48:F9:99:F1:99:71:C6:6F:80:64:D1:CA:0C:1A:6E:C8:8A:F3:B9:3
9:FD:07:08:8D:97:B2:BE:1E:27:95:BD:1E:86:88:FF:0E:61:72:B7:3D:37:A5:B8:19:35:C7:
C3:AE:57:A2:7E:5D:46:F3:83:83:08:9C:44:10:ED:A9:5D:1E:FA:99:C4:93:15:86:CE:57:49
:00:60:00:39:02:03:4A:35:8E:07:F9:0F:F2:D3:47:34:2E:6B:F9:51:39:E0:6E:63:F3:C9:9
7:87:4F:4B:35:E8:DA:3A:87:F4:F5:18:8A:86:74:C1:B1:1B:A0:F3:29:FC:5C:2E:B6:CD:26:
F4:65:75:1C:37:89:C6:B9:7E:39:63:36:8A:A1:88:19:10:26:2B:A9:D8:FE:E7:9D:34:34:E7
:22:A2:30:2D:F4:E8:2D:39:79:35:5B:62:54:D0:32:A3:A5:2C:31:7F:A5:D2:98:40:36:93:A
6:C3:A1:66:5F:3F:F6:FC:ED:45:4A:06:45:97:F5:EF:41:7E:68:BB:7F:D2:D3:89:2B:4F:04:
CD:35:9F:2B:01:33:46:00:12:BE:7B:52:82:DB:23:AA:D2:3F:FB:37:64:0F:65:5F:98:F3:80
:6F:10:D9:B4:BF:75:2F:41:A7:E5:BD:17:3A:B8:34:5B:81:FD:5C:8D:D1</modulus>
    <publicExponent>65537</publicExponent>
</RSAPublicKey>]]></pre>

<p class="note">Les entiers (<code>INTEGER</code>) supérieurs à 2<sup>31</sup>-1 sont représentés par des octets hexadécimals séparés par des « <code>:</code> ».</p>

<p>Le résultat obtenu permet de se familiariser avec le schéma XML correspondant au module ASN.1.</p>

<p>Une <code>RSAPublicKey</code> décrite en XER peut être convertie au format DER en utilisant les options <code>-ixer</code> et <code>-oder</code>. Ainsi, à partir du résultat ci-dessus préalablement stocké dans le fichier <code>ee-RSAPublicKey.xer</code> :</p>

<pre><strong>$ converter-sample -ixer -oder ee-RSAPublicKey.xer \
  | openssl asn1parse -inform DER -i</strong>
    0:d=0  hl=4 l= 266 cons: SEQUENCE
    4:d=1  hl=4 l= 257 prim:  INTEGER           :B86F48F999F19971C66F8064D1CA0C1
A6EC88AF3B939FD07088D97B2BE1E2795BD1E8688FF0E6172B73D37A5B81935C7C3AE57A27E5D46F
38383089C4410EDA95D1EFA99C4931586CE57490060003902034A358E07F90FF2D347342E6BF9513
9E06E63F3C997874F4B35E8DA3A87F4F5188A8674C1B11BA0F329FC5C2EB6CD26F465751C3789C6B
97E3963368AA1881910262BA9D8FEE79D3434E722A2302DF4E82D3979355B6254D032A3A52C317FA
5D298403693A6C3A1665F3FF6FCED454A064597F5EF417E68BB7FD2D3892B4F04CD359F2B0133460
012BE7B5282DB23AAD23FFB37640F655F98F3806F10D9B4BF752F41A7E5BD173AB8345B81FD5C8DD
1
  265:d=1  hl=2 l=   3 prim:  INTEGER           :010001</pre>

<p>Avec « un peu » de patience pour obtenir et adapter les modules, il est possible d'adapter et de compiler l'ensemble des modules ASN.1 correspondant aux certificats X.509, aux jetons TSP, aux capsules CMS et CAdES etc., de manière à pouvoir travailler sur les représentations XER des structures ASN.1 correspondantes, plus faciles à manipuler et modifier que les codages binaires.</p>

<h1 id="openssl">Compilation et installation d'OpenSSL</h1>
<p>Les instructions de compilation et installation décrites dans le fichier <code>INSTALL</code> (pour UNIX/Linux) du code source d'OpenSSL fonctionnent parfaitement. Celles pour Windows (dans <code>INSTALL.W32</code>) fonctionnent de manière variable en fonction du compilateur et des versions successives d'OpenSSL. Cette annexe donne quelques conseils pour installer OpenSSL sous ces environnements.</p>
<h2 id="openssl-linux">Linux</h2>
<p>Les distributions Linux incluent le plus souvent une version d'OpenSSL, qui est rarement la dernière parue. Les instructions ci-après permettent de faire coexister la dernière version d'OpenSSL avec la version du système (dont les bibliothèques sont souvent nécessaires à l'utilisation d'autres applications ou services, et dont la modification peut donc avoir des effets de bord non souhaitables). Les pré-requis sont l'installation de Perl 5 et gcc.</p>
<p>Télécharger la dernière version d'OpenSSL (la version 1.0.1a à la date de rédaction — se reporter au site d'OpenSSL<span class="fn">http://www.openssl.org/</span> pour connaître la dernière version à la date de lecture) dans un répertoire (pour fixer les idées, ce répertoire est supposé être <code>~/src</code>) :</p>
<pre><strong>$ wget http://www.openssl.org/source/openssl-1.0.1a.tar.gz</strong></pre>
<p>ou</p>
<pre><strong>$ curl -O http://www.openssl.org/source/openssl-1.0.1a.tar.gz</strong></pre>
<p>ou toute commande équivalente (ex. : copie FTP/SCP depuis une autre machine ayant accès à Internet), en fonction des possibilités de la machine.</p>
<p>Décompresser l'archive :</p>
<pre><strong>$ tar xvzf ../openssl-1.0.1a.tar.gz
$ cd openssl-1.0.1a</strong></pre>
<p>Configurer la compilation. Pour une installation transverse, si l'accès à un shell <code>root</code> sera possible lors de la phase d'installation, alors utiliser la commande suivante :</p>
<pre><strong>$ ./config --prefix /opt/openssl-1.0.1a shared</strong></pre>
<p>Si l'accès <code>root</code> ne sera pas disponible, alors utiliser :</p>
<pre><strong>$ ./config --prefix $HOME/openssl-1.0.1a shared</strong></pre>
<p class="note">Pour éviter des conflits de fichiers, remplacer <code>$HOME/openssl-1.0.1a</code> si le code source a été décompressé dans ce répertoire (au lieu pas exemple de <strong>~/src</strong> comme proposé ci-avant).</p>
<p>Si la configuration n'a soulevé aucune erreur, alors démarrer la compilation.</p>
<pre><strong>$ make</strong></pre>
<p>Cette opération dure de quelques minutes à quelques dizaines de minutes selon la puissance de la machine. (Si elle dure significativement plus longtemps, alors la machine n'est peut-être pas la plus adéquate pour effectuer des calculs cryptographiques complexes !)</p>
<p>Si la compilation ne génère aucune erreur, alors effectuer optionnellement les tests (<code>$ make test</code>) puis procéder à l'installation. S'il s'agit d'une installation transverse à la machine (dans <code>/opt/openssl-1.0.1a</code>), se connecter à la machine avec le compte <code>root</code> (ou employer <code>sudo</code>) et se rendre dans le répertoire de compilation (<strong>~<i>utilisateur_compilateur</i>/src/openssl-1.0.1a</strong>) au préalable.</p>
<pre><strong>$ make install</strong></pre>
<p>ou (cas <code>root</code>)</p>
<pre><strong># make install</strong></pre>
<p class="note">Le compte <code>root</code> n'est plus nécessaire pour la suite.</p>
<p>Créer s'il n'existe pas le répertoire <code>~/bin</code>. Ajouter, s'il n'y est pas déjà, le répertoire <code>$HOME/bin</code> à la fin de la variable d'environnement <code>$PATH</code> du profil de l'utilisateur (par exemple sous bash en ajoutant la ligne <code>PATH=$PATH:$HOME/bin</code> en fin de fichier <code>~/.bash_profile</code>). Enfin, créer dans <code>~/bin</code>un lien symbolique vers l'exécutable <code>openssl</code> :</p>
<pre><strong>$ ln -s /opt/openssl-1.0.1a/bin/openssl ~/bin/openssl-1.0.1a</strong></pre>
 
dans le cas d'une installation commune, ou (dans le cas d'une installation pour l'utilisateur uniquement) :
 
<pre><strong>$ ln -s ~/openssl-1.0.1a/bin/openssl ~/bin/openssl-1.0.1a</strong></pre>
<p class="note">Les utilisateurs souhaitant utiliser la commande <code>openssl</code> au lieu de <code>openssl-1.0.1a</code> et conscients des risques de sécurité sous-jacents, peuvent nommer le lien symbolique <code>openssl</code> et ajouter <code>$HOME/bin</code> au <em>début</em> de la variable d'environnement <code>$PATH</code> (donc <code>PATH=$HOME/bin:$PATH</code>).</p>
<p>Redémarrer la session si la variable <code>$PATH</code> a été modifiée dans le profil, et vérifier que tout fonctionne comme attendu :</p>
<pre><strong>$ openssl-1.0.1a version</strong>
OpenSSL 1.0.1a 19 Apr 2012</pre>
<p>Le répertoire de compilation d'OpenSSL n'est plus nécessaire et peut être supprimé. Pour supprimer l'installation d'OpenSSL, supprimer simplement le répertoire d'installation (ex. : <code>$ rm -Rf ~/openssl-x.x.x</code> ou <code># rm -Rf /opt/openssl-x.x.x</code>, avec les précautions d'usage applicables à l'utilisation de <code>rm -Rf</code> !).</p>
<h2 id="openssl-windows">Windows</h2>
<p>Cette section propose un mode opératoire pour compiler OpenSSL sous Windows de manière à pouvoir utiliser le moteur cryptographique <code>capi</code>. D'autres méthodes sont possibles (et sont décrites dans le fichier <code>INSTALL.W32</code> à la racine du paquetage source d'OpenSSL) mais présentent certaines limitations en l'absence de modifications.</p>
<p>La compilation d'OpenSSL sous Windows suppose que les logiciels suivants sont installés :</p>
<ul>
<li>Perl : ActivePerl Community Edition<span class="fn">http://www.activestate.com/activeperl/downloads</span> et Strawberry Perl<span class="fn">http://strawberryperl.com/</span> sont des versions gratuites de Perl pour Windows.</li>
<li>L'assembleur nasm<span class="fn">http://nasm.sourceforge.net/</span>, optionnellement utilisé pour tirer parti de code accéléré pour certaines fonctions de bas niveau (opérations sur les grands nombres et calculs cryptographiques).</li>
<li>Un compilateur C : celui utilisé ci-après est le compilateur inclus dans Visual C++ Express Edition 2010 (l'utilisation des versions précédentes, 2005 et 2008, devrait également être possible) de Microsoft, disponible gratuitement au téléchargement sur le site de Visual Studio<span class="fn">http://www.microsoft.com/visualstudio/en-us/products/2010-editions/express</span>.</li>
</ul>
<p>Télécharger le code source d'OpenSSL à partir du site www.openssl.org<span class="fn">http://www.openssl.org</span>. Le code source se présente sous la forme d'une archive compressée, portant un nom du type <code>openssl-<em>x.x.x</em>.tar.gz</code>. Décompresser cette archive.</p>
<p>Pour les versions 1.0.1 à (au moins) 1.0.1b d'OpenSSL, modifier le code du script <code>util/mk1mf.pl</code> comme décrit sur cette page<span class="fn">http://groups.google.com/group/mailing.openssl.users/browse_thread/thread/42a8f226f1fc279f</span>, en ajoutant la ligne <code>s/\r$//;</code> après la ligne <code>chop ;</code>.</p>
<p>Depuis le répertoire source d'OpenSSL, configurer la compilation :</p>
<pre><strong>> perl Configure VC-WIN32 --prefix=c:\openssl\openssl-1.0.1b
> ms\do_nasm</strong></pre>
<p>Ouvrir ensuite une invite de commande de Visual C++ 2010, et démarrer la compilation :</p>
<pre><strong>> nmake -f ms\ntdll.mak</strong></pre>
<p>Dans cette même invite de commande, lancer optionnellement les tests :</p>
<pre><strong>> nmake -f ms\ntdll.mak test</strong></pre>
<p>Installer enfin OpenSSL :</p>
<pre><strong>> nmake -f ms\ntdll.mak install</strong></pre>

<h1 id="xmlsec-windows">Compilation de xmlsec sous Windows</h1>

<p>La compilation de xmlsec repose sur la compilation préalable de plusieurs bibliothèques. Télécharger et décompresser le code source de libxml2<span class="fn">http://xmlsoft.org/</span>, libxslt<span class="fn">http://xmlsoft.org/</span>, xmlsec<span class="fn">http://www.aleksey.com/xmlsec/</span>, et compiler OpenSSL comme décrit dans l'annexe consacrée à ce sujet.</p>

<p class="note">Les bibliothèques libxml2, libxslt et xmlsec peuvent s'appuyer sur iconv, mais cette option n'est pas retenue car la compilation d'iconv supporte uniquement MinGW, contrairement aux autres bibliothèques qui privilégient ou supportent uniquement Visual C++, et les incompatibilités entre les bibliothèques produites par les deux compilateurs compliquent la procédure. De même, les bibliothèques peuvent s'appuyer sur zlib, mais cela n'apportant rien dans le cadre des manipulations proposées dans ce document, la compilation de zlib est omise.</p>

<p>L'environnement de compilation est Visual C++ 2010 Express. Le répertoire d'installation de xmlsec est noté <code><em>XMLSEC_DIR</em></code>.</p>

<h2 id="libxml2">Compilation de libxml2</h2>

<p>Effectuer les modifications suivantes dans le fichier <code>win32/Makefile.msvc</code> du répertoire source de libxml2 :</p>

<ul>
<li>Supprimer les symboles « <code>+</code> » au début de chacune des trois lignes référencées dans ce patch<span class="fn">http://git.gnome.org/browse/libxml2/commit/?id=364e3d2b054656f2cf97594365d15b2ddb72a9ed</span>.</li>
<li>Effacer l'option de compilation <code>/OPT:NOWIN98</code> (obsolète sous Visual Studio 2008 et supprimée sous Visual Studio 2010).</li>
</ul>

<p>Ouvrir une invite de commande Visual C++ 2010 Express dans le sous-répertoire <code>win32</code> du répertoire source, et configurer la compilation.</p>

<pre><strong>> cscript configure.js iconv=no prefix=<em>XMLSEC_DIR</em></strong></pre>

<p>Démarrer la compilation et l'installation, depuis le même répertoire.</p>

<pre><strong>> nmake /f Makefile.msvc clean all install</strong></pre>

<p>Déplacer <code>libxml2.dll</code> du répertoire <code><em>XMLSEC_DIR</em>/lib</code> vers <code><em>XMLSEC_DIR</em>/bin</code>.</p>

<p class="note">Pour vérifier que la compilation et l'installation se sont effectuées correctement, ouvrir une invite de commande standard dans <code><em>XMLSEC_DIR</em>/bin</code>, réinitialiser la variable d'environnement <code>PATH</code> (via <code>set PATH=</code> par exemple) pour éviter d'éventuels conflits avec des bibliothèques pré-installées dans un des répertoires de <code>PATH</code>, copier les sous-répertoires <code>test</code> et <code>result</code> du répertoire source de libxml2 dans <code><em>XMLSEC_DIR</em>/bin</code>, et exécuter <code>runtest.exe</code>. Quelques milliers de tests devraient se dérouler, avec une poignée d'erreurs tout au plus.</p>

<h2 id="libxslt">Compilation de libxslt</h2>

<p>Dans le fichier <code>win32/Makefile.msvc</code> du répertoire source de libxslt, effacer l'option de compilation <code>/OPT:NOWIN98</code>.</p>

<p>Ouvrir une invite de commande Visual C++ 2010 Express dans le sous-répertoire <code>win32</code> du répertoire source, et configurer la compilation.</p>

<pre><strong>> cscript configure.js iconv=no prefix=<em>XMLSEC_DIR</em> \
  lib=$(PREFIX)\lib include=$(PREFIX)\include</strong></pre>

<p>Démarrer la compilation et l'installation, depuis le même répertoire.</p>
<pre><strong>> nmake /f Makefile.msvc clean all install</strong></pre>

<p>Déplacer <code>libxslt.dll</code> et <code>libexslt.dll</code> du répertoire <code><em>XMLSEC_DIR</em>/lib</code> vers <code><em>XMLSEC_DIR</em>/bin</code>.</p>

<h2 id="xmlsec">Compilation et installation de xmlsec</h2>

<p>Avant tout, copier les sous-répertoires <code>bin</code>, <code>include</code> et <code>lib</code> du répertoire d'installation d'OpenSSL dans le répertoire <code><em>XMLSEC_DIR</em></code> (fusionnant ainsi avec les sous-répertoires équivalents).</p>

<p>Optionnellement, dans le fichier <code>win32/configure.js</code>, remplacer <code>"098"</code> par <code>"101"</code> dans la ligne <code>withOpenSSLVersion = "098"; /* default */</code>.</p>

<p>Dans le fichier <code>win32/Makefile.msvc</code> du répertoire source de xmlsec, effacer l'option de compilation <code>/OPT:NOWIN98</code>.</p>

<p>Ouvrir une invite de commande dans le sous-répertoire <code>win32</code> du répertoire source, et configurer la compilation.</p>

<pre><strong>> cscript configure.js iconv=no prefix=<em>XMLSEC_DIR</em> \
  lib=$(PREFIX)\lib include=$(PREFIX)\include static=no</strong></pre>

<p>Démarrer la compilation et l'installation, depuis le même répertoire.</p>

<pre><strong>> nmake /f Makefile.msvc clean all install</strong></pre>

<p>Déplacer <code>libxmlsec.dll</code> et <code>libxmlsec-openssl.dll</code> du répertoire <code><em>XMLSEC_DIR</em>/lib</code> vers <code><em>XMLSEC_DIR</em>/bin</code>.</p>

<p>L'exécutable résultant de la compilation, <code>xmlsec.exe</code>, est compilé avec les bibliothèques libxml, libxslt et libxmlsec de manière dynamique (et charge la bibliothèque libxmlsec-openssl de manière dynamique à l'exécution), c'est-à-dire que pour pouvoir exécuter <code>xmlsec.exe</code>, les fichiers DLL <code>libxml2.dll</code>, <code>libxslt.dll</code>, <code>libxmlsec.dll</code> et <code>libxmlsec-openssl.dll</code> doivent être dans le répertoire courant ou dans un répertoire inclus dans la variable d'environnement <code>PATH</code>. Après l'installation initiale, pour générer la version compilée de manière statique (plus grande, mais ne dépendant pas des bibliothèques dynamiques), configurer la compilation avec l'option <code>with-dl=no</code> (<code>static=yes</code> étant implicite) :</p>

<pre><strong>> cscript configure.js iconv=no prefix=<em>XMLSEC_DIR</em> \
  lib=$(PREFIX)\lib include=$(PREFIX)\include with-dl=no</strong></pre>

<p>Démarrer la compilation sans installation (omettre le paramètre <code>install</code>).</p>

<pre><strong>> nmake /f Makefile.msvc clean all install</strong></pre>

<p>Copier l'exécutable <code>xmlseca.exe</code> ainsi généré du sous-répertoire <code>win32/binaries</code> du répertoire de compilation vers <code><em>XMLSEC_DIR</em>/bin</code>.</p>

<p class="note">L'exécutable reste dépendant de la bibliothèque dynamique <code>libeay32.dll</code>.</p>

<h1 id="windows">Spécificités de Windows</h1>
<h2 id="openssl-capi">OpenSSL et CryptoAPI</h2>
<p>OpenSSL peut s'appuyer sur des moteurs cryptographiques tiers (appelés
<i>engines</i>), dont la CryptoAPI (ou CAPI) Microsoft, l'API cryptographique
native de Windows. Sans configuration spécifique, OpenSSL s'attend à ce que
les bibliothèques dynamiques associées aux <i>engines</i> (par exemple
<code>capi.dll</code> pour la CryptoAPI) soient situées dans le
sous-répertoire <code>lib/engines</code> du répertoire d'installation par
défaut d'OpenSSL, lequel est compilé dans l'exécutable <code>openssl</code>.
Si tel est le cas, alors la commande suivante, qui affiche les CSP
(<i>Cryptographic Service Provider</i> ou fournisseur de service
cryptographique) installés, ne provoque aucune erreur :</p>
<pre><strong>&gt; openssl engine -t capi -post list_csps</strong>
(capi) CryptoAPI ENGINE
     [ available ]
Available CSPs:
0. Microsoft Base Cryptographic Provider v1.0, type 1
1. Microsoft Base DSS and Diffie-Hellman Cryptographic Provider, type 13
2. Microsoft Base DSS Cryptographic Provider, type 3
3. Microsoft Base Smart Card Crypto Provider, type 1
4. Microsoft DH SChannel Cryptographic Provider, type 18
5. Microsoft Enhanced Cryptographic Provider v1.0, type 1
6. Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider, type 13
7. Microsoft Enhanced RSA and AES Cryptographic Provider, type 24
8. Microsoft Exchange Cryptographic Provider v1.0, type 5
9. Microsoft RSA SChannel Cryptographic Provider, type 12
10. Microsoft Strong Cryptographic Provider, type 1
[Success]: list_csps</pre>
<p>Dans le cas contraire, une ligne telle que celle-ci fait savoir que la
bibliothèque ne se trouve pas lans le répertoire prévu :</p>
<pre>2068:error:25078067:DSO support routines:WIN32_LOAD:could not load the shared li
brary:.\crypto\dso\dso_win32.c:180:filename(c:\openssl\openssl-1.0.1\lib\engines
\capi.dll)</pre>
<div class="note"><p>La commande <code>openssl engine</code> permet
de définir les paramètres de chargement d'un moteur cryptographique en ligne
de commande, notamment le chemin de la bibliothèque (<code>-pre
SO_PATH:…\lib\engines\capi.dll</code> pour la CryptoAPI), et l'identifiant de
l'<i>engine</i> tel que défini par OpenSSL (<code>-pre ID:capi</code>). Pour
une raison que ne comprend pas l'auteur (<i>bug</i> ?), cet usage permet
uniquement de charger l'<i>engine</i> (via <code>-pre LOAD</code>), mais ignore
l'exécution de commandes (ci-dessous la commande <code>list_csps</code> n'est
pas exécutée). L'auteur n'a pas creusé ce point, car il permettrait de
résoudre le problème pour la commande <code>openssl engine</code> uniquement,
et non pour les autres commandes, qui n'acceptent pas les options
<code>-pre</code>.</p>
<pre><strong>&gt; openssl engine -t dynamic -pre SO_PATH:…\lib\engines\capi.dll -pre ID:capi \
  -pre LOAD -post list_csps</strong>
(dynamic) Dynamic engine loading support
[Success]: SO_PATH:…\lib\engines\capi.dll
[Success]: ID:capi
[Success]: LOAD
Loaded: (capi) CryptoAPI ENGINE
     [ available ]</pre>
</div>
<p>Il est possible de définir le chemin des bibliothèques des moteurs
cryptographiques dans le fichier de configuration <code>openssl.cnf</code>,
qu'OpenSSL s'attend par défaut à trouver dans le sous-répertoire
<code>ssl</code> du répertoire d'installation. L'absence de ce fichier de
configuration se traduit par l'avertissement <code>WARNING: can't open config
file:…</code> au lancement de toutes les commandes <code>openssl</code>. Si
certaines commandes <code>openssl</code> permettent de définir l'emplacement
d'un fichier de configuration alternatif (option <code>-config</code>), ce
n'est pas le cas de toutes. Heureusement, une fonctionnalité parfois méconnue
(mentionnée ici<span class="fn">http://www.openssl.org/docs/crypto/OPENSSL_config.html</span> ou encore
ici<span class="fn">http://www.openssl.org/docs/apps/req.html</span>) permet de modifier
l'emplacement du fichier de configuration consulté par OpenSSL, en affectant
à la variable d'environnement <code>OPENSSL_CONF</code> le chemin du
fichier.</p>
<p>Créer le fichier de configuration ci-dessous — inspiré de cet échange<span class="fn">http://www.mail-archive.com/openssl-users@openssl.org/msg62249.html</span> — sous le nom <code><em>CONF_DIR</em>\capi.cnf</code>, où <code><em>CONF_DIR</em></code> est un répertoire arbitraire. Dans ce fichier, <code><em>OPENSSL_DIR</em></code> est à remplacer par le chemin du répertoire d'installation d'OpenSSL, en veillant à échapper le caractère
« <code>\</code> » avec « <code>\</code> » (en d'autres termes,
utiliser « <code>\\</code> » comme séparateur de sous-répertoires).</p>
<pre>openssl_conf = openssl_init

[openssl_init]
engines = engine_section

[engine_section]
capi = capi_config

[capi_config]
engine_id = capi
dynamic_path = <i>OPENSSL_DIR</i>\\lib\\engines\\capi.dll
init=1</pre>
<p>Utiliser la variable d'environnememt <code>OPENSSL_CONF</code> pour définir
l'emplacement du fichier de configuration, et tenter à nouveau d'afficher les
CSP :</p>
<pre><strong>&gt; set OPENSSL_CONF=<i>CONF_DIR</i>\capi.cnf
&gt; openssl engine -t capi -post list_csps</strong></pre>

<p>La liste des commandes supportées peut être affichée via :</p>

<pre><strong>> openssl engine -vvvv -t capi</strong>
(capi) CryptoAPI ENGINE
     [ available ]
     list_certs: List all certificates in store
          (input flags): NO_INPUT
     lookup_cert: Lookup and output certificates
          (input flags): STRING
     debug_level: debug level (1=errors, 2=trace)
          (input flags): NUMERIC
     debug_file: debugging filename)
          (input flags): STRING
     key_type: Key type: 1=AT_KEYEXCHANGE (default), 2=AT_SIGNATURE
          (input flags): NUMERIC
     list_csps: List all CSPs
          (input flags): NO_INPUT
     csp_idx: Set CSP by index
          (input flags): NUMERIC
     csp_name: Set CSP name, (default CSP used if not specified)
          (input flags): STRING
     csp_type: Set CSP type, (default RSA_PROV_FULL)
          (input flags): NUMERIC
     list_containers: list container names
          (input flags): NO_INPUT
     list_options: Set list options (1=summary,2=friendly name, 4=full printout,
 8=PEM output, 16=XXX, 32=private key info)
          (input flags): NUMERIC
     lookup_method: Set key lookup method (1=substring, 2=friendlyname, 3=contai
ner name)
          (input flags): NUMERIC
     store_name: certificate store name, default "MY"
          (input flags): STRING
     store_flags: Certificate store flags: 1 = system store
          (input flags): NUMERIC</pre>

<p>Pour déboguer l'utilisation du moteur <code>capi</code>, ajouter les deux lignes suivantes après la ligne <code>init=1</code> du fichier de configuration ci-dessus :</p>

<pre>debug_level = 2
debug_file = capi.log</pre>

<p>Chaque utilisation du moteur <code>capi</code> ajoutera des lignes de trace à la fin du fichier <code>capi.log</code> (créé au besoin).</p>

<h2 id="windows-magasin">Analyse du magasin de certificats de Windows</h2>

<p>Les certificats logiciels de l'utilisateur sont généralement situés dans l'un des répertoires suivants :</p>

<ul>
<li>Sous Windows XP : <code>C:\Documents and Settings\<em>&lt;utilisateur&gt;</em>\Application Data\Microsoft\SystemCertificates\My\Certificates</code>.</li>
<li>Sous Windows Vista/7 : <code>C:\Users\<em>&lt;utilisateur&gt;</em>\AppData\Roaming\Microsoft\SystemCertificates\My\Certificates</code>.</li>
</ul>

<p class="note">La liste complète des emplacements où sont stockés les certificats est disponible sur cette page<span class="fn">http://msdn.microsoft.com/en-us/library/windows/desktop/bb204781%28v=vs.85%29.aspx</span> relative à la migration de magasin de certificats.</p>

<p>Le nom du fichier correspondant à un certificat donné est l'empreinte SHA-1 du codage DER du certificat, dont l'obtention a été décrite dans la section <a href="#importation-magasin-windows" class="section"/>.</p>

<p>Si elle existe, alors la clé privée associée à un certificat du magasin de certificats de Windows a un identifiant de conteneur unique de type GUID (<i>Globally Unique IDentifier</i>), affichable par exemple de la manière suivante à partir d'une recherche sur le nom convivial du certificat :</p>
<pre><strong>> openssl engine -t capi -post lookup_method:2 -post list_options:32 \
  -post lookup_cert:"OpenSSL EE"</strong>
(capi) CryptoAPI ENGINE
     [ available ]
[Success]: lookup_method:2
[Success]: list_options:32
  Private Key Info:
    Provider Name:  Microsoft Enhanced Cryptographic Provider v1.0, Provider Typ
e 1
    Container Name: {B05E3F2B-27AE-48B6-A33E-3CB4A6BDF046}, Key Type 1
[Success]: lookup_cert:OpenSSL EE</pre>

<p>Le GUID <code>B05E3F2B-27AE-48B6-A33E-3CB4A6BDF046</code> est ici l'identifiant recherché.</p>

<p>Un outil C# est proposé pour obtenir le GUID du conteneur de la clé privée à partir d'un certificat sélectionné dans une boîte de dialogue Windows. Créer le fichier <code>GetContainerNameFromCertPicker.cs</code> suivant :</p>

<pre><![CDATA[using System;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

class CertSelect {
    static void Main() {
        try {
            X509Store store = new X509Store("MY",StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);
            X509Certificate2Collection collection =
                X509Certificate2UI.SelectFromCollection(
                    (X509Certificate2Collection)store.Certificates,
                    "Certificate selection",
                    "Select a certificate to obtain the container name from",
                    X509SelectionFlag.SingleSelection);
            
            if (collection.Count == 1) {
                X509Certificate2 x509 = collection[0] ;
                Console.WriteLine("Subject: {0}", x509.Subject) ;
                Console.WriteLine("Friendly name: {0}", x509.FriendlyName) ;
                if (x509.PrivateKey != null) {
                    ICspAsymmetricAlgorithm pkey = x509.PrivateKey
                        as ICspAsymmetricAlgorithm ;
                    Console.WriteLine("Key container name: {0}",
                        pkey.CspKeyContainerInfo.KeyContainerName);
                }
                x509.Reset();
            }
            store.Close();
        }
        catch (Exception e) {
           Console.WriteLine(e.ToString()) ;
        }
    }
}]]></pre>

<p>Compiler le code à l'aide de la commande suivante :</p>

<pre><strong>> <em>&lt;chemin_vers&gt;</em>\csc.exe GetContainerNameFromCertPicker.cs</strong></pre>

<p class="note">Le <i>framework</i> .NET de Microsoft doit être installé pour disposer du compilateur C# <code>csc.exe</code>. Celui-ci est alors situé dans le répertoire <code>C:\WINDOWS\Microsoft.NET\Framework\<em>&lt;version&gt;</em>\</code>.</p>

<p>Exécuter <code>GetContainerNameFromCertPicker.exe</code>, et sélectionner un certificat dans la boîte de dialogue.</p>

<pre><strong>> GetContainerNameFromCertPicker</strong>
Subject: CN=Entité Finale, OU=0002 963852741, O=Mon Organisation, C=FR
Friendly name: OpenSSL EE2
Key container name: {554D37DB-5F0B-4050-ABE1-379D3FD39533}</pre>

<p>Pour les utilisateurs, les clés privées RSA sont généralement stockées dans des fichiers situés dans l'un des répertoires suivants :</p>

<ul>
<li>Sous Windows XP : <code>C:\Documents and Settings\<em>&lt;utilisateur&gt;</em>\Application Data\Microsoft\Crypto\RSA\S-1-5-21-…</code>, où <code>S-1-5-21-…</code> est le SID<span class="fn">http://technet.microsoft.com/en-us/sysinternals/bb897417</span> (<i>Security IDentifier</i>, ou identifiant de sécurité) de l'utilisateur, identifiant celui-ci de manière unique.</li>
<li>Sous Windows Vista/7 : <code>C:\Users\<em>&lt;utilisateur&gt;</em>\AppData\Roaming\Microsoft\Crypto\RSA\S-1-5-21-…</code>.</li>
</ul>

<p class="note">Cette page<span class="fn">http://msdn.microsoft.com/en-us/library/bb204778%28v=vs.85%29.aspx</span> donne la liste exhaustive des cas de figure rencontrés.</p>

<p>La méthode la plus simple pour déterminer le fichier contenant une clé privée donnée consiste à faire correspondre la date et l'heure de génération ou d'importation de la clé privée avec la date des fichiers dans le répertoire des clés privées RSA. À défaut d'informations sur la date et l'heure de génération, il est possible d'utiliser l'algorithme décrit par Steve Johnson<span class="fn">http://www.stevestechspot.com/SSLCertificatesWrapup.aspx</span> pour déterminer le nom du fichier contenant la clé privée à partir d'un GUID donné. Cet algorithme peut être automatisé à l'aide d'une application C# : télécharger l'archive <code>RsaUtil.zip</code> de la page web référencée, extraire le fichier <code>RsaUtil.cs</code> dans un répertoire arbitraire, et créer le fichier <code>GetRsaKeyContainerFilename.cs</code> suivant dans le même répertoire :</p>

<pre><![CDATA[using System;

public class GetRsaKeyContainerFilename {
    static void Main(string[] args) {
        if (args.Length == 0) {
            Console.WriteLine(
                "Syntax: GetRsaKeyContainerFilename <private key GUID>"
            ) ;
        }
        else {
            Console.WriteLine(
                RsaUtil.RsaKeyFileUtil.GetRsaKeyContainerFilename(
                    args[0], false
                )
            ) ;
        }
    }
}]]></pre>

<p>Compiler les deux fichiers source à l'aide de la commande suivante :</p>

<pre><strong>> <em>&lt;chemin_vers&gt;</em>\csc.exe RsaUtil.cs GetRsaKeyContainerFilename.cs</strong></pre>

<p>Exécuter le fichier <code>GetRsaKeyContainerFilename.exe</code> résultant, en passant le GUID en paramètre, par exemple :</p>

<pre><strong>> GetRsaKeyContainerFilename.exe {554D37DB-5F0B-4050-ABE1-379D3FD39533}</strong>
C:\Documents and Settings\<em>&lt;utilisateur&gt;</em>\Application Data\Microsoft\Crypto\RSA\S-
1-5-21-<em>xxxxxxxx-xxxxxxxxxx-xxxxxxxxx-xxxxx</em>\df499da8fc142b55c15a9d7e1a3fa6b9_665d
02d4-e128-4978-8058-4969c9695bf6</pre>

<p>La structure du fichier dont le chemin est retourné n'est pas documenté, mais un peu de travail de reconnaissance de motifs permet de distinguer quatre parties :</p>
<ul>
<li>Une en-tête référençant notamment le GUID de la clé privée.</li>
<li>La clé publique.</li>
<li>La clé privée, protégée.</li>
<li>Le drapeau d'exportation de la clé privée, protégé.</li>
</ul>

<p class="note">Les positions relatives de ces blocs de données varient en fonction du type et de la taille du bi-clé, mais devraient être les suivantes pour un bi-clé RSA de 2048 bits, à adapter au besoin.</p>

<p>Le bloc d'en-tête pour la clé privée considérée est le suivant (octets <code>0x0000</code> à <code>0x0062</code> du fichier d'entrée). Noter la chaîne de caractères du GUID de la clé privée.</p>

<pre><strong>> od -tx1z -Ax -N0x73 <em>&lt;fichier clé privée&gt;</em></strong>
<![CDATA[000000 02 00 00 00 01 00 00 00 27 00 00 00 00 00 00 00  >........'.......<
000010 00 00 00 00 1c 01 00 00 f2 05 00 00 14 00 00 00  >........‗.......<
000020 00 00 00 00 a8 00 00 00 7b 35 35 34 44 33 37 44  >....¿...{554D37D<
000030 42 2d 35 46 30 42 2d 34 30 35 30 2d 41 42 45 31  >B-5F0B-4050-ABE1<
000040 2d 33 37 39 44 33 46 44 33 39 35 33 33 7d 00 00  >-379D3FD39533}..<
000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  >................<
000060 00 00 00                                         >...<
000063]]></pre>

<p>La clé publique est représentée par le bloc suivant (octets <code>0x0063</code> à <code>0x017e</code> du fichier d'entrée, soit une longueur de <code>0x011C</code> octets).</p>

<pre><strong>> od -tx1z -Ax -j0x63 -N0x011C <em>&lt;fichier clé privée&gt;</em></strong>
<![CDATA[000063 52 53 41 31 08 01 00 00 00 08 00 00 ff 00 00 00  >RSA1........ ...<
000073 01 00 01 00 ed 6b 32 2b a8 7b 67 78 50 45 d9 af  >....Ýk2+¿{gxPE┘»<
000083 ae bb 35 06 29 24 09 4f ff 54 f1 d6 75 53 61 89  >«╗5.)$ O T±ÍuSaë<
000093 a6 b8 4a a7 87 dc af 2c 21 3a 7d 82 92 de 56 15  >ª©Jºç▄»,!:}éÆÌV.<
0000a3 ac d8 59 18 ea 79 03 ea c5 19 21 57 40 7c 3f e8  >¼ÏY.Ûy.Û┼.!W@|?Þ<
0000b3 4d 73 08 09 78 49 82 df 39 35 5b a3 59 d5 b6 34  >Ms. xIé▀95[úYıÂ4<
0000c3 27 7a 90 65 12 15 95 8b 1a c8 7e dc 8e 37 47 48  >'z.e..òï.╚~▄Ä7GH<
0000d3 71 6b c8 6d 58 3e af b8 b2 84 69 7a cf 95 51 c0  >qk╚mX>»©▓äiz¤òQ└<
0000e3 40 b8 2e 03 98 d8 ea 69 96 0d 71 b1 67 e3 d9 93  >@©...ÏÛiû.q▒gÒ┘ô<
0000f3 6b e3 a9 a6 40 2e 8c b9 08 06 95 35 6f 2f a6 11  >kÒ®ª@.î╣..ò5o/ª.<
000103 18 2d 43 00 a3 36 0a 40 b2 1d 44 1a 24 60 e4 da  >.-C.ú6.@▓.D.$`õ┌<
000113 a5 56 18 94 ee 26 5e 60 7d e4 a6 0d 87 a3 99 4f  >ÑV.ö¯&^`}õª.çú.O<
000123 ce 31 73 08 7d e8 9f fe 80 0f d4 63 00 81 c7 a7  >╬1s.}Þƒ■..Èc..Ãº<
000133 46 8a ab 4a 10 12 e5 e4 a6 2f 05 10 56 12 b3 c8  >Fè½J..Õõª/..V.│╚<
000143 9f cc 3d ae 95 4c da 4c 6a e1 3a 15 fd 72 23 db  >ƒ╠=«òL┌Ljß:.²r#█<
000153 a7 a2 48 3a f4 37 e8 7a a3 74 5f c1 97 f3 98 08  >ºóH:¶7Þzút_┴ù¾..<
000163 3e 7f 3f bf 76 37 58 fc 29 69 37 ae f0 dd 20 de  >>.?┐v7X³)i7«­¦ Ì<
000173 ec be 89 bc 00 00 00 00 00 00 00 00              >ý¥ë╝........<
00017f]]></pre>

<p>Ce bloc ressemble à une structure <code>PUBLICKEYBLOB</code><span class="fn">http://msdn.microsoft.com/en-us/library/windows/desktop/aa387459(v=vs.85).aspx</span>, avec des éléments supplémentaires. Noter la chaîne « <code>RSA1</code> » indiquant qu'il s'agit d'une clé publique RSA, la taille de la clé (à l'octet <code>0x007b</code> pour une longueur de quatre octets, <code>00 08 00 00</code>est la représentation <i>little-endian</i> — ou petit-boutiste, c'est-à-dire que les octets sont ordonnés par poids croissants, donc la représentation « humaine » est <code>0x00000800</code> — de 2048), l'exposant public (<code>01 00 01 00</code>, à l'octet <code>0x0073</code>, représente 65 537) et le module (à partir de l'octet <code>0x0077</code> sur une longueur de 256 octets, toujours en représentation <i>little-endian</i>, l'octet de poids fort étant à la position <code>0x0176</code>, ce qui permet de rétablir l'ordre <i>big-endian</i> <code>0xbc89bc…</code> affiché par OpenSSL).</p>

<p>Les deux blocs suivants sont protégés par l'API de protection DPAPI<span class="fn">http://msdn.microsoft.com/en-us/library/ms995355.aspx</span> de Microsoft. Cette API propose deux fonctions, <code>CryptProtectData()</code> et <code>CryptUnprotectData()</code>, la première pour protéger un ensemble de données (de type <code>DATA_BLOB</code>, où blob signifie <i>binary lump of bits</i>, <i>binary large object</i> etc., c'est-à-dire des données binaires), la seconde pour déprotéger un <code>DATA_BLOB</code>.</p>

<p class="note">La DPAPI s'appuie en particulier sur le mot de passe de l'utilisateur pour déprotéger un bloc de données. Lorsque la session de l'utilisateur est ouverte, le mot de passe est conservé en cache et n'est pas demandé à l'utilisateur pour déprotéger les données. Lorsque la session de l'utilisateur est fermée, l'inaccessibilité du mot de passe garantit la protection des données (à concurrence de la sécurité du mot de passe).</p>

<p>Le premier bloc protégé (de l'octet <code>0x017f</code> à l'octet <code>0x0771</code>, pour une longueur de <code>0x05F2</code> ou 1522 octets) est la clé privée de l'utilisateur.</p>

<pre><strong>> od -tx1z -Ax -j0x17f -N0x05f2 <em>&lt;fichier clé privée&gt;</em></strong>
<![CDATA[00017f 01 00 00 00 d0 8c 9d df 01 15 d1 11 8c 7a 00 c0  >....ðî.▀..Ð.îz.└<
00018f 4f c2 97 eb 01 00 00 00 e9 75 b6 d6 59 ac cb 40  >O┬ùÙ....ÚuÂÍY¼╦@<
00019f a9 75 1a 04 f0 e0 f6 26 03 00 00 00 2a 00 00 00  >®u..­Ó÷&....*...<
0001af 43 00 6c 00 e9 00 20 00 70 00 72 00 69 00 76 00  >C.l.Ú. .p.r.i.v.<
0001bf e9 00 65 00 20 00 43 00 72 00 79 00 70 00 74 00  >Ú.e. .C.r.y.p.t.<
0001cf 6f 00 41 00 50 00 49 00 00 00 03 66 00 00 a8 00  >o.A.P.I....f..¿.<
0001df 00 00 10 00 00 00 ec e8 57 96 42 4a c4 da 76 f7  >......ýÞWûBJ─┌v¸<
0001ef bf 87 b5 af d0 eb 00 00 00 00 04 80 00 00 a0 00  >┐çÁ»ðÙ........á.<
0001ff 00 00 10 00 00 00 13 6b 19 40 d3 bd 0a 78 2b fa  >.......k.@Ë¢.x+·<
00020f b2 a8 e6 37 2b 0d 40 05 00 00 05 40 25 a7 62 34  >▓¿µ7+.@....@%ºb4<
…
00075f 0b 4a d3 5a cf cb c5 a7 a9 cc 05 a4 dd 55 34 72  >.JËZ¤╦┼º®╠.ñ¦U4r<
00076f 5b 12                                            >[.<
000771]]></pre>

<p>L'ingénierie inverse d'un blob protégé par la DPAPI a été décrite par Elie Bursztein et Jean-Michel Picod dans la section 3.3.1 de leur livre blanc<span class="fn">http://dpapick.com/documentation</span>, et n'est pas reprise ici. Noter simplement la chaîne « <code>Clé privé CryptoAPI\0</code> » dans le champ <code>description</code> (codé en UTF-16 <i>little-endian</i>).</p>

<p>Le second bloc protégé (couvrant les octets <code>0x0772</code> à <code>0x0818</code>, pour une longueur de <code>0x00a8</code>) a une structure analogue à la précédente. Y noter la description « <code>Export flag</code> ».</p>

<pre><strong>> od -tx1z -Ax -j0x0772 -N0xa8 <em>&lt;fichier clé privée&gt;</em></strong>
<![CDATA[000772 00 00 00 d0 8c 9d df 01 15 d1 11 8c 7a 00 c0 4f  >...ðî.▀..Ð.îz.└O<
000782 c2 97 eb 01 00 00 00 e9 75 b6 d6 59 ac cb 40 a9  >┬ùÙ....ÚuÂÍY¼╦@®<
000792 75 1a 04 f0 e0 f6 26 00 00 00 00 18 00 00 00 45  >u..­Ó÷&........E<
0007a2 00 78 00 70 00 6f 00 72 00 74 00 20 00 46 00 6c  >.x.p.o.r.t. .F.l<
0007b2 00 61 00 67 00 00 00 03 66 00 00 a8 00 00 00 10  >.a.g....f..¿....<
0007c2 00 00 00 68 33 ee a9 d9 93 7b 29 82 0e fd ed 9c  >...h3¯®┘ô{)é.²Ý£<
0007d2 03 fa e4 00 00 00 00 04 80 00 00 a0 00 00 00 10  >.·õ........á....<
0007e2 00 00 00 65 fa 8d a9 d7 1f c0 bd 56 66 b8 9b 82  >...e·.®Î.└¢Vf©øé<
0007f2 a3 4f c2 08 00 00 00 77 15 82 93 3c a1 f3 dd 14  >úO┬....w.éô<í¾¦.<
000802 00 00 00 9a 95 90 10 ea ad c8 f6 56 25 f8 2c 69  >...Üò..Û¡╚÷V%°,i<
000812 f0 5b 7c 87 31 de 4c                             >­[|ç1ÌL<
000819]]></pre>

<p>Extraire le bloc DPAPI associé à la clé privée (de l'octet <code>0x017f</code> ou 383, sur une longueur de ou 1552 octets) :</p>
<pre><strong>> dd if=<em>&lt;fichier clé privée&gt;</em> bs=1 skip=383 count=1522 of=pkey.blob</strong>
1522+0 enregistrements lus.
1522+0 enregistrements Úcrits.
1522 bytes (1,5 kB) copied, 0,0467547 seconds, -0,0 kB/s</pre>

<p>Ce bloc peut être déchiffré à l'aide de la DPAPI. À titre d'exemple, coder la clé privée ci-dessus en Base64.</p>

<pre><strong>$ openssl base64 -in pkey.blob -out pkey.blob.b64</strong></pre>

<p>Créer un fichier <code>decrypt_privkeyblob_dpapi.cs</code>, y copier le contenu du code C# d'exemple publié sur ce site<span class="fn">http://www.obviex.com/samples/dpapi.aspx</span>, et y remplacer la méthode <code>Main</code> de la classe <code>DPAPITest</code> par les lignes suivantes :</p>

<pre>[STAThread]
static void Main(string[] args) {
    try {
        string description;

        // private key blob
        string encrypted = @"AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAA6XW21lmsy0Cp…
            … <em>reste du contenu du fichier pkey.blob.b64</em> …
            kYYtLxpH/ABDbBQAAACJ9wtK01rPy8WnqcwFpN1VNHJbEg==" ;
        
        // Call DPAPI to decrypt data.
        string decrypted = DPAPI.Decrypt(   encrypted,
                                        out description);
        Console.WriteLine(decrypted) ;
    }
    catch (Exception ex) {
        while (ex != null) {
            Console.WriteLine(ex.Message);
            ex = ex.InnerException;
        }
    }
}</pre>

<p>Compiler ce code à l'aide de <code>csc</code> et exécuter la commande <code>decrypt_privkeyblob_dpapi.exe</code> pour déchiffrer la clé privée chiffrée, en notant que Windows demande l'autorisation de l'utilisateur pour accéder à la clé privée.</p>

<h1 id="code-source">Code source</h1>
<p>Cette annexe s'adresse aux lecteurs souhaitant se familiariser avec les bibliothèques sous-jacentes aux outils cryptographiques utilisés dans ce document, qui permettent tirer parti de bien plus de fonctionnalités et de paramètres que n'offrent les outils en ligne de commande.</p>
<h2 id="ocsp-sigalg">Paramétrage de l'algorithme de signature des jetons OCSP produits par OpenSSL</h2>
<p>Les jetons OCSP produits par <code>openssl ocsp</code> sont signés avec SHA-1 car dans le code source de cette commande (<code>apps/ocsp.c</code> du répertoire source d'OpenSSL), la fonction invoquée pour signer le jeton OCSP est :</p>
<pre>OCSP_basic_sign(bs, rcert, rkey, NULL, rother, flags);</pre>
<p>où <code>NULL</code> désigne l'algorithme de hachage à utiliser, soit l'algorithme de hachage par défaut associé à l'algorithme de chiffrement asymétrique (en l'occurrence RSA), défini dans <code>crypto/rsa/rsa_ameth.c</code>, c'est-à-dire SHA-1 :</p>
<pre>static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
  {
…
    case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
      *(int *)arg2 = <strong>NID_sha1</strong>;
      return 1;
…
  }</pre>
<p>Cette annexe s'intéresse à la possibilité d'utiliser l'option <code>-&lt;dgst&gt;</code> pour spécifier l'algorithme de hachage de l'algorithme de signature.</p>
<p>Dans un répertoire vide, copier depuis le répertoire source d'OpenSSL les fichiers suivants :</p>
<ul>
<li>
<code>apps/ocsp.c</code>, source de la commande <code>openssl ocsp</code>,</li>
<li>
<code>apps/apps.c</code> et <code>apps/apps.h</code>, source des fonctions auxiliaires des commandes <code>openssl</code> et en-tête associée,</li>
<li>
<code>e_os.h</code>, fichier d'en-tête définissant les spécificités liées aux environnements système.</li>
</ul>
<p>Modifier, dans le fichier <strong>ocsp.c</strong> nouvellement créé, le prototype de la fonction <code>make_ocsp_response</code>, en ajoutant un dernier paramètre définissant l'algorithme de hachage (en gras ci-dessous). Cette modification est à effectuer deux fois : une fois lors de la déclaration de la fonction (ligne terminant par « <code>;</code> ») et une fois lors de son implémentation (ligne suivie de « <code>{</code> » et du code de la fonction).</p>
<pre>static int make_ocsp_response(OCSP_RESPONSE **resp, …
    int nmin, int ndays<strong>, const EVP_MD *ocsp_id_md</strong>)</pre>
<p>Modifier les paramètres d'appel de la fonction (faire une recherche sur <code>make_ocsp_response</code>) :</p>
<pre>i = make_ocsp_response(&amp;resp, …, ndays<strong>, cert_id_md</strong>);</pre>
<p>Dans le corps de la fonction, remplacer, lors de l'appel à <code>OCSP_basic_sign</code>, le paramètre <code>NULL</code> par le nouveau paramètre <code>ocsp_id_md</code> définissant l'algorithme de hachage à utiliser lors de la signature.</p>
<pre>OCSP_basic_sign(bs, rcert, rkey, <strong>ocsp_id_md</strong>, rother, flags);</pre>
<p>À la fin du fichier, ajouter les blocs de code suivants issus de <code>apps/ca.c</code> du répertoire source d'OpenSSL :</p>
<pre>static const char *crl_reasons[] = {
    …
};

#define NUM_REASONS (sizeof(crl_reasons) / sizeof(char *))

int unpack_revinfo(ASN1_TIME **prevtm, …, const char *str)
    {
    …
    }</pre>
<p>Compiler le code source. Quelques exemples de commandes de compilation sont proposés ci-après.</p>
<p>Pour <code>gcc</code> de MinGW, en environnement Win32 :</p>
<pre><strong>> set OPENSSL_DIR=<em>&lt;répertoire d'installation d'OpenSSL&gt;</em>
> gcc -o ocsp.exe ocsp.c apps.c %OPENSSL_DIR%\include\openssl\applink.c \
  -I%OPENSSL_DIR%\include -L%OPENSSL_DIR%\bin -leay32 -lssleay32 \
  -lwsock32</strong></pre>
<p>Pour l'invite de commande de Visual Studio Express sous Windows :</p>
<pre><strong>> cl ocsp.c apps.c %OPENSSL_DIR%\include\openssl\applink.c \
  /I %OPENSSL_DIR%\include -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN \
  /link /LIBPATH:%OPENSSL_DIR%\lib libeay32.lib ssleay32.lib wsock32.lib</strong>
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 16.00.30319.01 for 80x86
Copyright (C) Microsoft Corporation.  All rights reserved.

ocsp.c
apps.c
applink.c
Generating Code...
Microsoft (R) Incremental Linker Version 10.00.30319.01
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:ocsp.exe
/LIBPATH:C:\Local\apps\openssl-1.0.1b\lib
libeay32.lib
ssleay32.lib
wsock32.lib
ocsp.obj
apps.obj
applink.obj
   Creating library ocsp.lib and object ocsp.exp</pre>
<p>Pour un environnement UNIX/Linux (en utilisant le répertoire <code>/opt/openssl-1.0.1a</code> proposé dans l'annexe sur la compilation d'OpenSSL) :</p>
<pre><strong>$ export OPENSSL_DIR=/opt/openssl-1.0.1a
$ gcc -o ocsp ocsp.c apps.c -I$OPENSSL_DIR/include -L$OPENSSL_DIR/lib -lssl \
  -lcrypto</strong></pre>
<p class="note">Des plaintes relatives à des références indéfinies à <code>dl…</code> (ex. : <code>dlopen</code>, <code>dlsym</code>) indiquent que les bibliothèques dynamiques d'OpenSSL ne sont pas disponibles (l'option <code>shared</code> de <code>./config</code> a sans doute été oubliée à la compilation, et une recompilation d'OpenSSL est alors nécessaire).</p>
<p>L'exécutable généré peut être invoqué avec les mêmes options qu'<code>openssl ocsp</code>, auxquelles s'ajoute <code>-&lt;dgst&gt;</code> pour spécifier l'algorithme de hachage (par exemple <code>-sha256</code>).</p>
<p>En environnement Linux (des modifications analogues étant à effectuer dans les autres environnements UNIX, comme suggéré dans le fichier <code>doc/openssl-shared.txt</code> du répertoire source d'OpenSSL), il convient de préciser dans la variable d'environnement <code>LD_LIBRARY_PATH</code> le chemin du répertoire dans lequel sont installées les bibliothèques dynamiques d'OpenSSL, par exemple :</p>
<pre>$ LD_LIBRARY_PATH=$OPENSSL_DIR/lib ./ocsp …</pre>
<p>S'assurer que le remplacement de <code>openssl ocsp</code> par le nouvel <code>ocsp</code> avec l'option <code>-sha-256</code> retourne bien un jeton signé avec l'algorithme attendu.</p>

<h2 id="testevroots">Génération d'un fichier <code>test_ev_roots.txt</code> pour Firefox</h2>

<p>L'outil dont le code source est proposé dans cette annexe permet de générer le contenu d'un fichier <code>test_ev_roots.txt</code> pour une AC racine (identifiée par son certificat) et un OID de PC EV SSL avec la syntaxe suivante :</p>
<pre><strong>$ gen_test_ev_roots tls-rootca-crt.pem \
  1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.2493436.1.3</strong>
1_fingerprint 43:90:8F:13:8A:57:68:BD:6D:7A:84:26:4A:F5:7A:D2:54:91:D3:18
2_readable_oid 1.2.840.113556.1.8000.2554.29563.49294.43847.16581.44480.6974059.
2493436.1.3
3_issuer MFwxCzAJBgNVBAYTAkZSMRYwFAYDVQQKEw1Nb24gT3JnYW5pc21lMRcwFQYDVQQLEw4wMDA
yIDE0NzI1ODM2OTEcMBoGA1UECxMTT3BlblNTTCBUTFMgUm9vdCBDQQ==
4_serial 37eOonwlwt0=</pre>

<p>Voici le code C du fichier source <code>gen_test_ev_roots.c</code>.</p>

<pre><![CDATA[#include <stdio.h>
#include <openssl/bio.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/bn.h>
#include <openssl/asn1.h>
#include <openssl/x509v3.h>

#include "gen_test_ev_roots.h"

int main (int argc, char **argv) {
  int res = 1 ;
  BIO *err=NULL;
  BIO *cert=NULL;
  BIO *out=NULL;
  X509 *x=NULL;
  
  /* Check command-line syntax */
  if (argc != 3) {
    fprintf (stderr, "Error - Expected syntax is:\n") ;
    fprintf (stderr, 
      "gen_test_ev_roots <EV OID> <PEM-encoded CA certificate file>\n") ;
    res = 1 ;
    goto end ;
  }

  /* Initialise stderr/stdout BIO */
  err = BIO_new_fp(stderr,BIO_NOCLOSE);
  out = BIO_new_fp(stdout,BIO_NOCLOSE);
  
  /* Initialise input file BIO */
  if ((cert=BIO_new(BIO_s_file())) == NULL) {
    ERR_print_errors(err);
    goto end;
  }
  
  /* Open file for reading */
  if (!BIO_read_filename(cert,argv[1])) {
    BIO_printf(err, "Error - Cannot open file %s\n", argv[1]);
    ERR_print_errors(err);
    goto end;
  }

  /* Read PEM-encoded certificate */
  x = PEM_read_bio_X509(cert, NULL, NULL, NULL);
  if (x == NULL) {
    BIO_printf(err,
      "Error - Cannot read certificate (hint: check content of file %s)\n",
      argv[1]);
    ERR_print_errors(err);
    goto end;
  }
  
  /* Output each line */
  if (res = output_fingerprint (out, err, x)) goto end ;
  if (res = output_OID (out, err, argv[2])) goto end ;
  if (res = output_issuer (out, err, x)) goto end ;
  if (res = output_serialNumber (out, err, x)) goto end ;
    
end:
  if (x != NULL) X509_free(x);
  if (cert != NULL) BIO_free(cert);
  return res ;
}

int output_fingerprint (BIO *out, BIO *err, X509 *x) {
  int j;
  unsigned int len;
  unsigned char md[EVP_MAX_MD_SIZE];
  
  if (!X509_digest(x,EVP_sha1(),md,&len)) {
    BIO_printf(err,
      "Error - Out of memory while calculating certificate fingerprint\n");
    return 1 ;
  }
  
  BIO_printf(out, "1_fingerprint ") ;
  for (j=0; j<len; j++) {
    BIO_printf(out,"%02X%c",md[j], (j+1 == (int)len)?'\n':':');
  }
  
  return 0 ;
}

int output_OID (BIO *out, BIO *err, char *oid) {
  if (OBJ_txt2obj(oid, 1) == NULL) {
    BIO_printf(err,"Error - Invalid OID %s\n", oid);
    return 1 ;
  }
  BIO_printf(out, "2_readable_oid %s\n", oid) ;
  return 0 ;
}

int output_issuer (BIO *out, BIO *err, X509 *x) {
  X509_NAME *issuer ;
  BIO *b64 ;

  if ((b64 = BIO_push(BIO_new(BIO_f_base64()), out)) == NULL) {
    BIO_printf(err,
      "Error - Cannot initialise Base64 output filter for issuer\n");
    return 1 ;
  } 
  BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL) ;
  
  BIO_printf(out, "3_issuer ") ;
  
  issuer = X509_get_issuer_name(x) ;
  ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509_NAME), b64, issuer);
  BIO_flush(b64);
  
  BIO_printf(out, "\n") ;
  return 0 ;
}

int output_serialNumber (BIO *out, BIO *err, X509 *x) {
  ASN1_INTEGER *serial ;
  BIO *b64 ;
  BIGNUM *bn = NULL ;
  unsigned char *binserial = NULL ;
  int len ;
  int res = 1 ;

  if ((b64 = BIO_push(BIO_new(BIO_f_base64()), out)) == NULL) {
    BIO_printf(err,
      "Error - Cannot initialise Base64 output filter for serial number\n");
    goto end ;
  } 
  BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL) ;
  
  serial = X509_get_serialNumber(x) ;
  bn = ASN1_INTEGER_to_BN (serial, NULL) ;
  len = BN_num_bytes(bn);
  binserial = malloc(len) ;
  if (BN_bn2bin(bn, binserial) != len) {
    BIO_printf(err,
      "Error - Cannot get a binary representation of serial number\n");
    goto end ;
  }
  
  BIO_printf(out, "4_serial ") ;
  /* Assuming that serial number is positive, prepend 0x00 if first byte
     of serial number is >= 0x80 */
  if (binserial[0] & 0x80) {
    BIO_write(b64, "\0", 1);
  }
  BIO_write(b64, binserial, len);
  BIO_flush(b64);

  BIO_printf(out, "\n") ;
  
  res = 0 ;
end:
  if (bn != NULL) BN_free (bn) ;
  if (binserial != NULL) free (binserial) ;
  return res ;
}]]></pre>

<p>Le code ne présente pas de difficulté de compréhension particulière : il s'appuie essentiellement sur les fonctions proposées par la libcrypto d'OpenSSL. La production par la fonction <code>output_serialNumber()</code> de la ligne correspondant au numéro de série mérite toutefois quelques explications.</p>

<p>La valeur à inclure pour le champ <code>4_serial</code> n'est pas le numéro de série à proprement parler mais le contenu des octets de valeur du codage DER de l'<code>INTEGER</code> représentant le numéro de série, qui nécessite de tenir compte d'une petite particularité liée à la gestion des nombres négatifs. Si le premier octet de la représentation hexadécimale du numéro de série est supérieur ou égal à <code>0x80</code>, alors, pour être considéré comme un nombre positif, il doit être précédé, dans la représentation DER de sa valeur, par un octet <code>0x00</code>. Ainsi, la représentation DER du champ de valeur du nombre décimal 127 est <code>0x7F</code>, et celle de 128 est <code>0x00 0x80</code> (tandis que <code>0x80</code> correspond à -128).</p>
<p class="note">Des exemples de codage DER d'entiers sont proposés par Burton S. Kaliski Jr. dans la section 5.7 de son document <i>A Layman's Guide to a Subset of ASN.1, BER, and DER</i> <span class="fn">http://luca.ntop.org/Teaching/Appunti/asn1.html</span>.</p>

<p>Ainsi, en supposant que le numéro de série du certificat est un entier positif (ce qui est imposé par la RFC 5280), un octet <code>0x00</code> est ajouté en début de numéro de série.</p>

<p>Créer le fichier d'en-tête <code>gen_test_ev_roots.h</code> suivant.</p>

<pre><![CDATA[#include <openssl/bio.h>
#include <openssl/x509.h>

int output_fingerprint (BIO *out, BIO *err, X509 *x) ;
int output_OID (BIO *out, BIO *err, char *oid) ;
int output_issuer (BIO *out, BIO *err, X509 *x) ;
int output_serialNumber (BIO *out, BIO *err, X509 *x) ;]]></pre>

<p>Compiler le code à l'aide de l'une des lignes de commande suivantes.</p>

<p>Pour <code>gcc</code> de MinGW, en environnement Win32 :</p>
<pre><strong>> set OPENSSL_DIR=<em>&lt;répertoire d'installation d'OpenSSL&gt;</em>
> gcc -o gen_test_ev_roots.exe gen_test_ev_roots.c -I%OPENSSL_DIR%\include \
  -L%OPENSSL_DIR%\bin -leay32</strong></pre>
  
  <p>Pour l'invite de commande de Visual Studio Express sous Windows :</p>
<pre><strong>> set OPENSSL_DIR=<em>&lt;répertoire d'installation d'OpenSSL&gt;</em>
> cl gen_test_ev_roots.c /I %OPENSSL_DIR%\include /link \
  /LIBPATH:%OPENSSL_DIR%\lib libeay32.lib</strong></pre>

<p>Pour un environnement UNIX/Linux (en utilisant le répertoire <code>/opt/openssl-1.0.1a</code> proposé dans l'annexe sur la compilation d'OpenSSL) :</p>
<pre><strong>$ export OPENSSL_DIR=/opt/openssl-1.0.1a
$ gcc -o gen_test_ev_roots gen_test_ev_roots.c -I$OPENSSL_DIR/include \
  -L$OPENSSL_DIR/lib -lcrypto</strong></pre>
  
  <p class="note">Se reporter à la fin de l'annexe <a href="#ocsp-sigalg" class="appendix_section"/> pour des explications sur l'exécution de fichier résultant avec une bibliothèque dynamique située dans un répertoire non standard.</p>

<h1 id="legal">Considérations légales</h1>
<h2 id="conditions-utilisation">Conditions d'utilisation de ce document</h2>
<p>Le texte de ce document est disponible sous licence <i>Creative Commons</i> paternité partage à l’identique<span class="fn">http://creativecommons.org/licenses/by-sa/3.0/deed.fr</span>, à l'exception des éléments recensés ci-dessous, soumis à des conditions d'utilisation spécifiques non compatibles avec cette licence.</p>
<p>Les captures d'écran des produits Microsoft sont utilisées avec l'autorisation de Microsoft<span class="fn">http://www.microsoft.com/About/Legal/EN/US/IntellectualProperty/Permissions/Default.aspx</span>.</p>
<p>Les extraits de documents normatifs sont cités conformément à l'article 10.1 de la convention de Berne<span class="fn">http://www.wipo.int/treaties/fr/ip/berne/trtdocs_wo001.html</span>.</p>
<p>L'utilisation de code source dérivé du code source d'OpenSSL est soumis aux exigences ci-dessous.</p>
<pre>  Copyright (c) 1999 The OpenSSL Project.  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer. 

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

  3. All advertising materials mentioning features or use of this
     software must display the following acknowledgment:
     "This product includes software developed by the OpenSSL Project
     for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"

  4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     endorse or promote products derived from this software without
     prior written permission. For written permission, please contact
     licensing@OpenSSL.org.

  5. Products derived from this software may not be called "OpenSSL"
     nor may "OpenSSL" appear in their names without prior written
     permission of the OpenSSL Project.

  6. Redistributions of any form whatsoever must retain the following
     acknowledgment:
     "This product includes software developed by the OpenSSL Project
     for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"

  THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
  EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
<h2 id="droit-marques">Droit des marques</h2>
<p>Toutes les marques déposées sont la propriété de leurs détenteurs respectifs, en particulier :</p>
<ul>
<li>Microsoft, Windows et Internet Explorer sont des marques déposées de Microsoft Corporation<span class="fn">http://www.microsoft.com/about/legal/en/us/IntellectualProperty/Trademarks/EN-US.aspx</span> aux États-Unis et dans d'autres pays.</li>
<li>UNIX est une marque déposée de The Open Group<span class="fn">http://www.unix.org/trademark.html</span>.</li>
<li>Mac OS et Apple sont des marques déposées d’Apple Computer Inc<span class="fn">http://www.apple.com/legal/trademark/appletmlist.html</span>.</li>
<li>Adobe et Reader sont des marques déposées d’Adobe System Incorporated<span class="fn">http://www.adobe.com/misc/trade.html</span>.</li>
<li>RSA Security est une marques déposée d’EMC Corporation<span class="fn">http://www.emc.com/legal/emc-corporation-trademarks.htm#rsa</span>.</li>
</ul>
<p class="note">Les symboles « ™ » et « ® » n'ayant aucune portée juridique en France<span class="fn">www.inpi.fr/fr/questions-faq/liste-des-questions/faq_categorie/autres-questions415.html</span>, ils ont été omis des noms de marque ci-dessus. Ils sont à restituer pour toute adaptation de ce document dans un pays où ils ont cours (en particulier dans les pays soumis à la <i>common law</i>).</p>
<h2 id="usage-crypto">Usage de la cryptographie</h2>
<p>Les lois régissant les conditions d'utilisation de la cryptographie variant en fonction des pays, l'auteur recommande vivement au lecteur de se renseigner sur les lois qui lui sont applicables (le panorama des lois cryptographiques<span class="fn">http://rechten.uvt.nl/koops/cryptolaw/</span> de Bert-Jaap Koops est un bon point de départ), et ne pourra nullement être tenu responsable de toute infraction commise par le lecteur dans ce domaine.</p>
<h2 id="attributions">Attributions</h2>
<p>Ce document s'appuie sur du code et des applications cryptographiques écrits par Eric A. Young (eay@cryptsoft.com) et Tim J. Hudson (tjh@cryptsoft.com).</p>
<p>
<i>This product includes cryptographic software written by Eric A. Young (eay@cryptsoft.com). This product includes software written by Tim J. Hudson (tjh@cryptsoft.com).</i>
</p>
<h1 id="acronymes-sigles">Acronymes et sigles</h1>

<dl>
<dt>3DES</dt><dd><i>Triple DES</i></dd>
<dt>3TDEA</dt><dd><i>Triple Data Encryption Algorithm, keying option 1</i></dd>
<dt>AC</dt><dd>autorité de certification</dd>
<dt>AES</dt><dd><i>Advanced Encryption Standard</i></dd>
<dt>ANSI</dt><dd><i>American National Standards Institute</i></dd>
<dt>API</dt><dd><i>Application Programming Interface</i></dd>
<dt>ASCII</dt><dd><i>American Standard Code for Information Interchange</i></dd>
<dt>ASN.1</dt><dd><i>Abstract Syntax Notation One</i></dd>
<dt>BER</dt><dd><i>Basic Encoding Rules</i></dd>
<dt>BES</dt><dd><i>Basic Electronic Signature</i></dd>
<dt>BOM</dt><dd><i>byte order mark</i></dd>
<dt>CA</dt><dd><i>certificate Authority</i></dd>
<dt>CAdES</dt><dd><i>CMS Advanced Electronic Signature</i></dd>
<dt>CBC</dt><dd><i>cipher-block chaining</i></dd>
<dt>CMS</dt><dd><i>Cryptographic Message Syntax</i></dd>
<dt>CN</dt><dd><i>Common Name</i></dd>
<dt>CRL</dt><dd><i>certificate revocation list</i></dd>
<dt>CSP</dt><dd><i>cryptographic service provider</i></dd>
<dt>CSR</dt><dd><i>certificate signature request</i></dd>
<dt>DER</dt><dd><i>Distinguished Encoding Rules</i></dd>
<dt>DES</dt><dd><i>Data Encryption Standard</i></dd>
<dt>DN</dt><dd><i>Distinguished Name</i></dd>
<dt>DPAPI</dt><dd><i>Data Protection API</i></dd>
<dt>DSA</dt><dd><i>Digital Signature Algorithm</i></dd>
<dt>ERS</dt><dd><i>Evidence Record Syntax</i></dd>
<dt>EV</dt><dd><i>Extended Validation</i></dd>
<dt>EXSLT</dt><dd><i>extensions to XSLT</i> (non officiel)</dd>
<dt>FAI</dt><dd>fournisseur d'accès à Internet</dd>
<dt>FAQ</dt><dd><i>Frequently Asked Questions</i> ou foire aux questions</dd>
<dt>GOST</dt><dd>standards d'État, du russe <i>ГОСТ</i> pour <i>Государственный стандарт</i></dd>
<dt>GUID</dt><dd><i>Globally Unique IDentifier</i></dd>
<dt>HTTPS</dt><dd><i>Hypertext Transfer Protocol Secure</i></dd>
<dt>ICP</dt><dd>infrastructure à clés publiques</dd>
<dt>IETF</dt><dd><i>Internet Engineering Task Force</i></dd>
<dt>IGC</dt><dd>infrastructure de gestion de clés</dd>
<dt>IIS</dt><dd><i>Internet Information Services</i></dd>
<dt>IP</dt><dd><i>Internet Protocol</i></dd>
<dt>ITU</dt><dd><i>International Telecommunication Union</i></dd>
<dt>LCR</dt><dd>liste de certificats révoqués</dd>
<dt>MIME</dt><dd><i>Multipurpose Internet Mail Extensions</i></dd>
<dt>OCSP</dt><dd><i>Online Certificate Status Protocol</i></dd>
<dt>OID</dt><dd><i>Object IDentifier</i></dd>
<dt>OU</dt><dd><i>Organizational Unit</i></dd>
<dt>PAdES</dt><dd><i>PDF Advanced Electronic Signature</i></dd>
<dt>PC</dt><dd>politique de certification</dd>
<dt>PEM</dt><dd><i>Privacy Enhanced Mail</i></dd>
<dt>PKCS</dt><dd><i>public-key cryptography standard</i></dd>
<dt>PKI</dt><dd><i>Public Key Infrastructure</i></dd>
<dt>RDN</dt><dd><i>Relative Distinguished Name</i></dd>
<dt>RFC</dt><dd><i>Request For Comment</i></dd>
<dt>RGS</dt><dd>référentiel général de sécurité</dd>
<dt>RSA</dt><dd><i>Rivest, Shamir, Adleman</i></dd>
<dt>SHA</dt><dd><i>Secure Hash Algorithm</i></dd>
<dt>SMIME</dt><dd><i>Secure/Multipurpose Internet Mail Extensions</i></dd>
<dt>SSL</dt><dd><i>Secure Sockets Layer</i></dd>
<dt>SVN</dt><dd><i>Apache Subversion</i></dd>
<dt>TLS</dt><dd><i>Transport Layer Security</i></dd>
<dt>TSP</dt><dd><i>Time-Stamp Protocol</i></dd>
<dt>URL</dt><dd><i>uniform resource locator</i></dd>
<dt>UTC</dt><dd>Temps universel coordonné</dd>
<dt>UTF-8</dt><dd><i>Universal Character Set (UCS) transformation format 8 bits</i></dd>
<dt>UUID</dt><dd><i>universally unique identifier</i></dd>
<dt>WYSIWYS</dt><dd><i>What You See Is What You Sign</i></dd>
<dt>XAdES</dt><dd><i>XML Advanced Electronic Signature</i></dd>
<dt>XER</dt><dd><i>XML Encoding Rules</i></dd>
<dt>XML</dt><dd><i>Extensible Markup Language</i></dd>
<dt>XSLT</dt><dd><i>eXtensible Stylesheet Language Transformations</i></dd>
</dl>

</div>
<div class="backmatter">

<h1 id="colophon">Colophon</h1>
<p>Consultant puis chef de projet, Sébastien Pujadas a découvert la confiance électronique au début des années 2000. Il a également été traducteur, auteur et relecteur pour les éditions O'Reilly France. Son profil professionnel complet est publié sur LinkedIn : http://www.linkedin.com/in/spujadas</p>
<p>La source de ce document est en XHTML<span class="fn">http://www.w3.org/TR/xhtml1/</span>, et la mise en forme est assurée à l'aide d'une CSS<span class="fn">http://www.w3.org/TR/CSS2/</span> initialement construite à partir d'un fichier d'exemple<span class="fn">http://www.princexml.com/howcome/2008/wikipedia/wiki2.css</span> d'utilisation de Prince.</p>
<p>La cohérence des renvois de section et de page est vérifiée à l'aide d'un schéma Schematron<span class="fn">http://www.schematron.com/</span> (<code>validatedoc.sch</code>), dont le résultat est mis en forme par une transformation XSLT (fichier <code>validatedoc.xslt</code>), à l'aide de la ligne de commande suivante (les autres fichiers sont ceux de Schematron) :</p>
<pre><strong>
$ xsltproc schematron/iso_dsdl_include.xsl validatedoc.sch \
  | xsltproc schematron/iso_abstract_expand.xsl - \
  | xsltproc schematron/iso_svrl_for_xslt1.xsl - \
  | xsltproc --nonet - tp-confiance.xhtml \
  | xsltproc validatedoc.xslt -</strong></pre>
<p>La version PDF de ce document est générée à partir des fichiers XHTML et CSS en utilisant l'outil Prince<span class="fn">http://www.princexml.com/</span> et la ligne de commande suivante :</p>
<pre><strong>$ prince --no-author-style --javascript -s doc.css tp-confiance.xhtml \
  -o tp-confiance.pdf</strong></pre>
<p>La production du fichier PDF par Prince inclut la génération automatisée de la table des matières à l'aide d'un script JavaScript (<code>toc.js</code>) adapté d'un message<span class="fn">http://www.princexml.com/bb/viewtopic.php?f=5&amp;t=14898</span> posté sur le forum de Prince.</p>
<p>Le texte courant est composé en Gentium <span class="fn">http://scripts.sil.org/gentium</span>, le code est composé en Latin Modern<span class="fn">http://www.gust.org.pl/projects/e-foundry/latin-modern/index_html</span>.</p>
<p>Ce document a été rédigé de mars à juillet 2012, puis finalisé et publié en octobre 2013 par Sébastien Pujadas.</p>
</div>
</body>
</html>
